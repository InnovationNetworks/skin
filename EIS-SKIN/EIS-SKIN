;SKIN
;====
;
;Simulating Knowledge Dynamics in Innovation Networks
;
;SKIN is a multi-agent model of innovation networks in knowledge-intensive industries grounded in empirical research and theoretical frameworks from innovation economics and economic sociology. The agents represent innovative firms who try to sell their innovations to other agents and end users but who also have to buy raw materials or more sophisticated inputs from other agents (or material suppliers) in order to produce their outputs. This basic model of a market is extended with a representation of the knowledge dynamics in and between the firms. Each firm tries to improve its innovation performance and its sales by improving its knowledge base through adaptation to user needs, incremental or radical learning, and co-operation and networking with other agents.
;
;CREDITS
;-------
;
;To cite the SKIN model please use the following acknowledgement:
;
;Gilbert, Nigel, Ahrweiler, Petra and Pyka, Andreas (2010) The SKIN (Simulating Knowledge Dynamics in Innovation Networks) model.  University of Surrey, Johannes Gutenberg University Mainz and University of Hohenheim.
;
;Copyright 2003 - 2017 Michel Schilperoord, Nigel Gilbert, Petra Ahrweiler and Andreas Pyka. All rights reserved.
;
;Permission to use, modify or redistribute this model is hereby granted, provided that both of the following requirements are followed: a) this copyright notice is included. b) this model will not be redistributed for profit without permission and c) the requirements of the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License <http://creativecommons.org/licenses/by-nc-sa/3.0/> are complied with.
;
;The authors gratefully acknowledge funding during the course of development of the model from the European Commission, DAAD, and the British Council.
;
;
;
; This code is an adaptation of the SKIN model to the study scope of
;    "Enabling Innovation by Simulation (EIS)"
;
;
; version 2.0    25 August    2003
; version  .1    1  September 2003   Bugs caused by extreme parameter values removed
;                                    Partnerships added
; version  .2    17 September 2003   Networks added
; version  .3    26 October   2003   Some network bugs removed and plots added
; version  .4     1 November  2003   Economy added
; version  .5     8 November  2003   Bugs, converted to NetLogo 2.0
; version  .7    12 November  2003   Partners cannot be from networks
; version  .9    13 November  2003   (Hamburg) Network bugs removed
; version 3.0    14 November  2003   Tidy up; make environmental inputs and outputs product ranges
; version  .2    27 December  2003   Changed incremental research direction setting
; version  .3    27 December  2003   Network graphics
; version  .6     2 January   2004   Herfindahl index, bug fixes, shorter partner search
; version  .7    15 February  2004   Connectivity graph; variable start-ups; random initial capital;
;                                    increased radical research threshold; changed network display
; version  .8    24 January   2006   Added degree distribution plot
; version  .9    31 May       2006   Added code for Behaviour Space runs
; version 4.0    16 June      2006   Real valued abilities, many bug fixes
; version 4.22   16 August    2006   IH no longer dependent on Abilities
;                                    Networks now cost partners to create
; version 4.23   19 August    2006   Stop crashing in make-networks
; version 4.24   19 August    2006   reward-to-trigger-start-up adjusted to 950
; version 4.27    5 September 2006   Increase final-price; changed back to map-artefact; using cost-plus pricing;
;                                    Incr-step now proportional to capability value
; version 5      23 April     2010   Stripped down and simplified version of v4.29, converted to NetLogo 4.1
; infso             August    2011   Adaptation of version 5 for DG INFSO study scope
; ipse              October   2014   Adaptation of version 5 for IPSE study scope
; eis               July      2016   Adaptation of version 5 for EIS study scope


extensions [array table matrix sql pathdir]


;;; SIMULATION OUTLINE
;;;
;;; the scope of the simulation, modules and main stages, and instruments to explore

;   Capabilities:
;   -------------
;     - 1000 different capabilities
;     - 10 research themes
;     - 40 sector capabilities per theme
;     - 40 common capabilities per theme
;     - 20 rare capabilities per theme
;     We fill half of the capability vectors in the starting distribution with sector capabilities.
;     We give rare capabilities in the starting distribution exclusively to SMEs, start-ups and entrepreneurs.
;
;   Agents:
;   -------
;     INS - research institutes (extra-university, other)
;     IM  - intermediaries
;     LDF - large diversified firms, incl. multinationals
;     SME - "Mittelstand"
;     SU  - start-ups, incl. spin-offs
;     EN  - entrepreneurs
;
;   Extra-university research institutes:
;     At the core of the simulation model are the extra-university research institutes (INS).
;     Their role includes research, innovation, technology transfer, incl. patenting, and start-up creation.
;     The prototype concentrates on participation of institutes in the initiation and development of networks.
;
;   Networks:
;   ---------
;     R-networks: networks for collaborative research
;     I-networks: partnerships and alliances for innovation
;     T-networks: partnerships for technology transfer, incl. patenting
;     E-networks: entrepreneurial support for start-up development, incl. spinoffs
;
;                     previous     current      previous & current
;                     partners:    partners:    partners:
;     R-networks:       Rp           Rc           R
;     I-networks:       Ip           Ic           I
;     T-networks:       Tp           Tc           T
;     E-networks:       Ep           Ec           E
;
;   Main stages:
;   ------------
;     The model iterates over four stages.
;
;     Stage 0 - General system environment
;       Exogenous scenario for the general system environment
;
;     Stage 1 - Agent metabolism, agents do R&D
;       Agents pursue their innovation strategies, go-it-alone or in collaboration (see Stage 2)
;
;     Stage 2 - The four network development cycles (R/I/T/E)
;       Stage 2.1 - R-networks (Research)
;         Agents develop proposals, proposals are evaluated, consortia carry out projects
;       Stage 2.2 - I-networks (Innovation)
;         Agents pursue their innovation strategies, in collaboration with partners, creating new networks
;       Stage 2.3 - T-networks (Technology Transfer)
;         Firms develop their technologies, in collaboration with research institutes
;       Stage 2.4 - E-networks (Entrepreneurship)
;         Entrepreneurs develop their start-up propositions, supported by networks
;
;     Stage 3 - Firms do business
;       Stage 3.1 - Market transactions
;         Firms buy, manufacture and sell
;       Stage 3.2 - Profits & taxes
;         Firms take profits and pay taxes
;
;     Stage 4 - Agent do valuations, market structure change
;       Stage 4.1 - Market valuations
;         Agents make market valuations
;       Stage 4.2 - Start-ups
;         Entrepreneurs create start-ups
;       Stage 4.3 - Entry of firms
;         Firms make entry decisions
;       Stage 4.4 - Exit of firms
;         Firms make exit decisions
;
;   Modules:
;   --------
;     The main stages (see above) each have their own module. These are called "flow" modules.
;     Procedures and global variables are given a module prefix, followed by ":"
;
;       s-module: System
;       %-module: Metabolism
;       r-module: R-networks   (Stage 1.1)
;       i-module: I-networks   (Stage 1.2)
;       t-module: T-networks   (Stage 1.3)
;       e-module: E-networks   (Stage 1.4)
;       $-module: Transactions (stage 2)
;       v-module: Valuations   (stage 3)
;
;     In addition to the flow modules, there are "observer" modules:
;       K-module: for monitoring the knowledge landscape
;       P-module: for monitoring proposals and projects
;       N-module: for monitoring networks and computing network statistics
;       L-module: for logging the model stages
;
;     No prefix (just ":") have procedures and globals for
;       - setting up the model
;       - building and monitoring the population of agents
;       - importing the empirical case data
;       - stepping the model and logging the main model activity
;       - ending the simulation and exporting the main results
;       - the user interface
;
;   Instruments:
;
;     Public research funding:
;       BM: a generic type of R&D project funded by the German ministeries
;       EC: a generic type of R&D project funded by the EC (FP7, H20)
;
;     Technology transfer:
;       CR: a generic model for contract research
;       PL: a generic model for patenting / licensing (*)
;       SO: a generic model for spin-off development (*)
;
;     (* Instruments that require a TTO connected to an institute)
;
;   Enabling Innovation:
;   --------------------
;     Across the main stages, a strategy is implemented for extra-university research institutes
;     to manage their research / innovation capacity and performance.
;     This strategy looks at two sets of scores:
;
;                       SCI scores          EI scores
;                       ------------        -----------------
;       R-networks:     publications        contract research
;       I-networks:                         collaborations
;       T-networks:                         patents, licenses
;       E-networks:                         spinoffs
;
;   EI strategy:
;   ------------
;
;     The strategy targets the allocation of capital and resources (Grundfinanzierung, Drittmittel)
;     and is implemented as a set of weights.
;
;       SCI capacity | SCI performance    <--- x --->    EI performance | EI capacity
;             ^                ^               |                ^              ^
;             |                |               v                |              |
;             |                |            strategy            |              |
;             |                |               |                |              |
;             |                |               v                |              |
;          resources  <---  success  <---  evaluation  --->  success  --->  resources
;          allocation                                                       allocation
;
;     The rewards of success include higher levels of Grundfinanzierung and Drittmittel.
;
;   Scenarios:
;   ----------
;     Scenarios are defined by means of Instrument-settings and Enabling innovation strategies:
;
;                          Baseline                     What-if
;                          scenario                    scenarios
;                        ------------    ------------------------------------
;                                           high weight         high weight
;                                           on SCI              on EI
;                        ------------    ------------------------------------
;       R-networks:          BM, EC           X
;       I-networks:          CR                                  X
;       T-networks:          TT                                  X
;       E-networks:          SU                                  X
;
;   R-networks:
;   -----------
;     Stage r1 - Agents (that have enough room) develop research proposals
;     Stage r2 - Proposals are evaluated
;     Stage r3 - Consortia carry out projects
;
;     Status:                          Next status:                            Go into stage:
;       0                                to 1, if enough room                    r1 - Initiating the proposal
;       1 - Proposal "initiated"         to 3, if enough partners                   - Developing the proposal (inviting partners)
;       2 - Proposal "stopped"           not enough partners
;       3 - Proposal "submitted"         to 4 or 5, depending on evaluation      r2 - Evaluation of proposal (eligibility)
;       4 - Proposal "eligible"          to 6 or 7, depending on evaluation         - Evaluation of proposal (ranking)
;       5 - Proposal "ineligible"
;       6 - Proposal "accepted"          to 8
;       7 - Proposal "rejected"          to 8
;       8 - Proposal "dissolved"         to 9, if proposal is accepted              - Creating the project
;       9 - Project "started"            to 10, after duration of project        r3 - Creating the deliverables
;      10 - Project "ended"              to 11, after evaluation                    - Evaluation of project
;      11 - Project "dissolved"          Stop. Project successful?
;
;   I-networks:
;   -----------
;     Stage i1 - Firms (that are already in successful partnerships) initiate proposals to partner with a TC
;     Stage i2 - Proposals are evaluated (firms also need to contribute, for example hire staff at the TC)
;     Stage i3 - Partners create new innovation networks
;
;     Status:                          Next status:                            Go into stage:
;       0                                to 1, if in successful partnership      r1 - Initiating the proposal
;       1..7 - as above
;       8 - Proposal "dissolved"         to 9, if proposal is accepted              - Creating the network
;       9 - Network "started"            to 10, if network not successful        i3 - Innovate and reward the partners
;      10 - Network "ended"              to 11, after evaluation                    - Evaluation of network
;      11 - Network "dissolved"          Stop. Network successful?
;
;   T-networks:
;   -----------
;     Stage t0 - TTOs assess and protect IP
;     Stage t1 - TTOs search partner companies
;     Stage t2 - Development plans are evaluated
;     Stage t3 - Partners develop the technology
;
;     Status:                          Next status:                                      Go into stage:
;       0 - Technology "identified"      to 1, if IP created at university &               t0 - Assessing the technology
;         - Technology "assessed"              if IP worth protecting &                       - Protecting the technology
;         - Technology "protected"             if IP ownership agreed with university      t1 - Writing the development plan
;       1 - Proposal "initiated"         to 3, if a company is selected to be partner         - Developing the proposal (searching for candidate partners)
;       2..7 - as above
;       8 - Proposal "dissolved"         to 9, if proposal is accepted                        - Start the tech transfer partnership
;                                        to 1, if proposal is rejected                        - Discuss the plan with the next candidate
;       9 - Partnership "started"        to 10, after duration (agreed timeframe)          t3 - Develop the technology and reward the partners and university
;      10 - Partnership "ended"          to 11, after evaluation                              - Evaluation of transfer
;      11 - Partnership "dissolved"      Stop. Transfer successful?
;
;    E-networks:
;    -----------
;     Stage e1 - Start-ups apply for support
;     Stage e2 - Applications are evaluated
;     Stage e3 - Start-ups develop their business
;
;     Status:                          Next status:                            Go into stage:
;       0                                to 1, if start-up has high potential              e1 - Initiating the proposal
;       1..7 - as above
;       8 - Proposal "dissolved"         to 9, if proposal is accepted                        - Supporting the start-up
;       9 - Support "started"            to 10, after duration (agreed timeframe)          e3 - Develop the business and reward the start-up
;      10 - Support "ended"              to 11, after evaluation                              - Evaluation of support
;      11 - Support "dissolved"          Stop. Support successful?


globals [
    ;;; Parameters
    ;;;

    ; Model-settings
;   System?
;   Metabolism?
;   R-Networks?                            * switch on/off stage 1.1
;   I-Networks?                            * switch on/off stage 1.2
;   T-Networks?                            * switch on/off stage 1.3
;   E-Networks?                            * switch on/off stage 1.4
;   Transactions?                          * switch on/off stage 2
;   Valuations?                            * switch on/off stage 3

    ; System-settings
;   Survival-threshold                     * the survival threshold
;   Growth-threshold                       ; TO DO: growth threshold not implemented yet

    ; Participants-settings
    #:Participant-types                    ; <?> = INS, IMD, LDF, SME, SUP, ENT or FND
    #:n
;   nInstitutes                            * number of research institutes (INS)
    nIntermediaries                        ; number of intermediaries (IMD)
;   nFirms                                 * number of firms (LDF, SME, SUP)
    nEntrepreneurs                         ; number of entrepreneurs (ENT)
    nAgencies                              ; number of funding agencies (FND)
;   Perc-<?>                               * percentage of type <?> firms
;   Size-INS                               * size (kene length) of research institutes
    Size-IMD                               ; size (kene length) of intermediaries
;   Size-<?>                               * size (kene length) of type ? firms
    Size-SUP                               ; size (kene length) of start-ups
    Size-ENT                               ; size (kene length) of entrepreneurs

    ; Institutes-settings
    I:Organisation-types                   ;  <?> = FhG, HGF, WGL or MPG
    I:n
;   Perc-SCI-<?>                           * share of infra resources invested by type <?> institutes in SCI capacity
    I:Perc-SCI
;   Perc-EI-<?>                            * share of non-infra resources invested by type <?> institutes in EI capacity
    I:Perc-EI

    ; Instruments-settings                 ; <?> = BM, EC, CR, PL or SO
    P:Project-types
    P:n
    P:Contribution                         ; contribution (per month and partner) for type <?> projects
    P:Duration-avg                         ; duration (number of months) of type <?> projects
    P:Duration-stdev
    P:Match                                ; number of capabilities in the call's range which must appear in an eligible type <?> proposal
;   P:Size                                 ; desired size (number of partners) of type <?> projects (not implemented yet)
    P:Size-min                             ; smallest size of type <?> projects (0 if not limited)
    P:Size-max                             ; largest size of type <?> projects (999 if not limited)
                                           ; TO DO: desired project size not implemented yet (size ~ match)

    ; Calls-settings                       ; <?> = BM, FP7 or H20
    P:Funding-calls                        ; funding available for call <?>
    P:Themes-calls                         ; thematic orientation (number of themes) of call <?>
    P:Orientation-calls                    ; research orientation (0 basic .. 9 applied) of call <?>
    P:Range-calls                          ; number of capabilities (range) which are desired for call <?> proposals

    ; Themes-settings
    K:nCapabilities                        ; global number of capabilities possible
    K:nThemes                              ; global number of themes possible
    K:Rare-capabilities-per-theme          ; number of "rare" capabilities (per theme) given exclusively to SMEs, SUs and ENs
    K:Sector-capabilities-per-theme        ; number of "sector" capabilities (per theme) used to fill half of capability vector

    ; Funding-settings
;   P:Funding                              * total funding for all calls
                                           ; TO DO: international scope of funding not implemented yet

    ;;; Parameters without presets
    ;;;

;   %:Infra-resources-ratio                * ratio of (physical) infrastructure resources to non-infrastructure resources
;   %:Pooled-cap-ratio                     * ratio of pooled SCI/EI capacity to own SCI/EI capacity
;   %:Cap-depreciation                     * both SCI and EI capacity undergo depreciation over time, and must be topped up by resource allocation

    &:Inc-step                             ; size of step change in ability, made in incremental research
    &:Low-capital-threshold                ; if a firm's capital is below this, it does radical research

    $:Capital-knowledge-ratio              ; proportionality between kene length and firm's capital
    $:Initial-capital-SME                  ; the capital that a SME starts with
    $:Delta                                ; the amount by which a product can differ from the value of an input and still be useable for that input
    $:End-products                         ; the outputs that are bought by the end-user (final consumers) are numbered greater than (nProducts - End-products)
    $:Final-price                          ; the selling price of a unit sold to the end-user
    $:Max-price                            ; maximum initial price of any product
;   $:nInputs                              * the maximum number of inputs that a firm can require
;   $:nProducts                            * the number of products that are possible
    $:Open-system?                         ; if true, there are producers of raw materials and consumers of end-products, otherwise all inputs must
                                           ; be obtained as products from other firms in the system
    $:Raw-cost                             ; the cost of a unit of raw material
    $:Raw-materials                        ; the inputs that come from the environment are numbered 0 up to (but not including) this
;   $:Success-threshold                    * how successful an innovation must be before it is a success
    $:Depreciation                         ; tax paid per step by every firm
    $:Collaboration-tax                    ; tax paid for every partnership per step
    $:Inc-research-tax                     ; tax paid for one step of incremental research
    $:Rad-research-tax                     ; tax paid for one step of radical research

    K:Adjust-expertise-rate                ; global likelihood of adjusting expertise levels
    K:Max-IH-length                        ; maximum length of an innovation hypothesis
    K:Max-deliverable-length               ; maximum number of capabilities used for making a deliverable
    K:Project-cap-ratio                    ; "room" (number of capabilities) needed for adding a project (or proposal)

    P:Sub-nr-max                           ; highest amount of subprojects (999 if not limited)
    P:Sub-size-min                         ; smallest size of subprojects (0 if not limited)
    P:Time-between-calls                   ; months between two subsequent calls
    P:Time-before-call-deadline            ; months between a call's publication date and deadline
    P:Time-before-project-start            ; months between a call's deadline and start of the projects
    P:Time-between-deliverables            ; months between a subproject's output of deliverables

    r1:Search-depth                        ; search depth for finding partners
    r1:Invite-previous-partners-first?     ; search partners first in previous partners network

;   i1:Partnership-strategy                * whether partners as alike (conservative) or as different as possible are sought
;   i1:Attractiveness-threshold            * how attractive a firm must be before it becomes a partner
    i1:Max-partners                        ; the maximum number of potential partners a firm searches for

    v:Memory-IH-value                      ; the memory parameter α used for an entrepreneur's valuation of start-up hypothesis
    v:Memory-fitness                       ; the memory parameter α used for valuation of a firm's fitness;
                                           ; possibly leads to exit decision

    s:Birth                                ; the birth parameter β used to calculate probability p of start-up
;   s:Reward-to-trigger-start-up           ; a start-up is created when the best reward in the round is more than or equal to this

    ;;; Other globals
    ;;;
    ;;; (not parameters)

    participants                           ; list with all potential participants in networks

    ; dictionaries for getting and setting the values of specific instruments, calls, agents, etc.
    ; Example: [instr-duration] of table:get _instruments-dict "bm" => the duration of projects funded by German ministeries
    participants-dict
    institutes-dict
    organisations-dict
    intermediaries-dict
    firms-dict
    entrepreneurs-dict
    agencies-dict
    themes-dict
    instruments-dict
    calls-dict

;   Model-version                           ; version of this model
;   Experiment-name                         ; name of the current experiment (set in BehaviorSpace)

;   Base-year                               ;
;   nMonths                                 ;

;   Empirical-case?                         ;
;   Instruments-filter                      ;
;   Cutoff-point                            ; number of calls used to make the starting network

    __L__log?                               ; switch off for more speed
    __L__log-r?  __L__log-i?
    __L__log-debug?
;   __L__activity                           ; description of the phase of activity of the model

    __X__Simdb-location                     ; location of the simulation database (../eissim)

    ;;; Measures that are updated while the model is running
    ;;;

    ; Some counters
    __#__current-max-firm-id                ; counter for the firm id's
    __#__highest-firm-nr                    ; for setting firm-nr
    __#__highest-pnr                        ; for setting pnr
    __#__dead-ages                          ; a list of the ages at death of all dead firms since the start
    __#__dead-ages-net                      ; a list of the ages at death of all dead network firms since the start
    __P__highest-call-nr                    ; for setting call-nr
    __P__highest-proposal-nr                ; for setting proposal-nr
;   __N__partnerships-matrix                ; matrix with history of partnerships used for weighted graph
    __P__the-current-call                   ; for monitoring the latest call

    ; Important remark regarding the numbering of agents:
    ; The R-module uses exclusively the list of participants, the participant numbers of the agents (my-pnr)
    ; and the participants dictionary (participants-dict)
    ; The $-module uses exclusively the list of firms, the firm numbers of the agents (my-firm-nr)
    ; and the firms dictionary (firms-dict)
    ; These two numberings are entirely independent of each other and do not affect the simulation outcomes
    ; For details, see the initialisation procedures (initialise-participants, initialise-firms)

    ; Important remark regarding the measures with prefix __K__, __N__ and __P__
    ; All these variables are arrays of three values that can be numbers or lists
    ; The first item contains measures for research networks (R-value)
    ; The second item corresponds to innovation networks (I-value)
    ; The third is for entrepreneurial networks (E-value)

    ; Lists for storing the SCI/EI scores of institutes
    __I__institutes-SCI-score-C1
    __I__institutes-SCI-score-C2
    __I__institutes-SCI-score-C3
    __I__institutes-SCI-total-score-C
    __I__institutes-SCI-score-P1
    __I__institutes-SCI-score-P2
    __I__institutes-SCI-score-P3
    __I__institutes-SCI-total-score-P
    __I__institutes-EI-score-C1
    __I__institutes-EI-score-C2
    __I__institutes-EI-score-C3
    __I__institutes-EI-total-score-C
    __I__institutes-EI-score-P1
    __I__institutes-EI-score-P2
    __I__institutes-EI-score-P3
    __I__institutes-EI-total-score-P
    __I__institutes-total-score

    ; Some measures for research proposals which are updated when proposals are dissolved
    __P__proposals-count           ; number of (submitted) proposals
    __P__proposals-with-SME-count  ; number of (submitted) proposals with at least one SME in consortium
;   __P__proposals-intl-count      ; number of (submitted) proposals with at least one international participant in consortium
    __P__proposals-type            ; list for storing the type of proposals
    __P__proposals-call            ; list for storing the call of proposals
    __P__proposals-size            ; list for storing the size (number of partners) of proposals
    __P__proposals-INS             ; lists for storing the number of Type<P> participants in proposals
    __P__proposals-IMD
    __P__proposals-LDF
    __P__proposals-SME
    __P__proposals-SUP
    __P__proposals-ENT
    __P__proposals-OTH
    __P__proposals-exp-level       ; list for storing the expertise level of proposals
    __P__proposals-cap-match       ; list for storing the capability match of proposals

    ; Some measures for research projects which are updated when projects are dissolved
    __P__projects-count            ; number of (finished) projects
    __P__projects-with-SME-count   ; number of (finished) projects with at least one SME in consortium
;   __P__projects-intl-count       ; number of (submitted) proposals with at least one international participant in consortium
    __P__projects-nr               ; list for storing the nr of projects
    __P__projects-id               ; list for storing the id of projects
    __P__projects-type             ; list for storing the type of projects
    __P__projects-call             ; list for storing the call of projects
    __P__projects-size             ; list for storing the size (number of partners) of projects
    __P__projects-duration         ; list for storing the duration (number of months) of projects
    __P__projects-contribution     ; list for storing the contribution for projects
    __P__projects-INS              ; lists for storing the number of Type<P> participants in projects
    __P__projects-IMD
    __P__projects-LDF
    __P__projects-SME
    __P__projects-SUP
    __P__projects-ENT
    __P__projects-OTH

    N:network-types
    N:n
    __N__which-network

    ; Some network measures which are updated according to a Network-update-interval, between 1 (each tick) and nMonths (end of run only)
    ; The computations can slow things down considerably especially with large networks.
    __N__average-degree
    __N__average-path-length
    __N__clustering-coefficient
    __N__component-size
    __N__compute-network-distances?         ; computationally expensive!
    __N__connected?
    __N__count-of-edges
    __N__count-of-possible-edges
    __N__density
    __N__diameter
    __N__infinity
    __N__largest-component-size
    __N__largest-start-node
    __N__num-connected-pairs
    __N__number-of-components
    __N__participants-in-net

    __N__networks-average-degree
    __N__networks-average-path-length
    __N__networks-clustering-coefficient
    __N__networks-components
    __N__networks-density
    __N__networks-largest-component-size

    ; Some measures for knowledge and project outputs which are updated each tick
    __K__capabilities-INS                   ; lists for storing the presence of capabilities
    __K__capabilities-IMD                   ; (e.g. how many participants of Type<P> have capability x?)
    __K__capabilities-LDF
    __K__capabilities-SME
    __K__capabilities-SUP
    __K__capabilities-ENT
    __K__capabilities-frequency-INS         ; lists for storing the frequency of capabilities in the capabilities-<P> lists
    __K__capabilities-frequency-IMD
    __K__capabilities-frequency-LDF
    __K__capabilities-frequency-SME
    __K__capabilities-frequency-SUP
    __K__capabilities-frequency-ENT
    __K__kenes-length-INS                   ; lists for storing the length of the kenes of Type<P> participants
    __K__kenes-length-IMD
    __K__kenes-length-LDF
    __K__kenes-length-SME
    __K__kenes-length-SUP
    __K__kenes-length-ENT
    __K__capabilities-diffusion             ; share of participants carrying a capability from a certain theme
    __K__knowledge                          ; the sum of all kene lengths of participants
    __K__knowledge-flow                     ; the sum of all knowledge flow within subprojects, which is measured in the learn-from-partners procedure
    __K__kf-INS-to-INS  __K__kf-LDF-to-INS  __K__kf-SME-to-INS
    __K__kf-INS-to-LDF  __K__kf-LDF-to-LDF  __K__kf-SME-to-LDF
    __K__kf-INS-to-SME  __K__kf-LDF-to-SME  __K__kf-SME-to-SME
    __K__distances-ENT
    __K__distances-frequency-ENT

    ; Some lists for storing and exporting run data.
    ; This could be automatically done in BehaviorSpace, but since we need more options for exporting data
    ; to the SKIN Viewer there is an "export-run-data" procedure written for this task.

    __#__run-data-participants-INS      __#__run-data-participants-IMD      __#__run-data-participants-LDF
    __#__run-data-participants-SME      __#__run-data-participants-SUP      __#__run-data-participants-ENT
    __#__run-data-participants-OTH
    __#__run-data-participants-INS-net  __#__run-data-participants-IMD-net  __#__run-data-participants-LDF-net
    __#__run-data-participants-SME-net  __#__run-data-participants-SUP-net  __#__run-data-participants-ENT-net
    __#__run-data-participants-OTH-net

    __P__run-data-proposals-submitted  __P__run-data-proposals-submitted-BM  __P__run-data-proposals-submitted-EC
    __P__run-data-proposals            __P__run-data-proposals-BM            __P__run-data-proposals-EC
    __P__run-data-proposals-with-SME   __P__run-data-proposals-with-SME-BM   __P__run-data-proposals-with-SME-EC
    __P__run-data-proposals-small
    __P__run-data-proposals-big
    __P__run-data-projects           __P__run-data-projects-BM           __P__run-data-projects-EC
    __P__run-data-projects-started   __P__run-data-projects-started-BM   __P__run-data-projects-started-EC
    __P__run-data-projects-with-SME  __P__run-data-projects-with-SME-BM  __P__run-data-projects-with-SME-EC
    __P__run-data-projects-small
    __P__run-data-projects-big

    __N__run-data-network-density
    __N__run-data-network-components
    __N__run-data-network-largest-comp
    __N__run-data-network-avg-degree
    __N__run-data-network-avg-path-length
    __N__run-data-network-clustering

    __K__run-data-knowledge
    __K__run-data-knowledge-flow
    __K__run-data-kf-INS-to-INS  __K__run-data-kf-LDF-to-INS  __K__run-data-kf-SME-to-INS
    __K__run-data-kf-INS-to-LDF  __K__run-data-kf-LDF-to-LDF  __K__run-data-kf-SME-to-LDF
    __K__run-data-kf-INS-to-SME  __K__run-data-kf-LDF-to-SME  __K__run-data-kf-SME-to-SME
    __K__run-data-knowledge-patents
    __K__run-data-knowledge-articles
    __K__run-data-capabilities
    __K__run-data-capabilities-diffusion

    __$__run-data-sales
]


; the research institutes
breed [institutes institute]

; the extra-university research organisations
breed [organisations organisation]

; the intermediaries
breed [intermediaries intermediary]

; the firms
breed [firms firm]

; the entrepreneurs
breed [entrepreneurs entrepreneur]

; the funding agencies
breed [agencies agency]

; the other agents
breed [other-agents other-agent]

; the research calls
breed [calls call]

; the instruments
breed [instruments instrument]

; the research themes
breed [themes theme]

; the research proposals
breed [proposals proposal]

; the research projects
breed [projects project]

; the research subprojects
breed [subprojects subproject]

; the networks (used in the SEIN model)
breed [networks]


institutes-own [
    my-institute-nr
    my-type                       ; = "ins", "uni" or "ctr" (research institute - extra-university or other)
    my-org-type                   ; ~ organisation type
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the institute's current partners
    my-previous-R-partners        ; agentset of agents with which the institute has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    ; metabolism
    my-SCI-capacity               ; my capacity to participate in R-networks
    my-EI-capacity                ; my capacity to participate in I/T/E-networks
    my-funding                    ; my institutional (core) funding
    my-demand                     ; (market) demand for goods and services that I produce
    my-output                     ; value of goods and services that I produce
    my-price                      ; my price, assuming a constant ratio of price to cost
    my-resources                  ; resources generated (cash flow and investment)
    my-SCI-fraction               ; fraction of (physical) infrastructure resources that I use to top up SCI capacity
    my-EI-fraction                ; fraction of non-infrastructure resources that I use to top up EI capacity

    ; SCI/EI scores
    SCI-score-C1                  ; = ?
    SCI-score-C2
    SCI-score-C3
    SCI-total-score-C             ; total SCI capacity score
    SCI-score-P1                  ; = ?
    SCI-score-P2
    SCI-score-P3
    SCI-total-score-P             ; total SCI performance score
    EI-score-C1                   ; = ?
    EI-score-C2
    EI-score-C3
    EI-total-score-C              ; total EI capacity score
    EI-score-P1                   ; = ?
    EI-score-P2
    EI-score-P3
    EI-total-score-P              ; total EI performance score

    total-score                   ; total balanced SCI/EI score

    ; kene
    my-cap-capacity               ; the length of the kene
    my-capabilities               ; the kene of the institute, part 1
    my-abilities                  ; the kene of the institute, part 2
    my-expertises                 ; the kene of the institute, part 3
    my-orientations               ; the kene of the institute, part 4

    ;; Variables used for computing measures
    ;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


organisations-own [
    my-organisation-nr
    my-type                       ; = "fhg", "hgf", "wgl" or "mpg"
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the organisation's current partners
    my-previous-R-partners        ; agentset of agents with which the organisation has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    my-institutes

    ; SCI/EI weights

    SCI-weight-C1                 ; the weights for computing total SCI capacity score
    SCI-weight-C2
    SCI-weight-C3
    SCI-weight-C
    SCI-weight-P1                 ; the weights for computing total SCI performance score
    SCI-weight-P2
    SCI-weight-P3
    SCI-weight-P
    EI-weight-C1                  ; the weights for computing total EI capacity score
    EI-weight-C2
    EI-weight-C3
    EI-weight-C
    EI-weight-P1                  ; the weights for computing total EI performance score
    EI-weight-P2
    EI-weight-P3
    EI-weight-P
    EI-balance                    ; the balance of total SCI/EI scores

    ; kene
    my-cap-capacity               ; the length of the kene
    my-capabilities               ; the kene of the institute, part 1
    my-abilities                  ; the kene of the institute, part 2
    my-expertises                 ; the kene of the institute, part 3
    my-orientations               ; the kene of the institute, part 4

    ;; Variables used for computing measures
    ;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


intermediaries-own [
    my-intermediary-nr
    my-type                       ; = "imd"
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the intermediary's current partners
    my-previous-R-partners        ; agentset of agents with which the intermediary has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    my-cap-capacity               ; the length of the kene
    my-capabilities               ; the kene of the university, part 1
    my-abilities                  ; the kene of the university, part 2
    my-expertises                 ; the kene of the university, part 3
    my-orientations               ; the kene of the university, part 4

    ;;; Variables used for computing measures
    ;;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


firms-own [
    my-firm-nr
    my-type                       ; = "ldf" (large diversified firm), "sme" or "sup" (start-up)
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the firm's current partners
    my-previous-R-partners        ; agentset of agents with which the firm has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    my-cap-capacity               ; the length of the kene
    my-capabilities               ; the kene of the firm, part 1
    my-abilities                  ; the kene of the firm, part 2
    my-expertises                 ; the kene of the firm, part 3
    my-orientations               ; the kene of the firm, part 4

;   my-status                     ; = 0 ("seed") .. 6 ("exit")
    my-founder                    ; the entrepreneur that founded the company

;   my-fitness                    ; the firm’s fitness at time t, updated using the memory parameter α
;   my-growth-rate                ; how fast the company is growing (based on its revenues)

    my-IH                         ; the firm's innovation hypothesis (the locations of the ih kene triples)
    my-advert                     ; list of the capabilities of my innovation hypothesis
    my-capital                    ; the amount of capital of the firm
    my-product                    ; the product produced by this firm (a number)
    my-quality                    ; the quality of the product
    my-number-of-inputs           ; the number of inputs required to produce product
    my-inputs                     ; the products required as inputs to make the product
    my-research-direction         ; direction of changing an ability (for incremental research)
    my-ability-to-research        ; the ability that is being changed by incremental research
    done-rad-research?            ; true if the firm has just done radical research

    selling?                      ; whether I have made any product to sell this round
                                  ; (I can make product only if all my inputs are available to me)
    buying?
    my-suppliers                  ; list of suppliers
    my-customers                  ; list of customers
    my-nCustomers                 ; number of customers who bought my product
    my-total-cost                 ; the total of the prices charged by suppliers for my inputs
    my-price                      ; the price I want to sell the product for
    my-sales                      ; the total amount received from selling in this round
    my-markup                     ; %-age difference between cost of my inputs and my selling price
    my-last-reward                ; the reward received by the firm last time

    my-potential-customers        ; potential rewards of start-ups in proto stage testing
    my-potential-nCustomers
    my-potential-sales

    my-I-network                  ; the network I am a member of
    network-firm-id               ; the firm id of the network I am member of
    my-age                        ; steps since the firm was started
    high-potential?               ; is this a high potential start-up?
    network-firm?                 ; is this a firm representing a network?
    firm-id                       ; individual number for every firm in the modell at every time
    sell-buy-vector               ; vector of all firms the firm is interacting with this round
    network-partner-vector        ; vector of all firms the firm has estabished a network or a partnership

    ;; Variables used for computing measures
    ;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


entrepreneurs-own [
    my-entrepreneur-nr
    my-type                       ; = "ent" (entrepreneur or entrepreneurial team)
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the entrepreneur's current partners
    my-previous-R-partners        ; agentset of agents with which the entrepreneur has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    my-cap-capacity               ; the length of the kene
    my-capabilities               ; the kene of the entrepreneur, part 1
    my-abilities                  ; the kene of the entrepreneur, part 2
    my-expertises                 ; the kene of the entrepreneur, part 3
    my-orientations               ; the kene of the entrepreneur, part 4

    my-geolocation                ; the geographical location of the entrepreneur

    my-start-up                   ; the start-up that was founded by the entrepreneur

;   my-fitness                    ; the entrepreneur’s fitness at time t, updated using the memory parameter α
;   my-career                     ; the entrepreneur's career path, patents and publishing performance
;   my-migration-attitude         ; the entrepreneur's attitude toward entrepreneurship outside Germany

    my-IH                         ; the entrepreneur's innovation hypothesis (the locations of the ih kene triples)
    my-capital                    ; the amount of capital of the entrepreneur
    my-number-of-inputs           ; the number of inputs required to produce product
    my-research-direction         ; direction of changing an ability (for incremental research)
    my-advert                     ; list of the capabilities of my innovation hypothesis
    my-markup                     ; %-age difference between cost of my inputs and my selling price

    ;; Variables used for computing measures
    ;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


other-agents-own [
    my-agent-nr
    my-type                       ; = "oth" (governmental or non-governmental)
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-pnr                        ; participant nr
    my-R-partners                 ; agentset of the organisation's current partners
    my-previous-R-partners        ; agentset of agents with which the organisation has previously partnered
    my-I-partners
    my-previous-I-partners
    my-T-partners
    my-previous-T-partners
    my-E-partners
    my-previous-E-partners
    my-proposals                  ; the research proposals I am currently in
    my-projects                   ; the projects I am currently in

    ;; Variables used for computing measures
    ;;

    ; Some lists used for computing participation measures
    my-participation-in-proposals
    my-participation-in-projects

    ; Some variables used for computing network measures
    explored?
    distance-from-other-participants
    node-clustering-coefficient
]


agencies-own [
    my-agency-nr
    my-type                       ; = "fnd" (funding agency)
    my-id                         ; for the empirical case
    my-name
    my-short-name
    my-city
    my-zip-code
    my-country

    my-calls                      ; the calls that I have published
]


calls-own [
    call-nr
    call-type                     ; ~ instrument type
    call-agency                   ; the agency publishing the call
    call-id                       ; for the empirical case
    call-publication-date         ; the publication date of the call
    call-deadline                 ; the deadline of the call
    call-funding                  ; funding available for projects (percentage of total funding)
;   call-themes                   ; thematic orientation of the call
    call-orientation              ; the desired research orientation (0 basic .. 9 applied)
    call-cap-range                ; the call's range (number of capabilities)
    call-status                   ; = "open" or "closed"
    call-evaluated?               ; has the call been evaluated?
    call-counter                  ; table for counting proposals having a given status
                                  ; e.g. table:get call-counter "initiated" -> number of initiated proposals
    ; kene
    call-capabilities             ; a range of capabilities (at least some of which must appear in an eligible proposal)
]


instruments-own [
    instr-nr
    instr-type                    ; = "bm", "ec", "cr", "pl" or "so"
;   instr-size                    ; desired size of projects (number of partners)
    instr-size-min                ; smallest size of projects
    instr-size-max                ; largest size of projects
    instr-sub-nr-max              ; highest amount of subprojects
    instr-sub-size-min            ; smallest size of subprojects
;   instr-INT-min                 ; min number of partners of type INT
;   instr-LDF-min
;   instr-SME-min
    instr-duration-avg            ; the length of the project (in months)
    instr-duration-stdev
    instr-contribution            ; the funding contribution (multiply by size and duration)
    instr-match                   ; the required capability match
]


themes-own [
    theme-nr
    theme-description
]


proposals-own [
    proposal-nr
    proposal-type                 ; ~ instrument type
    proposal-call                 ; the call
    proposal-consortium           ; the consortium partners
    proposal-coordinator          ; coordinator of the proposal
    proposal-status               ; = 0 ("initiated") .. 7 ("dissolved")
    proposal-ranking-nr           ; set by the evaluating agency
    ; kene
    proposal-capabilities         ; compilation of kene quadruples of the consortium, part 1
    proposal-abilities            ; compilation of kene quadruples of the consortium, part 2
    proposal-expertises           ; compilation of kene quadruples of the consortium, part 3
    proposal-orientations         ; compilation of kene quadruples of the consortium, part 4
    ;
    proposal-contributors         ; who added the kene quadruples?
]


projects-own [
    project-nr                    ; = proposal-nr
    project-type                  ; = proposal-type
    project-call                  ; = proposal-call
    project-consortium            ; = proposal-consortium
    project-id                    ; for the empirical case
    project-acronym
    project-title
    project-start-date            ; starting date of the project (start of the research)
    project-end-date              ; when the project is finished
    project-contribution          ; funding contribution
    project-status                ; = 8 ("started") .. 10 ("dissolved")
    project-subprojects           ; the subprojects in which research is concentrated
    project-successful?           ; success depends on the outputs of the subprojects
    ; kene
    project-capabilities          ; = proposal-capabilities
    project-abilities             ; = proposal-abilities
    project-expertises            ; = proposal-expertises
    project-orientations          ; = proposal-orientations
    ;
    project-contributors          ; = proposal-contributors
]


subprojects-own [
    subproject-nr
    subproject-project            ; the "super"-project
    subproject-deliverable        ; the current subproject deliverable (~ innovation hypothesis)
    subproject-partners           ; the partners allocated to the subproject
    subproject-status             ; = 8 ("started") .. 10 ("dissolved")
    subproject-outputs            ; the (published) deliverables of the subproject
    incr-research-direction       ; direction of changing an ability (for incremental research)
    ability-to-research           ; the ability that is being changed by incremental research
    ; kene
    subproject-capabilities       ; subset of kene quadruples of the project, part 1
    subproject-abilities          ; subset of kene quadruples of the project, part 2
    subproject-expertises         ; subset of kene quadruples of the project, part 3
    subproject-orientations       ; subset of kene quadruples of the project, part 4
    subproject-contributors       ; who added the kene quadruples?
]


networks-own [
    network-firm                  ; the firm object that does this network's work
    network-members               ; the firms that constitute this network
]


;;; SETUP
;;;


to #:setup
    no-display
    ;; (for this model to work with NetLogo's new plotting features,
    ;; __clear-all-and-reset-ticks should be replaced with clear-all at
    ;; the beginning of your setup procedure and reset-ticks at the end
    ;; of the procedure.)
    __clear-all-and-reset-ticks
;   clear-all

    ifelse (behaviorspace-run-number > 0)
      [ __X__setup-simdb (behaviorspace-run-number = 1) ]
      [ __X__setup-workdir ]
    #:setup-presets
    #:setup-globals

    ; create the four research organisations (for demo of SCI/EI scores)
    #:initialise-organisations

    ifelse (Empirical-case?) [
      __X__import-empirical-case 999
    ] [
      if (Cutoff-point > 0) [ __X__import-empirical-case Cutoff-point ]

      ; create a number of themes
      #:initialise-themes
      ; create a population of institutes, intermediaries, firms and entrepreneurs
      #:initialise-institutes
      #:initialise-intermediaries
      #:initialise-firms
      set __#__highest-firm-nr max [my-firm-nr] of firms
      #:initialise-entrepreneurs
      ; initialise the (potential) participants in projects
      #:initialise-participants
      set __#__highest-pnr max [my-pnr] of participants
      ; create a few funding agencies
      #:initialise-agencies
      ; initialise the instruments and calls
      #:initialise-instruments
      #:initialise-calls

      ; make kenes
      ask institutes     [ &:make-kene ]
      ask intermediaries [ &:make-kene ]
      ask firms          [ &:make-kene-and-IH true ]
      ask entrepreneurs  [ &:make-kene-and-IH false ]
    ]

    __K__distances-frequency

    ; create a starting network based on the first calls before the cutoff point
    if (Cutoff-point > 0) [
      #:make-starting-network
      if (not Empirical-case?) [
        ; delete all imported projects if in simulation mode - we don't need them no longer
        ask projects [ die ]
        output-print "All imported projects are no longer needed and discarded."
      ]
    ]

    ; initialise history of partnerships
;   let n count participants
;   set P:partnerships-matrix array:from-list n-values P: [0]
;   foreach [0 1 2] [
;     array:set P:partnerships-matrix ? (array:from-list n-values (n * n) [0])
;   ]
    ; TO DO: number of participants is not known

    __I__update-institute-measures
;   __N__update-network-measures
    if (not Empirical-case?)
      [ __K__update-knowledge-measures ]

    update-plots

    let pos position Export-settings ["none (fastest)" "model (default)" "all"]
    if (pos > 0) [
      __X__update-run-data
      if (pos > 1) [
        __X__export-network-data (behaviorspace-run-number > 0)
        if (not Empirical-case?)
          [ __X__export-knowledge-data (behaviorspace-run-number > 0) ]
      ]
    ]

;   reset-ticks
end


to __X__setup-simdb [delete-old-experiment-data?]
    let sep pathdir:get-separator
    set __X__Simdb-location (word pathdir:get-home sep "eissim")  ; /Users/<user name>/eissim
    set Model-version "EIS-SKIN (09.2016)"
    ; if this is a new model version then create its directory
    let model-dir (word __X__Simdb-location sep "eisskin" Model-version)
    let list-of-model-versions pathdir:list (word __X__Simdb-location)
    if (not member? (word "eisskin" Model-version) list-of-model-versions)
      [ pathdir:create model-dir ]
    ; if this is a new experiment then create its directory and sub-directories
    let experiment-dir (word __X__Simdb-location sep "eisskin" Model-version sep Experiment-name)
    let list-of-experiments pathdir:list (word __X__Simdb-location sep "eisskin" Model-version)
    ifelse (member? Experiment-name list-of-experiments) [
      if (delete-old-experiment-data?) [
        ; empty the entire contents of the data and report sub-directories
        let rundata-dir (word experiment-dir sep "data" sep "rundata")
        let list-of-rundata pathdir:list rundata-dir
        foreach list-of-rundata [ file-delete (word rundata-dir sep ?) ]
        let netdata-dir (word experiment-dir sep "data" sep "netdata")
        let list-of-netdata-gml pathdir:list (word netdata-dir sep "gml")
        foreach list-of-netdata-gml [ file-delete (word netdata-dir sep "gml" sep ?) ]
        let list-of-netdata-gexf pathdir:list (word netdata-dir sep "gexf")
        foreach list-of-netdata-gexf [ if (not (? = "dyn")) [ file-delete (word netdata-dir sep "gexf" sep ?) ] ]
        let list-of-netdata-dyn-gexf pathdir:list (word netdata-dir sep "gexf" sep "dyn")
        foreach list-of-netdata-dyn-gexf [ file-delete (word netdata-dir sep "gexf" sep "dyn" sep ?) ]
        let kdata-dir (word experiment-dir sep "data" sep "kdata")
        let list-of-kdata pathdir:list kdata-dir
        foreach list-of-kdata [ file-delete (word kdata-dir sep ?) ]
        let charts-dir (word experiment-dir sep "report" sep "charts")
        let list-of-charts pathdir:list charts-dir
        foreach list-of-charts [ file-delete (word charts-dir sep ?) ]
        let graphs-dir (word experiment-dir sep "report" sep "graphs")
        let list-of-graphs pathdir:list graphs-dir
        foreach list-of-graphs [ file-delete (word graphs-dir sep ?) ]
        let tables-dir (word experiment-dir sep "report" sep "tables")
        let list-of-tables pathdir:list tables-dir
        foreach list-of-tables [ file-delete (word tables-dir sep ?) ]
      ]
    ] [
      pathdir:create experiment-dir
      pathdir:create (word experiment-dir sep "data" sep "rundata")
      pathdir:create (word experiment-dir sep "data" sep "netdata")
      pathdir:create (word experiment-dir sep "data" sep "netdata" sep "gml")
      pathdir:create (word experiment-dir sep "data" sep "netdata" sep "gexf")
      pathdir:create (word experiment-dir sep "data" sep "netdata" sep "gexf" sep "dyn")
      pathdir:create (word experiment-dir sep "data" sep "kdata")
      pathdir:create (word experiment-dir sep "report" sep "tables")
      pathdir:create (word experiment-dir sep "report" sep "charts")
      pathdir:create (word experiment-dir sep "report" sep "graphs")
    ]
end


to __X__setup-workdir
    let sep pathdir:get-separator
    ; create the work directory structure if it does not exist yet, otherwise
    ; empty the entire contents of the data sub-directories
    let list-of-contents pathdir:list ""
    ifelse (member? "work" list-of-contents) [
      let rundata-dir (word "work" sep "rundata")
      let list-of-rundata pathdir:list rundata-dir
      foreach list-of-rundata [ file-delete (word rundata-dir sep ?) ]
      let netdata-dir (word "work" sep "netdata")
      let list-of-netdata-gml pathdir:list (word netdata-dir sep "gml")
      foreach list-of-netdata-gml [ file-delete (word netdata-dir sep "gml" sep ?) ]
      let list-of-netdata-gexf pathdir:list (word netdata-dir sep "gexf")
      foreach list-of-netdata-gexf [ if (not (? = "dyn")) [ file-delete (word netdata-dir sep "gexf" sep ?) ] ]
      let list-of-netdata-dyn-gexf pathdir:list (word netdata-dir sep "gexf" sep "dyn")
      foreach list-of-netdata-dyn-gexf [ file-delete (word netdata-dir sep "gexf" sep "dyn" sep ?) ]
      let kdata-dir (word "work" sep "kdata")
      let list-of-kdata pathdir:list kdata-dir
      foreach list-of-kdata [ file-delete (word kdata-dir sep ?) ]
    ] [
      pathdir:create "work"
      pathdir:create (word "work" sep "rundata")
      pathdir:create (word "work" sep "netdata")
      pathdir:create (word "work" sep "netdata" sep "gml")
      pathdir:create (word "work" sep "netdata" sep "gexf")
      pathdir:create (word "work" sep "netdata" sep "gexf" sep "dyn")
      pathdir:create (word "work" sep "kdata")
    ]
end


; Set parameters to pre-defined settings (presets).
; The purpose of presets is to make it easier to design experiments.
; When presets are selected using the choosers in the interface or in BehaviorSpace, groups of parameters will be set at once.
; For example, by using the Participants-settings preset the group of parameters for participants can be set.
; It is however not obligatory to use presets. When "no preset" is selected for certain groups of parameters, setup will
; skip the preset procedure for these parameter groups and not change the sliders for these groups.
; It is thus possible to fix with presets values for a certain groups of parameters, while experimenting with different parameter
; values for the remaining parameter groups, using sliders or [parameter values] lists in BehaviorSpace.

to #:setup-presets
    let i 0

    ;;; Participants-settings
    ;;;

    set #:Participant-types ["ins" "imd" "ldf" "sme" "sup" "ent"]
    set #:n length #:Participant-types

    ; The Baseline population has 700 participants (more than the empirical sample)
    ;
    ;-------------------------------------------
    ;             Count     Percent     Size
    ;   INS          30                   25
    ;   IMD          30                   10
    ;   LDF         100         20%       15
    ;   SME         400         80%       10
    ;   SUP          40           0        5
    ;   ENT         100                    5
    ;-------------------------------------------

    set i position Participants-settings ["manual" "Baseline"]
    if (i > 0) [
      set i i - 1
      set nInstitutes 30                     set Size-INS 10
      set nFirms   item i [540   600   540]
      set Perc-LDF item i [ 18.5  16.6  20]  set Size-LDF 15
      set Perc-SME item i [ 74.1  83.4  80]  set Size-SME 10
      ;   Perc-SUP        [  7.4   0     0]
    ]

    ;;; Institutes-settings
    ;;;

    set I:Organisation-types ["fhg" "hgf" "wgl" "mpg"]
    set I:n length I:Organisation-types

    set i position Institutes-settings ["manual" "Baseline"]
    ifelse (i > 0) [
      set i i - 1
      set I:Perc-SCI array:from-list [0.8 0.8 0.8 0.8]
      set I:Perc-EI  array:from-list [0.2 0.2 0.2 0.2]

      ; Update the sliders
      set Perc-SCI-FhG array:item I:Perc-SCI 0  set Perc-SCI-HGF array:item I:Perc-SCI 1
      set Perc-SCI-WGL array:item I:Perc-SCI 2  set Perc-SCI-MPG array:item I:Perc-SCI 3
      set Perc-EI-FhG  array:item I:Perc-EI  0  set Perc-EI-HGF  array:item I:Perc-EI  1
      set Perc-EI-WGL  array:item I:Perc-EI  2  set Perc-EI-MPG  array:item I:Perc-EI  3
    ] [
      ; (manual) Store the slider values in arrays
      set I:Perc-SCI array:from-list n-values I:n [0]
      set I:Perc-EI  array:from-list n-values I:n [0]

      array:set I:Perc-SCI 0 Perc-SCI-FhG  array:set I:Perc-SCI 1 Perc-SCI-HGF
      array:set I:Perc-SCI 2 Perc-SCI-WGL  array:set I:Perc-SCI 3 Perc-SCI-MPG
      array:set I:Perc-EI  0 Perc-EI-FhG   array:set I:Perc-EI  1 Perc-EI-HGF
      array:set I:Perc-EI  2 Perc-EI-WGL   array:set I:Perc-EI  3 Perc-EI-MPG
    ]

    ;;; Instruments-settings
    ;;;

    set nAgencies 1

    ;;; Instruments-settings
    ;;;

    set P:Project-types ["bm" "ec" "cr" "pl" "so"]
    set P:n length P:Project-types

    ; some Baseline settings (unaffected by the preset)
    set P:Duration-avg   array:from-list [36 36 12 12 12]
    set P:Duration-stdev array:from-list [ 6  6  3  3  3]
;       P:Size-avg   [? ? ? ? ?]
;       P:Size-stdev [? ? ? ? ?]
    set P:Size-min array:from-list [ 3  3  3  3  3]
    set P:Size-max array:from-list [30 30 30 30 30]

    set i position Instruments-settings ["manual" "Baseline"]
    ifelse (i > 0) [
      set i i - 1
      set P:Match array:from-list [18 15 15 15 15]
      set P:Contribution array:from-list [15000 10000 10000 1000 1000]

      ; Update the sliders
      set Match-BM array:item P:Match 0  set Match-EC array:item P:Match 1
      set Match-CR array:item P:Match 2  set Match-PL array:item P:Match 3
      set Match-SO array:item P:Match 4
      set Contribution-BM array:item P:Contribution 0  set Contribution-EC array:item P:Contribution 1
      set Contribution-CR array:item P:Contribution 2  set Contribution-PL array:item P:Contribution 3
      set Contribution-SO array:item P:Contribution 4
    ] [
      ; (manual) Store the slider values in arrays
      set P:Match array:from-list n-values P:n [0]
      set P:Contribution array:from-list n-values P:n [0]

      array:set P:Match 0 Match-BM  array:set P:Match 1 Match-EC
      array:set P:Match 2 Match-CR  array:set P:Match 3 Match-PL
      array:set P:Match 4 Match-SO
      array:set P:Contribution 0 Contribution-BM  array:set P:Contribution 1 Contribution-EC
      array:set P:Contribution 2 Contribution-CR  array:set P:Contribution 3 Contribution-PL
      array:set P:Contribution 3 Contribution-SO
    ]

    ;;; Calls-settings
    ;;;

    set i position Calls-settings ["manual" "Baseline"]
    ifelse (i > 0) [
      ; Empirical data for contributions per call per instrument is used for seting the Baseline funding,
      ; which are expressed as percentages of the total funding (a global variable that can be changed
      ; in experiments)

      ;  EUR      BM  Contr.     EC  Contr.
      ;  call nr
      ;  ...
      ;  TOTAL

      ;  %        BM  Contr.     EC  Contr.
      ;  call nr
      ;  ...
      ;  TOTAL

      set i i - 1
      set P:Funding-calls     array:from-list [3 1 1 1]
      set P:Orientation-calls array:from-list item i [[5 7 0 0] [6 8 0 0]]
      set P:Range-calls       array:from-list [35 35 0 0]

      ; Update the sliders
      set Funding-calls-BM     array:item P:Funding-calls 0
      set Funding-calls-EC     array:item P:Funding-calls 1
      set Orientation-calls-BM array:item P:Orientation-calls 0
      set Orientation-calls-EC array:item P:Orientation-calls 1
      set Range-calls-BM       array:item P:Range-calls 0
      set Range-calls-EC       array:item P:Range-calls 1
    ] [
      ; (manual) Store the slider values in arrays
      set P:Funding-calls     array:from-list n-values P:n [0]
      set P:Orientation-calls array:from-list n-values P:n [0]
      set P:Range-calls       array:from-list n-values P:n [0]

      array:set P:Funding-calls 0     Funding-calls-BM
      array:set P:Funding-calls 1     Funding-calls-EC
      array:set P:Orientation-calls 0 Orientation-calls-BM
      array:set P:Orientation-calls 1 Orientation-calls-EC
      array:set P:Range-calls 0       Range-calls-BM
      array:set P:Range-calls 1       Range-calls-EC
    ]

    ;;; Other-settings
    ;;;

    ; Capability space is differentiated by 10 themes
    ;
    ;-------------------------------------------------------------------------
    ; Theme    Sector capabilities    Common capabilities    Rare capabilities
    ;     1           1 -  40               41 -  80             81 -  100
    ;     2         101 - 140              141 - 180            181 -  200
    ;   ...            ...                    ...                  ...
    ;     9         801 - 840              841 - 880            881 -  900
    ;    10         901 - 940              941 - 980            981 - 1000
    ;-------------------------------------------------------------------------

    set K:nCapabilities 1000
    set K:nThemes 10
    set K:Sector-capabilities-per-theme 40
    set K:Rare-capabilities-per-theme   20
    ;     Common-capabilities-per-theme 40

    ; some other Baseline settings (unaffected by the preset)
    set Survival-threshold 0.2

    set i position Other-settings ["manual" "Baseline" "increase funding" "decrease funding"]
    if (i > 0) [
      set i i - 1
      set Funding item i [3500 5000 2000]
    ]

    ;;; Model-settings
    ;;;

    ; is used to activate specific combinations of cycles, each focussing on one particular network cycle (R-I-T-E)

    set i position Model-settings ["manual" "R-networks" "I-networks" "T-networks" "E-networks" "Transactions" "all"]
    if (i > 0) [
      set i i - 1
      set System?          item i [false  false  false  false  false  true]
      set R-Networks?      item i [ true  false  false  false  false  true]
      set I-Networks?      item i [false   true  false  false  false  true]
      set T-Networks?      item i [false  false   true  false  false  true]
      set E-Networks?      item i [false  false  false   true  false  true]
      set Transactions?    item i [false  false  false  false   true  true]
      set Valuations?      item i [ true   true   true   true   true  true]
    ]

    ;;; Log-settings
    ;;;

    ; is used to activate specific combinations of logs, each focussing on one particular purpose

    set i position Log-settings ["none (fastest)" "model (default)" "all" "debug"]

    set __L__log?       item i [false   true   true   true]
    set __L__log-r?     item i [false  false   true  false]
    set __L__log-i?     item i [false  false   true  false]
    set __L__log-debug? item i [false  false  false   true]
    if (i = 1) [
      set __L__log-r? R-Networks?
      set __L__log-i? I-Networks?
    ]
end


to __U__set-all-settings [choice]
    set Participants-settings choice
    set Institutes-settings   choice
    set Instruments-settings  choice
    set Calls-settings        choice
    set Other-settings        choice
end


; Update all controls (sliders etc.) to show current settings

to __U__show-current-settings
    #:setup-presets
    output-print "Controls are now showing the current settings"
end


to #:setup-globals
    set participants no-turtles  ; empty agentset

    ; Reset parameters without presets

    set &:Inc-step 0.011  ; must be a prime number ????
    set &:Low-capital-threshold 1000

    set $:Capital-knowledge-ratio 50
    set $:Initial-capital-SME 10000
    set $:Delta 2.0
    set $:Max-price 1000
    set $:Depreciation 100
    set $:Collaboration-tax 100
    set $:Inc-research-tax  100
    set $:Rad-research-tax  100

    ; In an open system, the 1st five products are 'raw materials' always available and always sold at a low
    ; price (Raw-cost) and the last 5 products are always purchased by consumers with inexhaustible demand at
    ; a high price (Final-price)
    set $:Raw-cost 1
    set $:Final-price 100000
    set $:Open-system? true
    ifelse ($:Open-system?)
      [ set $:Raw-materials 10  set $:End-products 10 ]
      [ set $:Raw-materials  0  set $:End-products  0 ]

    set K:Max-IH-length 10
    set K:Adjust-expertise-rate 0.0333
    set K:Max-deliverable-length 9
    set K:Project-cap-ratio 5

    set P:Sub-nr-max   array:from-list [10 10 1 1 1]
    set P:Sub-size-min array:from-list [ 3  3 1 1 1]
    set P:Time-between-calls 12
    set P:Time-before-call-deadline 6
    set P:Time-before-project-start 9
    set P:Time-between-deliverables 3

    set r1:Search-depth 20
    set r1:Invite-previous-partners-first? true

    set i1:Max-partners 5

    ; Reset counters

    set __#__current-max-firm-id 0
    set __#__highest-firm-nr 0
    set __P__highest-call-nr 0
    set __P__highest-proposal-nr 0

    ; Reset measures

    set __I__institutes-SCI-score-C1 []  set __I__institutes-SCI-score-C2 []  set __I__institutes-SCI-score-C3 []
    set __I__institutes-SCI-score-P1 []  set __I__institutes-SCI-score-P2 []  set __I__institutes-SCI-score-P3 []
    set __I__institutes-EI-score-C1  []  set __I__institutes-EI-score-C2  []  set __I__institutes-EI-score-C3  []
    set __I__institutes-EI-score-P1  []  set __I__institutes-EI-score-P2  []  set __I__institutes-EI-score-P3  []
    set __I__institutes-SCI-total-score-C []
    set __I__institutes-SCI-total-score-P []
    set __I__institutes-EI-total-score-C  []
    set __I__institutes-EI-total-score-P  []
    set __I__institutes-total-score []

    set __P__proposals-count          array:from-list n-values P:n [0]
    set __P__proposals-with-SME-count array:from-list n-values P:n [0]
;   set __P__proposals-intl-count     array:from-list n-values P:n [0]
    set __P__proposals-type           array:from-list n-values P:n [[]]
    set __P__proposals-call           array:from-list n-values P:n [[]]
    set __P__proposals-size           array:from-list n-values P:n [[]]
    set __P__proposals-INS            array:from-list n-values P:n [[]]
    set __P__proposals-IMD            array:from-list n-values P:n [[]]
    set __P__proposals-LDF            array:from-list n-values P:n [[]]
    set __P__proposals-SME            array:from-list n-values P:n [[]]
    set __P__proposals-SUP            array:from-list n-values P:n [[]]
    set __P__proposals-ENT            array:from-list n-values P:n [[]]
    set __P__proposals-OTH            array:from-list n-values P:n [[]]
    set __P__proposals-exp-level      array:from-list n-values P:n [[]]
    set __P__proposals-cap-match      array:from-list n-values P:n [[]]

    set __P__projects-count          array:from-list n-values P:n [0]
    set __P__projects-with-SME-count array:from-list n-values P:n [0]
;   set __P__projects-intl-count     array:from-list n-values P:n [0]
    set __P__projects-nr             array:from-list n-values P:n [[]]
    set __P__projects-id             array:from-list n-values P:n [[]]
    set __P__projects-type           array:from-list n-values P:n [[]]
    set __P__projects-call           array:from-list n-values P:n [[]]
    set __P__projects-size           array:from-list n-values P:n [[]]
    set __P__projects-duration       array:from-list n-values P:n [[]]
    set __P__projects-contribution   array:from-list n-values P:n [[]]
    set __P__projects-INS            array:from-list n-values P:n [[]]
    set __P__projects-IMD            array:from-list n-values P:n [[]]
    set __P__projects-LDF            array:from-list n-values P:n [[]]
    set __P__projects-SME            array:from-list n-values P:n [[]]
    set __P__projects-SUP            array:from-list n-values P:n [[]]
    set __P__projects-ENT            array:from-list n-values P:n [[]]
    set __P__projects-OTH            array:from-list n-values P:n [[]]

    set N:network-types ["R" "I" "T" "E"]
    set N:n length N:network-types
    set __N__which-network "R"
    set __N__compute-network-distances? false
    set __N__infinity 99999

    set __N__networks-average-degree         array:from-list n-values N:n [0]
    set __N__networks-average-path-length    array:from-list n-values N:n [0]
    set __N__networks-clustering-coefficient array:from-list n-values N:n [0]
    set __N__networks-components             array:from-list n-values N:n [0]
    set __N__networks-density                array:from-list n-values N:n [0]
    set __N__networks-largest-component-size array:from-list n-values N:n [0]

    set __K__capabilities-INS []  set __K__capabilities-IMD []  set __K__capabilities-LDF []
    set __K__capabilities-SME []  set __K__capabilities-SUP []  set __K__capabilities-ENT []
    set __K__knowledge 0
    set __K__knowledge-flow array:from-list n-values P:n [0]
    set __K__kf-INS-to-INS  array:from-list n-values P:n [0]  set __K__kf-LDF-to-INS array:from-list n-values P:n [0]  set __K__kf-SME-to-INS array:from-list n-values P:n [0]
    set __K__kf-INS-to-LDF  array:from-list n-values P:n [0]  set __K__kf-LDF-to-LDF array:from-list n-values P:n [0]  set __K__kf-SME-to-LDF array:from-list n-values P:n [0]
    set __K__kf-INS-to-SME  array:from-list n-values P:n [0]  set __K__kf-LDF-to-SME array:from-list n-values P:n [0]  set __K__kf-SME-to-SME array:from-list n-values P:n [0]
    set __K__kenes-length-INS []  set __K__kenes-length-IMD []  set __K__kenes-length-LDF []
    set __K__kenes-length-SME []  set __K__kenes-length-SUP []  set __K__kenes-length-ENT []

    ; Reset run data

    set __#__run-data-participants-INS []      set __#__run-data-participants-IMD []      set __#__run-data-participants-LDF []
    set __#__run-data-participants-SME []      set __#__run-data-participants-SUP []      set __#__run-data-participants-ENT []
    set __#__run-data-participants-OTH []
    set __#__run-data-participants-INS-net []  set __#__run-data-participants-IMD-net []  set __#__run-data-participants-LDF-net []
    set __#__run-data-participants-SME-net []  set __#__run-data-participants-SUP-net []  set __#__run-data-participants-ENT-net []
    set __#__run-data-participants-OTH-net []

    set __P__run-data-proposals-submitted array:from-list n-values P:n [[]]
    set __P__run-data-proposals           array:from-list n-values P:n [[]]
    set __P__run-data-proposals-with-SME  array:from-list n-values P:n [[]]
    set __P__run-data-proposals-small     array:from-list n-values P:n [[]]
    set __P__run-data-proposals-big       array:from-list n-values P:n [[]]
    set __P__run-data-projects-started    array:from-list n-values P:n [[]]
    set __P__run-data-projects            array:from-list n-values P:n [[]]
    set __P__run-data-projects-with-SME   array:from-list n-values P:n [[]]
    set __P__run-data-projects-small      array:from-list n-values P:n [[]]
    set __P__run-data-projects-big        array:from-list n-values P:n [[]]

;   set __N__run-data-network-density         array:from-list n-values N:n [[]]
;   set __N__run-data-network-components      array:from-list n-values N:n [[]]
;   set __N__run-data-network-largest-comp    array:from-list n-values N:n [[]]
;   set __N__run-data-network-avg-degree      array:from-list n-values N:n [[]]
;   set __N__run-data-network-avg-path-length array:from-list n-values N:n [[]]
;   set __N__run-data-network-clustering      array:from-list n-values N:n [[]]

    set __K__run-data-knowledge []
    set __K__run-data-knowledge-flow array:from-list n-values P:n [[]]
    set __K__run-data-kf-INS-to-INS  array:from-list n-values P:n [[]]
    set __K__run-data-kf-LDF-to-INS  array:from-list n-values P:n [[]]
    set __K__run-data-kf-SME-to-INS  array:from-list n-values P:n [[]]
    set __K__run-data-kf-INS-to-LDF  array:from-list n-values P:n [[]]
    set __K__run-data-kf-LDF-to-LDF  array:from-list n-values P:n [[]]
    set __K__run-data-kf-SME-to-LDF  array:from-list n-values P:n [[]]
    set __K__run-data-kf-INS-to-SME  array:from-list n-values P:n [[]]
    set __K__run-data-kf-LDF-to-SME  array:from-list n-values P:n [[]]
    set __K__run-data-kf-SME-to-SME  array:from-list n-values P:n [[]]
;   set __K__run-data-knowledge-patents  []
;   set __K__run-data-knowledge-articles []
    set __K__run-data-capabilities []
    set __K__run-data-capabilities-diffusion []

    set __$__run-data-sales matrix:make-constant (nFirms + nEntrepreneurs + 2) (nMonths + 1) 0
end


;;; EMPIRICAL CASE
;;;
;;; import EIS data


to __X__import-empirical-case [number-of-calls]
    ; open EIS database
    sql:configure "defaultconnection" [
      ["user" "root"]
      ["password" ""]
      ["database" "eis_070317?zeroDateTimeBehavior=convertToNull"]
    ]

    if (false) [
      ; This routine calculates and stores participant size based on total funding, considering all calls.
      ; The information is used later when the agents are created.
      let participants-size-dict table:make
      ; get total funding of all the participants
      sql:exec-query (word
          "SELECT E.id, E.short_name, SUM(P.funding)"
         " FROM participations AS P, entities AS E"
         " WHERE E.id = P.entity_id"
         " GROUP BY E.id") []
      let all-participants sql:fetch-resultset
;     let max-participant-funding    max    map [item 2 ?] all-participants
;     let mean-participant-funding   mean   map [item 2 ?] all-participants
;     let median-participant-funding median map [item 2 ?] all-participants
;     print (word "max "    max-participant-funding
;                " mean "   precision mean-participant-funding 2
;                " median " median-participant-funding)
      while [not empty? all-participants] [
        ; step through the list of participants
        let row first all-participants
        set all-participants butfirst all-participants
        ; calculate participant size
;       let participant-size 1
        let participant-funding item 2 row
;       if (participant-funding > 10 * median-participant-funding)
;         [ set participant-size ceiling (participant-funding / (10 * median-participant-funding)) ]
;       table:put participants-size-dict (item 0 row) participant-size
        table:put participants-size-dict (item 0 row) participant-funding
;       print (word (item 0 row) " '" (item 1 row) "' " participant-funding)
      ]
    ]

    ; Main routine, which retrieves the centres and participants
    ; ------------

    ; set the import filter
    let call-ids ["FP7-ICT-2007-1" "FP7-ICT-2007-2" "FP7-ICT-2007-3" "FP7-ICT-2009-4" "FP7-ICT-2009-5" "FP7-ICT-2009-6"]
    set number-of-calls length call-ids  ; reset the function's parameter to default
    let call-id-filter (word "('" item 0 call-ids "'")
    let i 1
    while [i < number-of-calls] [
      set call-id-filter (word call-id-filter ", '" item i call-ids "'")
      set i i + 1
    ]
    set call-id-filter (word call-id-filter ")")
    output-print (word "Import filter is " call-id-filter)

    let npr 0  ; for counting the projects
    let npa 0  ; for counting the participants

    ; get the projects
;   set i position Instruments-filter ["CSET" "TC"]
;   let psfs-filter item i ["('CP-IP')" "('CP-FP', 'CP-FP-INFSO')" "('CP-FP', 'CP-FP-INFSO', 'CP-IP')"]
    let sql-exec (word
        "SELECT id, short_name, name, funding_call, type, budget, starts_at, ends_at, funding_scheme"
       " FROM networks"
       " WHERE funding_call IN " call-id-filter
       " ORDER BY id")
    sql:exec-direct sql-exec
    let all-projects sql:fetch-resultset

    let pnr 1  ; for numbering participants
;   let snr 1  ; for grouping participants (super-organisations)
    while [not empty? all-projects] [
      ; step through the list of projects
      let row first all-projects
      set all-projects butfirst all-projects

      let the-new-project-id (item 0 row)  ; e.g. 1297
      ; create a turtle for the new project
      let the-new-project nobody
      create-projects 1 [
        set the-new-project self
        set project-nr the-new-project-id
        set project-id the-new-project-id
        set project-acronym (item 1 row)  ; e.g. Omega
        set project-title   (item 2 row)  ; e.g. Home Gigabit Access
;       set project-type _project-type (item 8 row)  ; e.g. CP
        set project-type "ec"
        set project-start-date _date-to-month (item 6 row)  ; e.g. 2008-01-01
        set project-end-date   _date-to-month (item 7 row)  ; e.g. 2011-03-31
;       set project-budget (item 6 row)   ; e.g. 19057275
;       set project-contribution 0
        set project-status ""
      ]
      set npr npr + 1

      ask the-new-project [ print ""  print (word project-nr " '" project-acronym "' '" project-type "'") ]

      ; get all the participants in the project
      sql:exec-query (word
           "SELECT E.id, E.type, E.short_name, PP.role, E.country_code"
          " FROM participations AS PP, entities AS E"
          " WHERE E.id = PP.entity_id AND PP.network_id = ?") (list the-new-project-id)

      ; create an agentset of the members of this project
      let members nobody
      while [sql:row-available?] [
        let project-row sql:fetch-row
        let member one-of participants with [my-id = (item 0 project-row)]
        if (member = nobody) [
          ; this is a new participant - create 1 or more agents for it
          let the-new-participant nobody

          ifelse (Empirical-case?) [
            ; Empirical case - the participant's size is not used
            let the-type _participant-type (item 1 project-row)
            ; 1 agent only - the participant's size is not used
              ifelse ((the-type = "ins") or (the-type = "uni") or (the-type = "ctr"))
              ;; create a new institute
              [ create-institutes 1   [ set the-new-participant self ]  set npa npa + 1 ]
            [ ifelse ((the-type = "ldf") or (the-type = "sme") or (the-type = "sup"))
              ;; create a new firm
              [ create-firms 1        [ set the-new-participant self ]  set npa npa + 1 ]
            [ ifelse ((the-type = "gov") or (the-type = "ngo") or (the-type = "oth"))
              ;; create a new "other" agent
              [ create-other-agents 1 [ set the-new-participant self ]  set npa npa + 1 ]
              ;; default: should not happen
              [ print (word "Unknown participant type (" the-type ")") ]
            ]]
            ask the-new-participant [
              set my-pnr pnr
              set my-id         (item 0 project-row)  ; e.g. 549
              set my-short-name (item 2 project-row)  ; e.g. EMB
              set my-type       the-type              ; e.g. ins
            ]
            set member the-new-participant
            set pnr pnr + 1
          ] [
            ; Simulation - the participant's size is used
;           let participant-size table:get participants-size-dict item 0 project-row
;           create-firms participant-size [
;             set my-pnr  pnr
;             set my-id   (item 0 project-row)
;             set my-type the-type
;             set member  self
;             set pnr pnr + 1
;           ]
;           set snr snr + 1
          ]
          set participants (turtle-set participants the-new-participant)
        ]
        set members (turtle-set members member)

        ask member [ print (word " " (_fv my-pnr 8) " " (_fv my-id 8) " " (_fs my-short-name 25) " " (_fs my-type 5)) ]
      ]

      ; the project consortium
      ask the-new-project [ set project-consortium members ]
    ]

    ; add participant name, location and org-type to participant agents
    ask participants [
      sql:exec-query (word
          "SELECT research_organization, name, short_name, city, zip_code, country_code"
         " FROM entities"
         " WHERE id = ?") (list my-id)
      let row sql:fetch-row
      ifelse (my-type = "ins")
        [ set my-org-type _organisation-type (item 0 row) ]  ; e.g. Fraunhofer Gesellschaft
        [ if ((my-type = "uni") or (my-type = "ctr")) [ set my-org-type "" ]]  ; no info in database
      set my-name       (item 1 row)  ; e.g. Fraunhofer-Einrichtung für Marine Biotechnologie
;     set my-short-name (item 2 row)  ; e.g. EMB
      set my-city       (item 3 row)  ; e.g. Lübeck
      set my-zip-code   (item 4 row)  ; e.g. 2
      set my-country    (item 5 row)  ; e.g. DE
      set my-proposals           no-turtles
      set my-projects            no-turtles
      set my-R-partners          no-turtles
      set my-previous-R-partners no-turtles
      set my-I-partners          no-turtles
      set my-previous-I-partners no-turtles
      set my-T-partners          no-turtles
      set my-previous-T-partners no-turtles
      set my-E-partners          no-turtles
      set my-previous-E-partners no-turtles
      if (not Empirical-case?) [
        set my-capabilities []
        set my-abilities    []
        set my-expertises   []
        set my-orientations []
      ]
      set my-participation-in-proposals []
      set my-participation-in-projects  []
    ]
    output-print (word "Import resulted in " npr " projects and " npa " participants.")
end


; format value (align right)

to-report _fv [a-value n]
    let s (word a-value "")
    let m n - length s
    repeat m [ set s (word " " s) ]
    report s
end


; format string (align left)

to-report _fs [a-string n]
    let s (word "'" a-string "'")
    let m n - length s
    ifelse (m > 0)
      [ repeat m [ set s (word s " ") ]  report s ]
      [ report (word "'" (substring a-string 0 (n - 2)) "'") ]
end


; Starting network
; ----------------
; We fill the list of previous partners with consortium partners of the first calls before the cutoff point.
; This is an approximation of the starting network.

to #:make-starting-network
; let call-ids ["CSET" "CSET/SRC" "CSET/RC" "TC" "TTC"]
; let call-ids ["CSET" "CSET/SRC" "CSET/RC"]
  let call-ids ["TC"]
; let call-ids ["TTC"]
  let npr 0  ; for counting the projects
  ask projects with [position project-call call-ids < Cutoff-point] [
    let the-consortium project-consortium
    ask the-consortium [
      set my-previous-R-partners (turtle-set my-previous-R-partners (the-consortium with [self != myself]))
    ]
    set npr npr + 1
  ]
  output-print (word "Cutoff-point (first " Cutoff-point " calls) resulted in " npr " projects.")
  output-print ("Starting network is created.")
end


; Correct any missing values identified in the database

;to-report _correct-start-date [the-project-nr the-start-date]
;;   if (the-project-nr = 270447)
;;     [ report "2011-04-01" ]
;    report the-start-date
;end


;to-report _correct-end-date [the-project-nr the-end-date]
;;   if (the-project-nr = 270447)
;;     [ report "2014-09-30" ]
;    report the-end-date
;end


; Convert from full date YYYY-MM-DD to month:
; 2006-01-DD -> 0, 2006-02-DD -> 2 etc.

to-report _date-to-month [the-date]
    if (not is-string? the-date) [ report 0 ]  ; intercept <null>
    let the-year  substring the-date 0 4
    let the-month substring the-date 5 7
    let pos position the-year [
        "2006" "2007" "2008" "2009" "2010" "2011" "2012" "2013" "2014" "2015"
        "2016" "2017" "2018" "2019" "2020" "2021" "2022"]
    ifelse (pos != false) [
      let months 12 * pos
      set months months + position the-month ["01" "02" "03" "04" "05" "06" "07" "08" "09" "10" "11" "12"]
      report months
    ] [
      report -1
    ]
end


; Convert from EIS database to SKIN-type

; FP7 funding schemes only!
;
;   CP            ->  CP
;   CP-FP         ->  FP
;   CP-IP         ->  IP
;   MC-ITN        ->  ITN
;   MC-IEF        ->  IEF
;   CSA           ->  CSA
;   CSA-CA        ->  CA
;   CSA-SA        ->  SA
;   BSG-SME       ->  SME
;   ERC-SG        ->  SG
;   ERC-AG        ->  AG
;   CP-CSA-Infra  ->  INFRA
;   CP-TP         ->  TP
;   Other         ->  OTH (*)
;
; (* Other include NoE, various MC, etc.)

; observer procedure
to-report _project-type [eis-type]
    ifelse   (eis-type = "CP")
      ;; collaborative project
      [ report "cp" ]
    [ ifelse (eis-type = "CP-FP")
      ;; small or medium-scale focused research project
      [ report "fp" ]
    [ ifelse (eis-type = "CP-IP")
      ;; large-scale integrating project
      [ report "ip" ]
    [ ifelse (eis-type = "MC-ITN")
      ;; Marie Curie initial training network
      [ report "itn" ]
    [ ifelse (eis-type = "MC-IEF")
      ;; Intra-European fellowship for career development
      [ report "ief" ]
    [ ifelse (eis-type = "CSA")
      ;; coordination and support action
      [ report "csa" ]
    [ ifelse (eis-type = "CSA-CA")
      ;; coordination (or networking) action
      [ report "ca" ]
    [ ifelse (eis-type = "CSA-SA")
      ;; support action
      [ report "sa" ]
    [ ifelse (eis-type = "BSG-SME")
      ;; research for SMEs
      [ report "sme" ]
    [ ifelse (eis-type = "ERC-SG")
      ;; ERC starting grant
      [ report "sg" ]
    [ ifelse (eis-type = "ERC-AG")
      ;; ERC advanced grant
      [ report "ag" ]
    [ ifelse (eis-type = "CP-CSA-Infra")
      ;; integrating activity
      [ report "infra" ]
    [ ifelse (eis-type = "CP-TP")
      ;; collaborative project targeted to SMEs
      [ report "tp" ]
      ;; default
      [ report "oth" ]
    ]]]]]]]]]]]]
end


; Convert from EIS database to SKIN-type

; no SME flag! (the default for firms is LDF)

; observer procedure
to-report _participant-type [eis-type]
    ifelse   (eis-type = "Institute")
      ;; research institute (extra-university or other)
      [ report "ins" ]
    [ ifelse (eis-type = "University")
      ;; university
      [ report "uni" ]
    [ ifelse (eis-type = "LargeFirm")
      ;; large firm
      [ report "ldf" ]
    [ ifelse (eis-type = "Firm")
      ;; firm
      [ report "ldf" ]
    [ ifelse (eis-type = "SmallFirm")
      ;; small firm
      [ report "sme" ]
    [ ifelse (eis-type = "Governmental")
      ;; governmental organisation
      [ report "gov" ]
    [ ifelse (eis-type = "NonGovernmental")
      ;; non-governmental organisation
      [ report "ngo" ]
    [ ifelse (eis-type = "Center")
      ;; center
      [ report "ctr" ]
    [ ifelse (eis-type = "EntityOther")
      ;; other entity
      [ report "oth" ]
      ;; default
      [ report "" ]
    ]]]]]]]]
end


; Convert from EIS database to SKIN-type

; observer procedure
to-report _organisation-type [eis-type]
    ifelse   (eis-type = "Fraunhofer Gesellschaft")
      ;; Fraunhofer institute
      [ report "fhg" ]
    [ ifelse (eis-type = "Helmholtz Gemeinschaft")
      ;; Helmholtz center
      [ report "hgf" ]
    [ ifelse (eis-type = "Leibniz Gemeinschaft")
      ;; Leibniz institute
      [ report "wgl" ]
    [ ifelse (eis-type = "Max-Planck-Gesellschaft")
      ;; Max Planck institute
      [ report "mpg" ]
      ;; default
      [ report "" ]
    ]]]
end


;;; INITIALISE INSTITUTES
;;;
;;; Initialise institutes, make kenes


; Make institutes as empty shells, yet to be filled with knowledge

to #:initialise-institutes
    set institutes-dict table:make
    ask institutes [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-institutes: my-institute-nr = " my-institute-nr)
       table:put institutes-dict my-institute-nr self
    ]
    let nr 1 + count institutes
    create-institutes nInstitutes [
      set my-institute-nr nr
      set my-type "ins"
      set my-org-type "fhg"  ; TO DO: perc and size per organisation

      table:put institutes-dict my-institute-nr self
      set nr nr + 1
      hide-turtle
    ]
    ask institutes [
      #:initialise
      #:initialise-institute
    ]
end


; Initialise more of the institute's variables (not previously set)

; institute procedure
to #:initialise-institute
    set my-SCI-capacity 50
    set my-EI-capacity  20
    set my-funding 10
    set my-demand 40
    set my-output 50
    set my-price 1
    set my-resources 0
    set my-SCI-fraction 0.8
    set my-EI-fraction 0.2
end


;;; INITIALISE INTERMEDIARIES
;;;
;;; Initialise intermediaries, make kenes


; Make intermediaries as empty shells, yet to be filled with knowledge

to #:initialise-intermediaries
    set intermediaries-dict table:make
    ask intermediaries [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-intermediaries: my-intermediary-nr = " my-intermediary-nr)
       table:put intermediaries-dict my-intermediary-nr self
    ]
    let nr 1 + count intermediaries
    create-intermediaries nIntermediaries [
      set my-intermediary-nr nr
      set my-type "imd"

      table:put intermediaries-dict my-intermediary-nr self
      set nr nr + 1
      hide-turtle
    ]
    ask intermediaries [
      #:initialise
;     #:initialise-intermediary
    ]
end


;;; INITIALISE FIRMS
;;;
;;; Initialise firms, make kenes


; Make firms as empty shells, yet to be filled with knowledge

to #:initialise-firms
    set firms-dict table:make
    ask firms [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-firms: my-firm-nr = " my-firm-nr)
       table:put firms-dict my-firm-nr self
    ]
    let nLDF round (Perc-LDF * nFirms / 100)
    let nSME round (Perc-SME * nFirms / 100)
    let nr 1 + count firms
    ; large diversified firms
    create-firms nLDF [
      set my-firm-nr nr
      set my-type "ldf"
      set my-capital 10 * $:Initial-capital-SME
      set my-age 200

      table:put firms-dict my-firm-nr self
      set nr nr + 1
      hide-turtle
    ]
    ; SMEs
    create-firms nSME [
      set my-firm-nr nr
      set my-type "sme"
      set my-capital $:Initial-capital-SME
      set my-age 200

      table:put firms-dict my-firm-nr self
      set nr nr + 1
      hide-turtle
    ]
    ask firms [
      #:initialise
      #:initialise-firm
    ]
end


; Initialise more of the firm's variables (not previously set)

; firm procedure
to #:initialise-firm
    set my-IH []
    set my-advert []
    set my-inputs []
    set my-research-direction "random"
    set done-rad-research? false
    set my-suppliers []
    set my-customers []
    set selling? true
    set buying?  true
    set my-markup 1
    set my-price (random $:Max-price) + 1  ; price of my product is initially random
;   set sell-buy-vector []
;   set network-partner-vector []
;   set customers-firm-ID []
;   set network-firm-ID []
    set network-firm? false
    set my-founder nobody
    set high-potential? false
end


;;; INITIALISE ENTREPRENEURS
;;;
;;; Initialise entrepreneurs, make kenes


; Make entrepreneurs as empty shells, yet to be filled with knowledge

to #:initialise-entrepreneurs
    set entrepreneurs-dict table:make
    ask entrepreneurs [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-entrepreneurs: my-nr = " my-entrepreneur-nr)
       table:put entrepreneurs-dict my-entrepreneur-nr self
    ]
    let nENT nEntrepreneurs
    let nr 1 + count entrepreneurs
    create-entrepreneurs nENT [
      set my-entrepreneur-nr nr
      set my-type "ent"
      set my-capital 0.1 * $:Initial-capital-SME

      table:put entrepreneurs-dict my-entrepreneur-nr self
      set nr nr + 1
      hide-turtle
    ]
    ask entrepreneurs [
      #:initialise
      #:initialise-entrepreneur
    ]
end


; Initialise more of the entrepreneur's variables (not previously set)

to #:initialise-entrepreneur
    set my-start-up nobody
end


;;; INITIALISE PARTICIPANTS
;;;
;;; Initialise the (potential) participants in projects


to #:initialise-participants
    set participants (turtle-set institutes intermediaries firms entrepreneurs)
    let pnr 1
    set participants-dict table:make
    ask participants [
      set my-pnr pnr

      table:put participants-dict pnr self
      set pnr pnr + 1
    ]
end


;;; INITIALISE AGENCIES
;;;
;;; Initialise agencies


; Make agencies as empty shells

to #:initialise-agencies
    set agencies-dict table:make
    ask agencies [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-agencies: my-nr = " my-agency-nr)
       table:put agencies-dict my-agency-nr self
    ]
    let nr 1 + count agencies
    create-agencies nAgencies [
      set my-agency-nr nr
      set my-type "fnd"

      table:put agencies-dict my-agency-nr self
      set nr nr + 1
      hide-turtle
    ]
;   ask agencies [
;     #:initialise-agency
;   ]
end


;;; INITIALISE ORGANISATIONS
;;;
;;; Initialise the research organisations


to #:initialise-organisations
    let nr 1
    set organisations-dict table:make
    ask organisations [
;      set my-nr ... ; my-nr is already set?
       print (word "initialise-organisations: my-organisation-nr = " my-organisation-nr)
       table:put organisations-dict my-type self
    ]
    create-organisations I:n [
      let ot nr - 1
      set my-organisation-nr nr
      set my-type item ot I:Organisation-types
;     set EI-balance array:item I:EI-balance ot
      set EI-balance 0.25

      set SCI-weight-C1 0.333
      set SCI-weight-C2 0.333
      set SCI-weight-C3 0.333
      set SCI-weight-C  0.5 * (1 - EI-balance)
      set SCI-weight-P1 0.333
      set SCI-weight-P2 0.333
      set SCI-weight-P3 0.333
      set SCI-weight-P  0.5 * (1 - EI-balance)
      set EI-weight-C1  0.333
      set EI-weight-C2  0.333
      set EI-weight-C3  0.333
      set EI-weight-C   0.5 * EI-balance
      set EI-weight-P1  0.333
      set EI-weight-P2  0.333
      set EI-weight-P3  0.333
      set EI-weight-P   0.5 * EI-balance

      table:put organisations-dict my-type self
      set nr nr + 1
      hide-turtle
    ]
end


;;; INITIALISE THEMES
;;;
;;; Structure the knowledge space (n themes)


to #:initialise-themes
    let nr 1
    set themes-dict table:make
    create-themes K:nThemes [
      set theme-nr nr
      set theme-description (word "" nr)

      table:put themes-dict theme-description self
      set nr nr + 1
      hide-turtle
    ]
end


;;; INITIALISE INSTRUMENTS
;;;
;;; Create the instruments


to #:initialise-instruments
    let nr 1
    set instruments-dict table:make
    create-instruments P:n [
      let pt nr - 1
      set instr-nr nr
      set instr-type item pt P:Project-types
;     set instr-size array:item P:Size pt
      set instr-size-min array:item P:Size-min pt
      set instr-size-max array:item P:Size-max pt
      set instr-sub-nr-max array:item P:Sub-nr-max pt
      set instr-sub-size-min array:item P:Sub-size-min pt
;     set instr-INT-min array:item P:INT-min pt
;     set instr-LDF-min array:item P:LDF-min pt
;     set instr-SME-min array:item P:SME-min pt
      set instr-duration-avg array:item P:Duration-avg pt
      set instr-duration-stdev array:item P:Duration-stdev pt
      set instr-contribution array:item P:Contribution pt
      set instr-match array:item P:Match pt

      table:put instruments-dict instr-type self
      set nr nr + 1
      hide-turtle
    ]
end


;;; INITIALISE CALLS
;;;
;;; Create calls


; Calls are created and published run-time by the research funding agencies

; observer procedure
to #:initialise-calls
    set calls-dict table:make
end


; When a new call is published, the deadline for a proposal is six months away, i.e. the agents
; have six time steps to set up a consortium and to write a proposal.

; agency procedure
to-report r1:make-call [the-call-type]
    let the-new-call nobody
    hatch-calls 1 [
      let pt 0
      set the-new-call self

      set call-nr __P__highest-call-nr + 1
      set call-type the-call-type
      set call-id call-nr
      set call-publication-date ticks
      set call-deadline ticks + P:Time-before-call-deadline
      set call-funding     array:item P:Funding-calls pt
      set call-orientation array:item P:Orientation-calls pt
      set call-cap-range   array:item P:Range-calls pt
      set call-capabilities []
      set call-status ""
      set call-evaluated? false
      set call-counter table:make
      set __P__highest-call-nr call-nr

      table:put calls-dict call-id self
      hide-turtle
    ]
    ask the-new-call [ &:make-cap-range ]
    report the-new-call
end


; Initialise all the agent's variables, except my-type and my-cap-capacity, previously set

; Important Remark concerning the initialisation of SMEs, start-ups and entrepreneurs
; -----------------------------------------------------------------------------------
; We discussed the important meaning of SMEs, start-ups and entrepreneurs concerning their
; contribution to radical research. New knowledge is injected into the system most often by new,
; small and sophisticated companies.Therefore, we should design SMEs, start-ups and entrepreneurs
; with this rare knowledge.
; We structure the knowledge space, allocating 100 capabilities to each of the themes.
; In order to allow the SMEs to play their special role we define 10 capabilities per theme
; as “rare” capabilities and give these capabilities in the starting distribution exclusively to
; SMEs, start-ups and entrepreneurs.

to #:initialise
    set my-name ""
    set my-R-partners no-turtles
    set my-previous-R-partners no-turtles
    set my-I-partners no-turtles
    set my-previous-I-partners no-turtles
    set my-T-partners no-turtles
    set my-previous-T-partners no-turtles
    set my-E-partners no-turtles
    set my-previous-E-partners no-turtles
    set my-capabilities []
    set my-abilities []
    set my-expertises []
    set my-orientations []
    set my-proposals no-turtles
    set my-projects no-turtles
    set my-participation-in-proposals []
    set my-participation-in-projects []
end


;;; MAKE KENES
;;;


; participant procedure
to &:make-kene
    ; Set cap-capacity depending on type
    if (my-type = "ins") [ set my-cap-capacity Size-INS ]
    if (my-type = "imd") [ set my-cap-capacity Size-IMD ]
    if (my-type = "ldf") [ set my-cap-capacity Size-LDF ]
    if (my-type = "sme") [ set my-cap-capacity Size-SME ]
    if (my-type = "sup") [ set my-cap-capacity Size-SUP ]
    if (my-type = "ent") [ set my-cap-capacity Size-ENT ]

    ; Fill the capability vector with capabilities. These are integers between 1 and nCapabilities, such
    ; that no number is repeated.
    ; First, fill half of the capability vector with sector capabilities
    while [length my-capabilities < my-cap-capacity * 0.5] [
      let candidate-capability &:pick-sector-capability
      if (not member? candidate-capability my-capabilities) [
        set my-capabilities lput candidate-capability my-capabilities
      ]
    ]
    ; SMEs, start-ups and entrepreneurs should have at least one rare capability
    if ((my-type = "sme") or (my-type = "sup") or (my-type = "ent"))
      [ set my-capabilities lput &:pick-rare-capability my-capabilities ]
    ; Fill the capability vector
    while [length my-capabilities < my-cap-capacity] [
      let candidate-capability &:pick-common-capability
      if (not member? candidate-capability my-capabilities) [
        set my-capabilities lput candidate-capability my-capabilities
      ]
    ]

    ; Fill the ability and expertise vectors with real numbers randomly chosen from 0 .. <10 for abilities
    ; and integers from 1 .. 10 for expertise levels
    while [length my-abilities < length my-capabilities] [
      set my-abilities lput random-float 10.0 my-abilities
      set my-expertises lput ((random 10) + 1) my-expertises
    ]

    ; We extend the capabilities, abilities and expertise by a research orientation, which is represented by
    ; an integer between 0 and 9 (0 corresponds to a full basic research orientation; 9 corresponds to a
    ; full applied research orientation)
    while [length my-orientations < length my-capabilities] [
      ifelse (my-type = "res")
        [ set my-orientations lput random 5 my-orientations ]
        [ set my-orientations lput ((random 5) + 5) my-orientations ]
    ]
end


; participant procedure
to &:make-kene-and-IH [manufacture?]
    &:make-kene
    &:make-IH
    &:make-advert
    if (manufacture?)
      [ &:manufacture ]  ; not strictly necessary, but sets the initial product
end


; call procedure
to &:make-cap-range
    ; Set cap-range-size depending on type
    if (call-type = "bm") [ set call-cap-range Range-calls-BM ]
    if (call-type = "ec") [ set call-cap-range Range-calls-EC ]

    ; fill the capability vector with unique capabilities.
    ; These are integers between 1 and nCapabilities, such that no number is repeated.
    while [length call-capabilities < call-cap-range] [
      let candidate-capability 1 + random K:nCapabilities
      if (not member? candidate-capability call-capabilities) [
        set call-capabilities lput candidate-capability call-capabilities
      ]
    ]
end


;---------------------------------------------------------------------------
;   Theme    Sector capabilities    Common capabilities    Rare capabilities
;       1           1 -  40               41 -  80             81 -  100
;       2         101 - 140              141 - 180            181 -  200
;     ...            ...                    ...                  ...
;       9         801 - 840              841 - 880            881 -  900
;      10         901 - 940              941 - 980            981 - 1000
;---------------------------------------------------------------------------

to-report &:pick-sector-capability
    let theme 1 + random (count themes)  ; 1 .. 10
    let sector-capability 1 + random K:Sector-capabilities-per-theme  ; 1 .. 40
    let capabilities-per-theme K:nCapabilities / count themes  ; 100
    report sector-capability + (theme - 1) * capabilities-per-theme
end


to-report &:pick-common-capability
    let theme 1 + random (count themes)  ; 1 .. 10
    let capabilities-per-theme K:nCapabilities / count themes  ; 100
    let common-capabilities-per-theme capabilities-per-theme - (K:Sector-capabilities-per-theme + K:Rare-capabilities-per-theme)  ; 40
    let common-capability 1 + random common-capabilities-per-theme  ; 1 .. 40
    report K:Sector-capabilities-per-theme + common-capability + (theme - 1) * capabilities-per-theme
end


to-report &:pick-rare-capability
    let theme 1 + random (count themes)  ; 1 .. 10
    let rare-capability 1 + random K:Rare-capabilities-per-theme  ; 1 .. 20
    let capabilities-per-theme K:nCapabilities / count themes  ; 100
    report capabilities-per-theme - K:Rare-capabilities-per-theme + rare-capability + (theme - 1) * capabilities-per-theme
end


;;; GO
;;;
;;; Main loop


; observer procedure
to #:go
    if (ticks = nMonths) [ stop ]

    ifelse (Empirical-case?) [
      ; Empirical case
      __L__log-stage 2 "Networks"
      r:go      ; R-Networks       (Stage 2.1 only)

      __L__log-stage 4 "Valuations"
      v:go      ; Valuations       (Stage 4)
    ] [
      ; Simulation
;     s:go      ; System

      __L__log-stage 1 "Metabolism"
      %:go "choose-strategy"

      __L__log-stage 2 "Networks"
      r:go      ; R-Networks       (Stage 2.1)
      i:go      ; I-Networks       (Stage 2.2)
;     t:go      ; T-Networks       (Stage 2.3)
;     e:go      ; E-Networks       (Stage 2.4)

      __L__log-stage 3 "Transactions"
      $:go      ; Transactions     (Stage 3)

      __L__log-stage 4 "Valuations"
      v:go      ; Valuations       (Stage 4)

      __L__log-stage 5 "Metabolism"
      %:go "allocate-resources"
      %:go "evaluate-strategy"

      ask firms [ #:do-admin ]
    ]

    tick

    __I__update-institute-measures
    ; update-network-measures is computationally expensive and is commented out (but not
    ; deleted because it could be useful for demos that work with small agentsets)
;   if (ticks mod Network-update-interval = 0)
;     [ __N__update-network-measures ]

    if (not Empirical-case?)
      [ __K__update-knowledge-measures ]

    __U__update-plots

    let pos position Export-settings ["none (fastest)" "model (default)" "all"]
    if (pos > 0) [
      __X__update-run-data
      if ((pos > 1) or (ticks = nMonths)) [
        ; if the run is part a BehaviorSpace experiment (run-number > 0) then export to simdb
        ; otherwise export to workdir
        __X__export-network-data (behaviorspace-run-number > 0)
        if (not Empirical-case?)
          [ __X__export-knowledge-data (behaviorspace-run-number > 0) ]
        if (ticks = nMonths)
          [ __X__export-run-data (behaviorspace-run-number > 0) ]
      ]
    ]
end


;;; MONITORS
;;;
;;; monitor some outputs


; observer procedure
to-report __U__show-call-status [the-call-nr]
    let the-call one-of calls with [call-nr = the-call-nr]
    report [call-status] of the-call
end


; observer procedure
to-report __U__show-call-counter [the-proposal-status]
    report [table:get call-counter the-proposal-status] of __P__the-current-call
end



;;;;;;;;;;;;;;;;;;
;;;            ;;;
;;;   SYSTEM   ;;;
;;;            ;;;
;;;;;;;;;;;;;;;;;;



; The survival threshold Ts is a feature of the general market environment that rolls together a
; lot of different things, from formal thresholds for entry and competition in markets to informal
; perceptions by company leaders of which firms are “serious” partners.
;
; The growth threshold Tg is another feature of the general market environment that outlines the
; development stages of a succesful company.

; observer procedure
to s:go
    if (not System?) [ stop ]
    print "go System"
    ; The baseline scenario is overall tougher demands for firm performance, which is mirrored by an
    ; increasing survival threshold level.
    ; The baseline scenario for growth rate?
end



;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   METABOLISM   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



; observer procedure
to %:go [stage]
    if (not Metabolism?) [ stop ]

    ; stage %1 - institutes choose strategy
    ; stage %2 - agents participate in networks
    ; stage %3 - resources are generated and allocated
    ; stage %4 - institutes evaluate strategy

    ; Simulation
      ifelse (stage = "choose-strategy")
      [ ask institutes [
          %1:select-instruments
          %1:implement-measures
        ]
      ]
    [ ifelse (stage = "allocate-resources")
      [ ask institutes [
          %3:allocate-resources
        ]
      ]
    [ ifelse (stage = "evaluate-strategy")
      [ ask institutes [
          %4:evaluate-strategy
        ]
      ]
      ;; default case
      [ print (word "Unknown stage " stage) ]
  ]]
end


; apply SCI & EI criteria; select instruments and implement measures

; institute procedure
to %1:select-instruments
end


; implement measures

; institute procedure
to %1:implement-measures
end


; allocate revenues from transfer and other resources to top up SCI & EI capacity

; institute procedure
to %3:allocate-resources
end


; assess the impacts of its strategy against SCI & EI criteria

; institute procedure
to %4:evaluate-strategy
end



;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   R-NETWORKS   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



; observer procedure
to r:go
    if (not R-Networks?) [ stop ]
    array:set __K__knowledge-flow 0 0

    ; stage r1 - Call is published. Agents develop research proposals
    ; stage r2 - Call is closed. Proposals are evaluated
    ; stage r3 - Consortia carry out projects
    ; stage r4 - Projects are evaluated

    ifelse (Empirical-case?) [
      ; Empirical case - stage r3 only
      ask projects [
        r3:start-project
        r3:finish-project
      ]
      r3:dissolve-projects
    ] [
      ; Simulation
      ask agencies [
        r1:make-calls "ec"
        r1:publish-calls "ec"
      ]
      __L__log-calls "ec"
      ask participants [
        r1:initiate-proposals
        r1:find-partners
        r1:submit-proposals
      ]
      __L__log-proposals "ec"

      ask agencies [
        r2:close-calls "ec"
        r2:evaluate-calls
      ]
      __L__log-evaluation
      r2:dissolve-proposals
      __L__log-projects "ec"

      ask projects [
        r3:start-project
        r3:learn-from-partners
        r3:do-research
        r3:make-deliverables
        r3:finish-project
      ]
      r3:adjust-expertise-levels
      r3:dissolve-projects
    ]
end


; make new calls for being published at a certain date

; agency procedure
to r1:make-calls [the-call-type]
;   let time-elapsed ...
    if (ticks mod P:Time-between-calls = 0) [
      print (word "making a new call of type " the-call-type)
      let the-new-call r1:make-call the-call-type
      if (__L__log-debug?) [
        ask the-new-call [
          print (word "I have initiated a new call (nr = " call-nr ").")
          print (word "Its cap range is " call-capabilities)
        ]
      ]
    ]
end


; agency procedure
to r1:publish-calls [the-call-type]
    ask calls with [(call-type = the-call-type) and (call-publication-date = ticks)] [
      set call-status "open"
      ; to keep an eye on the open calls, we show the latest call
      set __P__the-current-call self
    ]
end


; agency procedure
to r2:close-calls [the-call-type]
    ask calls with [(call-type = the-call-type) and (call-deadline = ticks + 1)]
      [ set call-status "closed" ]
end


; Notify the call about the changed status of the proposal. This is for measuring the process
; in response to the call only
;
; here is an example:
; Call 1 is notified about the change that a proposal is "submitted". This procedure updates
; the table of call 1, increasing the number of submitted proposals.
; If this is the first proposal that is submitted for the call, the table key "submitted" does
; not exist and thus cannot be read. In this case, the new key is mapped to the value 1

; proposal procedure
to _notify-changed-status
    let the-updated-value 1
    let the-counter [call-counter] of table:get calls-dict proposal-call
    if (table:has-key? the-counter proposal-status)
      [ set the-updated-value (table:get the-counter proposal-status) + 1 ]
    table:put the-counter proposal-status the-updated-value
end


;;; PROPOSALS & RESEARCH CONSORTIA
;;;
;;; initiate proposals, invite partners, formulate and submit proposals


; Initiation of Proposals
; -----------------------
; Proposals are (most often) initiated by research institutes. The possibility to initiate a
; proposal depends on the length of the kene. We assume that a project or one proposal requires
; at minimum the kene length of an SME (which is five quadruples). (From this follows that the
; number of proposals a research institute can initiate depends on the length of its kene
; divided by the minimum length of the kene of an SME.)
;
; As each agent cannot be engaged in an extensive number of projects and proposal writings the
; number of initiated proposals follows:
; (length of the kene) / (minimum length of an SME kene) x (the number of existing projects)
;
; To summarise:
; the number of new proposals initiated depends on
;   1. size (~ kene length)
;   2. existing projects

; participant procedure
to r1:initiate-proposals
    if (my-type = "ins") [
      let the-call one-of calls with [(call-type = "ec") and (call-status = "open")]
      if (the-call != nobody)
        [ r1:initiate-proposal the-call ]
    ]
end


; participant procedure
to-report r1:room-for-another-proposal?
    report (length my-capabilities / K:Project-cap-ratio) - (count my-proposals + count my-projects) > 0
end


; make an 'empty' proposal

; participant procedure
to-report r1:make-proposal
    let the-new-proposal nobody
    hatch-proposals 1 [
      set the-new-proposal self
      set proposal-nr __P__highest-proposal-nr + 1
      set proposal-consortium no-turtles
      set proposal-status "initiated"
      set proposal-ranking-nr 0
      set proposal-capabilities []
      set proposal-abilities []
      set proposal-expertises []
      set proposal-orientations []
      set proposal-contributors []
      set __P__highest-proposal-nr proposal-nr
    ]
    report the-new-proposal
end


; if enough room and relevant capabilities initiate one proposal

; participant procedure
to r1:initiate-proposal [the-call]
    let log? __L__log? and __L__log-r?
    let n 1
    repeat n [
      ifelse (r1:room-for-another-proposal?) [
        let relevant-capabilities _intersection my-capabilities [call-capabilities] of the-call
        if (not empty? relevant-capabilities) [
          let the-new-proposal r1:make-proposal
          if (log?) [
            type (word "I am participant " my-pnr " (" my-type ") (in " count my-proposals " proposals). ")
            print (word "I am initiating a new proposal " [proposal-nr] of the-new-proposal ".")
          ]
          set my-proposals (turtle-set my-proposals the-new-proposal)
          ask the-new-proposal [
            set proposal-type [call-type] of the-call
            set proposal-call [call-id] of the-call
            set proposal-coordinator myself
            _notify-changed-status
          ]
          r1:join the-new-proposal
        ]
      ]
      [ if (log?) [ print (word "I have no 'room' for initiating a new proposal.")  print "" ] ]
    ]
end


; A proposal is a compilation of kene quadruples of agents in the proposal consortium.
; - Each agent is contributing one capability to the proposal.
; - If the agent has a capability which is specified in the call he contributes this capability.
; - If the agent possesses more than one capability outlined in the call we randomly choose
;   one of these capabilities.
;
; The possibilities to join a proposal consortium are determined by the same rules we applied
; for the determination of project initiations. The length of the kene determines whether the
; agent has free capacities for new activities, e.g. a SME, whose kene is of minimum size
; (i.e. five quadruples) and which is already in a project or a proposal initiative has to
; reject the offer.


; participant procedure
to r1:join [the-proposal]
    let log? __L__log? and __L__log-r?
    if (log?) [ type (word "I am participant " my-pnr " (" my-type "). I am invited to join proposal " [proposal-nr] of the-proposal ". ") ]
    ifelse (r1:room-for-another-proposal?) [
      ; randomly choose capabilities to contribute
      let the-call table:get calls-dict [proposal-call] of the-proposal
      let relevant-capabilities _intersection my-capabilities [call-capabilities] of the-call
      ifelse (not empty? relevant-capabilities) [
        if (log?) [ print "I accept." ]
        let n my-cap-capacity / K:Project-cap-ratio  ; "room" for adding capabilities
        while [n > 0 and not empty? relevant-capabilities] [
          let capability one-of relevant-capabilities
          let location position capability my-capabilities
          ; add a kene quadruple to the proposal
          ask the-proposal [
            set proposal-capabilities lput capability proposal-capabilities
            set proposal-abilities    lput (item location [my-abilities]    of myself) proposal-abilities
            set proposal-expertises   lput (item location [my-expertises]   of myself) proposal-expertises
            set proposal-orientations lput (item location [my-orientations] of myself) proposal-orientations
            ; who added the kene quadruple?
            set proposal-contributors lput ([my-pnr] of myself) proposal-contributors
          ]
          set relevant-capabilities remove capability relevant-capabilities
          set n n - 1
        ]
        ; become a consortium partner
        ask the-proposal [ set proposal-consortium (turtle-set proposal-consortium myself) ]
        set my-proposals (turtle-set my-proposals the-proposal)
      ]
      [ if (log?) [ type (word "I have no relevant capabilities for joining this proposal. ")  print "I decline." ] ]
    ]
    [ if (log?) [ type (word "I have no 'room' for joining the new proposal. ")  print "I decline." ] ]
end


; Partner Search
; --------------
; First, the agent looks on the list of his previous partners.
; Second, previous partners, who agreed to join the proposal, can add previous partners
; from their list.
; Third, new partners will be searched for.
; The search process is guided by the requirements outlined in the call. These requirements
; are a list of capabilities and the proposal is considered to be eligible only, if at minimum
; one of these capabilities appears.
; If no agent from the list of previous partners can contribute such a capability in the first
; iteration, than in the second iteration previous partners of those agents who agreed to join
; the proposal can ask their previous partners. If the required capability is not found, the
; proposal consortium can search for the knowledge in the population of all actors. This is
; done on a random basis. In every iteration n agents can be asked whether they have the
; respective capability and whether they want to join the proposal consortium.


; participant procedure
to r1:find-partners
    foreach [self] of my-proposals with [proposal-status = "initiated" and proposal-coordinator = myself]
      [ r1:find-possible-partners ? ]
end


; participant procedure
to r1:find-possible-partners [the-proposal]
    let log? __L__log? and __L__log-r?
    if (log?) [
      type (word "I am participant " my-pnr " (" my-type "). ")
      type (word "I am coordinator of proposal " [proposal-nr] of the-proposal ". ")
      print "I am searching possible partners for this proposal."
    ]

    let nr 0
    let possible-partners []
    let declined []  ; if declined, do not ask again

    if (r1:Invite-previous-partners-first?) [
      ; 1st iteration - search previous partners
      set possible-partners [self] of my-previous-R-partners ; of the coordinator
      ; the search
      set nr 0
      while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
        let a-possible-partner one-of possible-partners
        ask a-possible-partner [ r1:join the-proposal ]
        set possible-partners remove a-possible-partner possible-partners
        if (not member? a-possible-partner [proposal-consortium] of the-proposal)
          [ set declined lput a-possible-partner declined ]
        set nr nr + 1
      ]

      ; 2nd iteration - previous partners can add their previous partners
      let previous-partners no-turtles
      ask my-previous-R-partners [ set previous-partners (turtle-set previous-partners my-previous-R-partners) ]
      set possible-partners [self] of previous-partners with [not member? self [proposal-consortium] of the-proposal]
      set possible-partners _set-difference declined possible-partners
      ; the search (same as above)
      set nr 0
      while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
        let a-possible-partner one-of possible-partners
        ask a-possible-partner [ r1:join the-proposal ]
        set possible-partners remove a-possible-partner possible-partners
        if (not member? a-possible-partner [proposal-consortium] of the-proposal)
          [ set declined lput a-possible-partner declined ]
        set nr nr + 1
      ]
    ]

    ; 3rd iteration - search new partners
    set possible-partners [self] of participants with [not member? self [proposal-consortium] of the-proposal]
    set possible-partners _set-difference declined possible-partners
    ; the search (same as above)
    set nr 0
    while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
      let a-possible-partner one-of possible-partners
      ask a-possible-partner [ r1:join the-proposal ]
      set possible-partners remove a-possible-partner possible-partners
      if (not member? a-possible-partner [proposal-consortium] of the-proposal)
        [ set declined lput a-possible-partner declined ]
      set nr nr + 1
    ]
end


; reporter for the ranking the potential partners on attractiveness.
; the search for new partners in the 3rd iteration requires a concept of what makes for an attractive
; potential partner. Relevant factors for attractiveness include a participant's type, size (kene length),
; rare capabilities, research orientation, thematic orientation, position in the network, etc.

; WARNING: A sort on 3000 participants is computationally expensive and is consequently not used.

; to-report r:attractiveness-comparator? [ a-potential-partner another-potential-partner ]
;     ; 1st ranking order - Average expertise level of the potential partners
;     ; 2nd ranking order - Desired research orientation of the potential partners
;     ; 3rd ranking order - Randomly decide on the ranking
;     if ([mean my-expertises] of a-potential-partner > [mean my-expertises] of another-potential-partner) [ report true ]
;     if ([mean my-expertises] of a-potential-partner = [mean my-expertises] of another-potential-partner)
;       [
;         if ([mean my-orientations] of a-potential-partner > [mean my-orientations] of another-potential-partner) [ report true ]
;         if ([mean my-orientations] of a-potential-partner = [mean my-orientations] of another-potential-partner) [ report random 2 = 1 ]
;       ]
;     report false
;end


; A proposal will be submitted if at least one capability appears. Otherwise the process is
; stopped and the agents may start a new initiative.

; participant procedure
to r1:submit-proposals
    let log? __L__log? and __L__log-r?
    ask my-proposals with [proposal-status = "initiated" and proposal-coordinator = myself] [
      if (log?) [ type (word "I am participant " [my-pnr] of myself ". ") ]
      ifelse (r2:eligible? self) [
        if (log?) [ print "I am submitting this proposal."  print "" ]
        set proposal-status "submitted"
        _notify-changed-status
      ] [
        if (log?) [ print "I am stopping this proposal."  print "" ]
        set proposal-status "stopped"
        _notify-changed-status
        r2:dissolve-proposal
      ]
    ]
end


;;; EVALUATION OF PROPOSALS
;;;
;;; evaluate (reject or accept) proposals


; Evaluation of calls
; -------------------
; Proposals have to fulfil the hard criteria to be considered as eligible, otherwise they are rejected.
; Hard factors are: sufficient partners with the desired research orientation.
; Concerning the desired research orientation the following rule will be applied: The Commission asks
; in their calls for a research orientation of a certain value; e.g. a more applied research project
; requires a research orientation of the consortium above 7.5. This value is computed as the average
; of the individual research orientations.
; Also a hard factor for a proposal to be considered as eligible is the requirement that at least one
; of the capabilities specified in the call appear in the proposal.


; observer procedure
to r2:evaluate-calls
  ask calls with [call-status = "closed" and call-evaluated? = false] [
     r2:evaluate-proposals
     set call-evaluated? true
  ]
end


; call procedure
to r2:evaluate-proposals
    ; look at all submitted proposals - which proposals are eligible?
    let the-submitted-proposals proposals with [proposal-status = "submitted" and proposal-call = [call-id] of myself]
    ask the-submitted-proposals [
      ifelse (r2:eligible? self)
        [ set proposal-status "eligible" ]
        [ set proposal-status "ineligible" ]
      _notify-changed-status
    ]
    ; look at all eligible proposals - which proposals get highest ranking?
    let the-eligible-proposals the-submitted-proposals with [proposal-status = "eligible"]
    ; the number of proposals that are accepted depends on the funding available for this call
    let threshold r2:rank the-eligible-proposals ((call-funding / 100) * Funding)
    ask the-eligible-proposals [
      ifelse (proposal-ranking-nr <= threshold)
        [ set proposal-status "accepted" ]
        [ set proposal-status "rejected" ]
      _notify-changed-status
    ]
end


; observer procedure
to-report r2:eligible? [the-proposal]
    let the-instrument table:get instruments-dict [proposal-type] of the-proposal
    let the-consortium [proposal-consortium] of the-proposal
    ; consortium too small or too big?
    if (count the-consortium < [instr-size-min] of the-instrument)
      [ report false ]
    if (count the-consortium > [instr-size-max] of the-instrument)
      [ report false ]
    ; 1st hard factor - sufficient partners with the desired research orientation
    let the-call table:get calls-dict [proposal-call] of the-proposal
    if ([mean proposal-orientations] of the-proposal < [call-orientation] of the-call)
      [ report false ]
    ; 2nd hard factor - sufficient capabilities specified in the call appear in the proposal
    if (r2:capability-match the-proposal < [instr-match] of the-instrument)
      [ report false ]
    ; OK for all factors
    report true
end


; observer procedure
to-report r2:capability-match [the-proposal]
    let the-call table:get calls-dict [proposal-call] of the-proposal
    report length _intersection [proposal-capabilities] of the-proposal [call-capabilities] of the-call
end


; All proposals which fulfil the eligibility criteria are than ranked according to the following rule:
; The first ranking order is the average expertise level of the proposals (i.e. the expertise levels of
; the capabilities are summed up and divided by the number of quadruples in the proposal).
; If some proposals turn out to have the same average expertise level, the second criteria applied is
; the number of capabilities specified in the call which are in the proposal (i.e. a proposal is ranked
; higher in the case more outlined capabilities are used).
; If after the application of this rule proposals are still ranked equally, we randomly decide on the
; ranking. As in the call the number x of projects which will be supported by the Commission is
; specified, the Commission chooses the x highest ranked proposals.


; observer procedure
to-report r2:rank [the-eligible-proposals the-funding-available]
    ; 1. give a (unique) ranking-nr to each of the eligible proposals
    ; 2. report the number of proposals that can be funded
    set the-eligible-proposals sort-by [r2:ranking-comparator? ?1 ?2] the-eligible-proposals
    let n 0
    let nr 1
    foreach the-eligible-proposals [
      ask ? [
        set proposal-ranking-nr nr
        let the-instrument table:get instruments-dict proposal-type
        let funding-requested (count proposal-consortium * [instr-duration-avg] of the-instrument *
            [instr-contribution] of the-instrument) / 1000000
        set the-funding-available the-funding-available - funding-requested
        if (the-funding-available >= 0)
          [ set n n + 1 ]
        set nr nr + 1
      ]
    ]
    report n
end


; reporter for the ranking the eligible proposals.
; Two proposals are being compared. Reporter should be true if ?1 comes strictly before ?2 in the desired
; sort order, and false otherwise

to-report r2:ranking-comparator? [a-proposal another-proposal]
    if ([proposal-type] of a-proposal = "hpsu")
      [report r2:ranking-comparator? a-proposal another-proposal]

    ; 1st ranking order - average expertise level of the proposals
    ; 2nd ranking order - number of capabilities specified in the call which are in the proposal
    ; 3rd ranking order - randomly decide on the ranking
    if ([mean proposal-expertises] of a-proposal > [mean proposal-expertises] of another-proposal) [ report true ]
    if ([mean proposal-expertises] of a-proposal = [mean proposal-expertises] of another-proposal)
      [
        if (r2:capability-match a-proposal > r2:capability-match another-proposal) [ report true ]
        if (r2:capability-match a-proposal = r2:capability-match another-proposal) [ report random 2 = 1 ]
      ]
    report false
end


;;; COMBINE PROPOSALS
;;;

; very large projects can be the result of combining two or more proposals into one. This can be done by the Commission
; after the ranking of all eligible proposals

; WARNING: This needs to be fleshed out further

; call procedure
;to r2:combine-proposals
;    let accepted-proposal one-of proposals with [proposal-status = "accepted"]
;    let rejected-proposal one-of proposals with [proposal-status = "rejected"]
;    r2:combine accepted-proposal rejected-proposal
;end


; observer procedure
;to r2:combine [a-proposal another-proposal]
;    ask a-proposal [
;      set proposal-consortium (turtle-set proposal-consortium [proposal-consortium] of another-proposal)
;      foreach [proposal-capabilities] of another-proposal [ set proposal-capabilities lput ? proposal-capabilities ]
;      foreach [proposal-abilities]    of another-proposal [ set proposal-abilities    lput ? proposal-abilities ]
;      foreach [proposal-expertises]   of another-proposal [ set proposal-expertises   lput ? proposal-expertises ]
;      foreach [proposal-orientations] of another-proposal [ set proposal-orientations lput ? proposal-orientations ]
;      foreach [proposal-contributors] of another-proposal [ set proposal-contributors lput ? proposal-contributors ]
;    ]
;    ask another-proposal [
;      set proposal-status "combined"
;    ]
;end


;;; DISSOLVE PROPOSALS & MAKE PROJECTS
;;;


; Proposal consortia which are not successful are dissolved.
; Proposal consortia which are successful become project consortia.

; observer procedure
to r2:dissolve-proposals
    ; successful consortia -> project consortia
    ask proposals with [proposal-status = "accepted"] [
      r2:make-project
      r2:dissolve-proposal
    ]
    ; dissolve merged consortia
    ask proposals with [proposal-status = "merged"] [ r2:dissolve-proposal ]
    ; dissolve consortia that are not successful
    ask proposals with [proposal-status = "ineligible"] [ r2:dissolve-proposal ]
    ask proposals with [proposal-status = "rejected"] [ r2:dissolve-proposal ]
end


; make the project based on the proposal

; proposal procedure
to r2:make-project
    let the-proposal self
    let the-consortium proposal-consortium
    let the-instrument table:get instruments-dict proposal-type
    let the-new-project nobody
    hatch-projects 1 [
      set the-new-project self
      ; pass on properties of the proposal to the new project
      set project-nr [proposal-nr] of the-proposal
      set project-type [proposal-type] of the-proposal
      set project-call [proposal-call] of the-proposal
      set project-consortium (turtle-set the-consortium)
      set project-capabilities map [?] [proposal-capabilities] of the-proposal
      set project-abilities map [?] [proposal-abilities] of the-proposal
      set project-expertises map [?] [proposal-expertises] of the-proposal
      set project-orientations map [?] [proposal-orientations] of the-proposal
      set project-contributors map [?] [proposal-contributors] of the-proposal
      ; project starts x months after the call closed
      set project-start-date ticks + P:Time-before-project-start
      ; project end date depends on the project type
      ; duration is drawn from normal distristibution
      set project-end-date project-start-date + round random-normal [instr-duration-avg] of the-instrument [instr-duration-stdev] of the-instrument
      ; EC contribution depends on the project type and size
      set project-contribution count project-consortium * [instr-duration-avg] of the-instrument * [instr-contribution] of the-instrument
      set project-subprojects no-turtles
      set project-status ""
      set project-successful? false
    ]

    if (not Empirical-case?) [
      ; allocate partners to subprojects
      ask the-new-project [ r2:allocate-to-subprojects ]
      ask [project-subprojects] of the-new-project [ r3:make-deliverable ]
    ]

    if (__L__log?) [ print (word "New project " [project-nr] of the-new-project " of type " [project-type] of the-new-project ".") ]
end


; proposal procedure
to r2:dissolve-proposal
    let the-proposal self

    ; update agents
    ask proposal-consortium [
      ; remove the proposal from my proposals list
      set my-proposals (my-proposals with [self != the-proposal])
      ; update proposal participation list
      if ([proposal-status] of the-proposal != "stopped") [
        set my-participation-in-proposals lput ([proposal-nr] of the-proposal) my-participation-in-proposals
      ]
    ]

    ; update proposal measures
    if (proposal-status != "stopped") [
      let pos position proposal-type P:Project-types
      array:set __P__proposals-count pos array:item __P__proposals-count pos + 1
      if (count proposal-consortium with [my-type = "sme"] > 0) [
        array:set __P__proposals-with-SME-count pos (array:item __P__proposals-with-SME-count pos + 1)
      ]
      ; TO DO: update count of international proposals
      array:set __P__proposals-type      pos lput proposal-type                                      (array:item __P__proposals-type pos)
      array:set __P__proposals-call      pos lput proposal-call                                      (array:item __P__proposals-call pos)
      array:set __P__proposals-size      pos lput (count proposal-consortium)                        (array:item __P__proposals-size pos)
      array:set __P__proposals-INS       pos lput (count proposal-consortium with [my-type = "ins"]) (array:item __P__proposals-INS pos)
      array:set __P__proposals-IMD       pos lput (count proposal-consortium with [my-type = "imd"]) (array:item __P__proposals-IMD pos)
      array:set __P__proposals-LDF       pos lput (count proposal-consortium with [my-type = "ldf"]) (array:item __P__proposals-LDF pos)
      array:set __P__proposals-SME       pos lput (count proposal-consortium with [my-type = "sme"]) (array:item __P__proposals-SME pos)
      array:set __P__proposals-SUP       pos lput (count proposal-consortium with [my-type = "sup"]) (array:item __P__proposals-SUP pos)
      array:set __P__proposals-ENT       pos lput (count proposal-consortium with [my-type = "ent"]) (array:item __P__proposals-ENT pos)
      array:set __P__proposals-exp-level pos lput ([mean proposal-expertises] of the-proposal)       (array:item __P__proposals-exp-level pos)
      array:set __P__proposals-cap-match pos lput (r2:capability-match the-proposal)                 (array:item __P__proposals-cap-match pos)
    ]

    die
end


;;; RESEARCH PROJECTS & DELIVERABLES
;;;
;;; start projects, do research, make deliverables


; Every 3 months:
;   Make new deliverable
;   Map artefact: deliverable -> publication or patent
;   Improve results?
;
; Every month:
;   Do incremental research
;   Adjust expertises
;   Learn from partners


; project procedure
to r3:start-project
    let log? __L__log? and __L__log-r?
    if (project-start-date = ticks) [
      set project-status "started"
      if (not Empirical-case?)
        [ ask project-subprojects [ set subproject-status "started" ] ]
      if (__L__log?) [ print (word "Project " project-nr " has now started.") ]

      let the-project self
      let the-consortium project-consortium

      ; update the partners
      ask the-consortium [
        ; add the project to my projects list
        set my-projects (turtle-set my-projects the-project)
        ; add the consortium partners to my list of current partners
        set my-R-partners (turtle-set my-R-partners (the-consortium with [self != myself]))
        ; update project participation list
        set my-participation-in-projects lput ([project-nr] of the-project) my-participation-in-projects
      ]

      ; update project measures
      let pos position project-type P:Project-types
      array:set __P__projects-count pos (array:item __P__projects-count pos) + 1
      if (count the-consortium with [my-type = "sme"] > 0) [
        array:set __P__projects-with-SME-count pos ((array:item __P__projects-with-SME-count pos) + 1)
      ]
      ; TO DO: update count of international projects
      array:set __P__projects-nr           pos lput project-nr                                    (array:item __P__projects-nr pos)
      array:set __P__projects-id           pos lput project-id                                    (array:item __P__projects-id pos)
      array:set __P__projects-type         pos lput project-type                                  (array:item __P__projects-type pos)
      array:set __P__projects-call         pos lput project-call                                  (array:item __P__projects-call pos)
      array:set __P__projects-size         pos lput (count the-consortium)                        (array:item __P__projects-size pos)
      array:set __P__projects-INS          pos lput (count the-consortium with [my-type = "ins"]) (array:item __P__projects-INS pos)
      array:set __P__projects-IMD          pos lput (count the-consortium with [my-type = "imd"]) (array:item __P__projects-IMD pos)
      array:set __P__projects-LDF          pos lput (count the-consortium with [my-type = "ldf"]) (array:item __P__projects-LDF pos)
      array:set __P__projects-SME          pos lput (count the-consortium with [my-type = "sme"]) (array:item __P__projects-SME pos)
      array:set __P__projects-SUP          pos lput (count the-consortium with [my-type = "sup"]) (array:item __P__projects-SUP pos)
      array:set __P__projects-ENT          pos lput (count the-consortium with [my-type = "ent"]) (array:item __P__projects-ENT pos)
      array:set __P__projects-OTH          pos lput (count the-consortium with [my-type = "oth"]) (array:item __P__projects-OTH pos)
      array:set __P__projects-duration     pos lput (project-end-date - project-start-date)       (array:item __P__projects-duration pos)
      array:set __P__projects-contribution pos lput (project-contribution / 1000000)              (array:item __P__projects-contribution pos)
    ]
end


; project procedure
to r3:finish-project
    if (project-end-date = ticks) [
      set project-status "finished"
      if (not Empirical-case?)
        [ ask project-subprojects [ set subproject-status "finished" ] ]
    ]
end


; The research in the projects follows the ideas of SKEIN. Agents in project consortia are randomly
; allocated to subprojects and combine their kenes. Every three months they produce an output (deliverable)
; which can be a working paper, a journal article or a patent. During the length of the project they can
; improve their results.
;
; The research undertaken in projects is incremental research (abilities are substituted, expertise
; levels are increased). The potential of a radical innovation is determined only when the proposal is put
; together in the sense that new capability combinations can appear in consortia. SMEs are important
; candidates for contributing new capabilities and therefore increase the likelihood for
; radical innovation.


; randomly allocate partners to subprojects and combine their kenes.

; project procedure
to r2:allocate-to-subprojects
    let the-instrument table:get instruments-dict project-type
    let partners [self] of project-consortium
    ifelse (length partners < 2 * [instr-sub-size-min] of the-instrument) [
      ; small consortium - only 1 subproject
      r2:make-subprojects 1
      ; add all partners to the 1 subproject
      foreach partners [
        let the-subproject one-of project-subprojects
        ask ? [ r2:commit-to the-subproject ]
      ]
    ] [
      ; more than 1 subproject
      r2:make-subprojects min list [instr-sub-nr-max] of the-instrument int ((length partners) / [instr-sub-size-min] of the-instrument)
      ; add randomly the minimal number of partners per subproject
      ask project-subprojects [
        foreach n-of [instr-sub-size-min] of the-instrument partners [
          ask ? [ r2:commit-to myself ]
          set partners remove ? partners
        ]
      ]
      ; add randomly the remaining partners to subprojects
      foreach partners [
        let the-subproject one-of project-subprojects
        ask ? [ r2:commit-to the-subproject ]
      ]
    ]
end


; project procedure
to r2:make-subprojects [the-number-of-subprojects]
    set project-subprojects no-turtles
    ; create the number of subprojects
    let the-project self
    let the-new-subproject nobody
    let nr 1
    repeat the-number-of-subprojects [
      hatch-subprojects 1 [
        set the-new-subproject self
        set subproject-nr nr
        set subproject-project the-project
        set subproject-deliverable []
        set subproject-partners no-turtles
        set subproject-status ""
        set subproject-outputs 0
        set incr-research-direction "random"
        set subproject-capabilities []
        set subproject-abilities []
        set subproject-expertises []
        set subproject-orientations []
        set subproject-contributors []
        set nr nr + 1
      ]
      set project-subprojects (turtle-set project-subprojects the-new-subproject)
    ]
end


; participant procedure
to r2:commit-to [the-subproject]
    let my-number my-pnr
    let the-project [subproject-project] of the-subproject
    ; commit to the subproject
    ask the-subproject [
      ; participant becomes partner of the subproject
      set subproject-partners (turtle-set subproject-partners myself)
      ; commit the kene quadruples contributed to the project in the proposal stage
      let i 0
      foreach [project-contributors] of the-project [
        if (? = my-number) [
          set subproject-capabilities lput (item i [project-capabilities] of the-project) subproject-capabilities
          set subproject-abilities lput (item i [project-abilities] of the-project) subproject-abilities
          set subproject-expertises lput (item i [project-expertises] of the-project) subproject-expertises
          set subproject-orientations lput (item i [project-orientations] of the-project) subproject-orientations
          set subproject-contributors lput my-number subproject-contributors
        ]
        set i i + 1
      ]
    ]
end


; every three months the subprojects produce an output (deliverable).
; This can be a journal article or a patent

; project procedure
to r3:make-deliverables
    if (project-status = "started") [
      ; the time elapsed since the project was started
      let time-elapsed ticks - project-start-date
      if ((time-elapsed > 0) and (time-elapsed mod P:Time-between-deliverables = 0)) [
        ask project-subprojects with [subproject-status = "started"] [
          ; produce an output (journal article or patent)
          r3:produce-output
          ; improve or change the deliverable
          r3:make-deliverable
        ]
      ]
    ]
end


; subproject procedure
to r3:produce-output
    if (subproject-status = "started") [
      set subproject-outputs subproject-outputs + 1
    ]
end


; a deliverable is a vector of locations in the subproject's kene. So, for example, a deliverable
; might be [1 3 4 7], meaning the second (counting from 0 as the first), fourth, fifth and eighth
; quadruple in the kene. The deliverable cannot be longer than the length of the kene, nor shorter
; than 2, but is of random length between these limits.

; subproject procedure
to r3:make-deliverable
    set subproject-deliverable []
    let location 0
    let kene-length length subproject-capabilities
    let deliverable-length _random-between 2 (min list kene-length K:Max-deliverable-length + 1)
    while [deliverable-length > 0] [
      set location random kene-length
      if (not member? location subproject-deliverable) [
        set subproject-deliverable lput location subproject-deliverable
        set deliverable-length deliverable-length - 1
      ]
    ]
    ; reorder the elements of the deliverable in numeric ascending order
    set subproject-deliverable sort subproject-deliverable

    ; initialise incremental research values, since this is a new deliverable, and
    ; previous research will have been using a different deliverable
    set incr-research-direction "random"
end


; project procedure
to r3:do-research
    if (project-status = "started") [
      ask project-subprojects with [subproject-status = "started"]
        [ r3:do-incremental-research ]
    ]
end


; do incremental research (abilities are substituted)

; subproject procedure
to r3:do-incremental-research
    if (subproject-status = "started") [
      if (incr-research-direction = "random") [
        let location random length subproject-deliverable
        set ability-to-research item location subproject-deliverable
        ifelse ((random 2) = 1)
          [ set incr-research-direction "up" ]
          [ set incr-research-direction "down" ]
      ]
      let new-ability item ability-to-research subproject-abilities
      ; TO DO step size is not optimal (see Excel sheet)
      ifelse (incr-research-direction = "up")
        [ set new-ability new-ability + (new-ability / item ability-to-research subproject-capabilities) ]
        [ set new-ability new-ability - (new-ability / item ability-to-research subproject-capabilities) ]
      if (new-ability <= 0) [ set new-ability 0  set incr-research-direction "random" ]
      if (new-ability > 10) [ set new-ability 10 set incr-research-direction "random" ]
      set subproject-abilities replace-item ability-to-research subproject-abilities new-ability
    ]
end


; Raise the expertise level by one (up to a maximum of 10) for capabilities that are used (in my-used-capabilities).
; Decrease the expertise level by one for capabilities that are not used (in my-capabilities but not in my-used-capabilities).
; If an expertise level has dropped to zero, the capability is forgotten, but only if the capability is not contributed
; to any project (not in my-contributed-capabilities).


to r3:adjust-expertise-levels
    let n floor (K:Adjust-expertise-rate * (count participants))
    ask n-of n participants [ r3:adjust-expertise-subprojects ]
end


to r3:adjust-expertise-subprojects
    let my-number my-pnr
    let my-contributed-capabilities []
    let my-used-capabilities []

    ; list all my contributed and used capabilities
    ask subprojects [
      let i 0
      foreach subproject-contributors [
        if (? = my-number) [
          let contributed-capability item i subproject-capabilities
          ; for contributed-capabilites we consider also the projects that have not started yet
          set my-contributed-capabilities lput contributed-capability my-contributed-capabilities
          ; for used-capabilities we consider only the projects that have already started
          if ((subproject-status = "started") and (member? i subproject-deliverable)) [
            set my-used-capabilities lput contributed-capability my-used-capabilities
          ]
        ]
        set i i + 1
      ]
    ]
    set my-contributed-capabilities remove-duplicates sort my-contributed-capabilities
    set my-used-capabilities remove-duplicates sort my-used-capabilities

    ; adjust my expertise levels
    let location 0
    while [location < length my-capabilities] [
      let capability item location my-capabilities
      let expertise item location my-expertises
      ifelse (member? capability my-used-capabilities) [
        ; capability has been used - increase expertise if possible
        if (expertise < 10)
          [ set my-expertises replace-item location my-expertises (expertise + 1) ]
      ] [
        ; capability has not been used - decrease expertise and drop capability if expertise
        ; has fallen to zero, but only if capability is not contributed to any project
        ifelse (expertise > 0) [
          set my-expertises replace-item location my-expertises (expertise - 1)
        ] [
          if (not member? capability my-contributed-capabilities) [
            r3:forget-capability location
            set location location - 1
          ]
        ]
      ]
      set location location + 1
    ]

    ; update the expertise levels of all projects that the participant is or will be contributor of.
    ; There are two effects:
    ; 1. an immediate effect on the expertise in these projects, which will benefit from the contributor's
    ;    gained expertise or suffer from its lost expertise.
    ; 2. a later effect on the expertise levels that the contributor will add to new proposals

;   let my-self self
;   ask subprojects [
;     ; this also updates the subprojects that have not started yet!
;     let i 0
;     while [i < length subproject-capabilities] [
;       let contributor-nr item i subproject-contributors
;       if (contributor-nr = my-number) [
;         let contributed-capability item i subproject-capabilities
;         set location position contributed-capability [my-capabilities] of my-self
;         set subproject-expertises replace-item i subproject-expertises (item location [my-expertises] of my-self)
;       ]
;       set i i + 1
;     ]
;   ]
end


; remove the capability, ability, expertise at the given location of the kene.
; The capability that is being forgotten is not included in a project's deliverable.
; Although the kene is changed, the deliverable and the output are not (since
; the forgotten capability is not in the deliverable, this doesn't matter)

to r3:forget-capability [location]
    set my-capabilities remove-item location my-capabilities
    set my-abilities    remove-item location my-abilities
    set my-expertises   remove-item location my-expertises
    set my-orientations remove-item location my-orientations
end


; obtain capabilities from partners.
; The capabilities that are learned are those from the subproject's deliverable

; project procedure
to r3:learn-from-partners
    if (project-status = "started") [
      ask project-subprojects with [subproject-status = "started"]
        [ r3:learn-from-subproject-partners ]
    ]
end


; subproject procedure
to r3:learn-from-subproject-partners
    if (subproject-status = "started") [
      ask subproject-partners [ r3:add-capabilities myself ]
    ]
end


; the expertise levels of the capabilities used for the deliverables are increasing at each iteration.
; Capabilities of deliverables are exchanged among partners (i.e. knowledge transfer in projects, but
; they have to start with low expertise).
; for each capability in the deliverable, if it is new to me,
; add it (and its ability) to my kene (if I have sufficient capacity), and make
; the expertise level 1 less. For each capability that is not new, if the subproject's
; expertise level is greater than mine, adopt its ability and expertise level,
; otherwise do nothing

; participant procedure
to r3:add-capabilities [the-subproject]
    ; measure the agent's knowledge before
    let my-knowledge-before length my-capabilities

    let new-capability? false
    let contributor-nr 0

    let location 0
    foreach [subproject-deliverable] of the-subproject [
      let capability item ? [subproject-capabilities] of the-subproject

      set new-capability? false
      set contributor-nr 0

      ifelse (member? capability my-capabilities) [
        ; capability already known to me
        set location position capability my-capabilities
        if (item location my-expertises < item ? [subproject-expertises] of the-subproject) [
          set my-expertises replace-item location my-expertises (item ? [subproject-expertises] of the-subproject)
          set my-abilities replace-item location my-abilities (item ? [subproject-abilities] of the-subproject)
        ]
      ] [
        ; capability is new to me; adopt it if I have 'room'
        if (length my-capabilities < my-cap-capacity) [
          set my-capabilities lput capability my-capabilities
          set my-abilities lput (item ? [subproject-abilities] of the-subproject) my-abilities
          let other-expertise (item ? [subproject-expertises] of the-subproject) - 1
          ; if other-expertise is 1, it is immediately forgotten by adjust-expertise
          if (other-expertise < 2) [ set other-expertise 2 ]
          set my-expertises lput other-expertise my-expertises
          set my-orientations lput (item ? [subproject-orientations] of the-subproject) my-orientations

          ; record the knowledge flow
          set new-capability? true
          set contributor-nr (item ? [subproject-contributors] of the-subproject)
        ]
      ]

      if (new-capability?) [
        let contributor table:get participants-dict contributor-nr
        if ([my-type] of contributor = "ins") [
          if (my-type = "ins") [ array:set __K__kf-INS-to-INS 0 ((array:item __K__kf-INS-to-INS 0) + 1) ]
          if (my-type = "ldf") [ array:set __K__kf-INS-to-LDF 0 ((array:item __K__kf-INS-to-LDF 0) + 1) ]
          if (my-type = "sme") [ array:set __K__kf-INS-to-SME 0 ((array:item __K__kf-INS-to-SME 0) + 1) ]
        ]
        if ([my-type] of contributor = "ldf") [
          if (my-type = "ins") [ array:set __K__kf-LDF-to-INS 0 ((array:item __K__kf-LDF-to-INS 0) + 1) ]
          if (my-type = "ldf") [ array:set __K__kf-LDF-to-LDF 0 ((array:item __K__kf-LDF-to-LDF 0) + 1) ]
          if (my-type = "sme") [ array:set __K__kf-LDF-to-SME 0 ((array:item __K__kf-LDF-to-SME 0) + 1) ]
        ]
        if ([my-type] of contributor = "sme") [
          if (my-type = "ins") [ array:set __K__kf-SME-to-INS 0 ((array:item __K__kf-SME-to-INS 0) + 1) ]
          if (my-type = "ldf") [ array:set __K__kf-SME-to-LDF 0 ((array:item __K__kf-SME-to-LDF 0) + 1) ]
          if (my-type = "sme") [ array:set __K__kf-SME-to-SME 0 ((array:item __K__kf-SME-to-SME 0) + 1) ]
        ]
      ]
    ]

    ; measure the agent's knowledge after
    let my-knowledge-after length my-capabilities
    array:set __K__knowledge-flow 0 ((array:item __K__knowledge-flow 0) + my-knowledge-after - my-knowledge-before)
end


;;; DISSOLVE PROJECTS
;;;


; at the end of the project all results are delivered to the agency. And the partners start new
; proposal consortia etc. Only in the case the results are below a certain threshold the agency puts
; the partners of the project on a black list. However, so far we have not considered to implement any
; consequences from this.

; observer procedure
to r3:dissolve-projects
    ask projects with [project-status = "finished"] [ r3:dissolve-project ]
end


; project procedure
to r3:dissolve-project
    let the-project self
    let the-consortium project-consortium
    ;let npa count :participants

    ; update partners
    ask the-consortium [
      ; remove the project from my projects list
      set my-projects my-projects with [self != the-project]
      ; add the consortium partners to my list of previous partners
      set my-previous-R-partners (turtle-set my-previous-R-partners (the-consortium with [self != myself]))
      ; update history of partnerships
;     let mynr my-pnr
;     foreach [self] of the-consortium with [my-pnr > mynr] [
;       let index ((mynr - 1) * npa) + [my-pnr] of ? - 1
;       array:set P:partnerships-matrix index (array:item P:partnerships-matrix index) + 1
;     ]
      ; TO DO : number of participants is not known
      ; rebuild my list of partners
      r3:rebuild-partners-list
    ]

    ; the project and its subprojects die
    if (not Empirical-case?)
      [ ask project-subprojects [ die ] ]
    die
end


; participant procedure
to r3:rebuild-partners-list
    set my-R-partners no-turtles
    foreach [self] of my-projects with [project-status = "started"] [
      let the-consortium [project-consortium] of ?
      set my-R-partners (turtle-set my-R-partners (the-consortium with [self != myself]))
    ]
end



;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   I-NETWORKS   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



;                       procedures called            variables set
;                       ----------------------       --------------
; collaborate           find-partners                my-I-partners
;                       learn-from-partners          kenes of partners
; create-networks       create-networks
;                       make-network                 network, network firm

; observer procedure
to i:go
    if (not I-Networks?) [ stop ]
    array:set __K__knowledge-flow 1 0
    print "go I-Networks"

    ; two possibilities:

    ; self-organizing innovation networks (SEIN)
    ; stage i1 - Firms find partners to collaborate with and form partnerships
    ; stage i2 - Firms carry out incremental or radical research and adjust expertise and prices
    ; stage i3 - Firms create networks

    ; innovation centres (IPSE)
    ; stage i1 - ...
    ; stage i2 - ...
    ; stage i3 - ...

    ifelse (Empirical-case?) [
      ; Empirical case
    ] [
      ; Simulation
      ask firms [
        i1:collaborate
      ]
      __L__log-partnerships

      ask firms [
        i2:do-research
      ]
;     __L__???

      ask firms [
        i3:create-networks
      ]
      __L__log-networks
    ]
end


;;; COLLABORATION
;;;
;;; find partners to collaborate with and form partnerships


; find some partners to form partnerships with, if the current product is not being produced

; firm procedure
to i1:collaborate
    if ((not Partnering?) or (Partnership-strategy = "no partners")) [ stop ]
    if (my-sales = 0) [
      i1:find-partners
      if (count my-I-partners > 0)
        [ i1:learn-from-partners ]
      $:pay-tax $:Collaboration-tax * count my-I-partners
    ]
end


; try up to Max-partners times to find partners to collaborate with, looking first at previous
; partners and then at suppliers, customers and finally others.
; For each partner found, tell the partner that I am now a partner

; firm procedure
to i1:find-partners
    let candidates 0
    set candidates (sentence my-previous-I-partners my-suppliers my-customers)
    while [length candidates < i1:Max-partners]
      [ set candidates lput one-of firms candidates ]
    set candidates remove-duplicates candidates
    while [length candidates > i1:Max-partners]
      [ set candidates but-last candidates ]
    foreach filter [i1:compatible? ?] candidates [
      set my-I-partners (turtle-set my-I-partners ?)
      ask ? [
        set my-I-partners (turtle-set my-I-partners myself)
      ]
    ]
end


; reports true or false according to whether the possible partner is sufficiently attractive,
; according to the current partnership strategy

; firm procedure
to-report i1:compatible? [possible-partner]
    let attractiveness 0
    ; reject impossible potential partners
    if ((possible-partner = self) or (possible-partner = nobody) or (not is-agent? possible-partner))
      [ report false ]
    ; a partner cannot already be a member of my network
    if ((is-agent? my-I-network) and (my-I-network != nobody) and
        (member? possible-partner [network-members] of my-I-network))
      [ report false ]
    ; a possible partner cannot already be a partner of mine
    if ((member? self [my-I-partners] of possible-partner) or (member? possible-partner my-I-partners))
      [ report false ]
    ifelse (Partnership-strategy = "conservative")
      [ set attractiveness (length _intersection my-advert [my-advert] of possible-partner) /
            (min list length my-advert length [my-advert] of possible-partner) ]
      [ ifelse ((length _intersection my-advert [my-advert] of possible-partner) >= 1)
          [ set attractiveness (length _set-difference my-advert [my-advert] of possible-partner) /
                (length my-advert + length [my-advert] of possible-partner) ]
          [ set attractiveness 0 ]
      ]
    report attractiveness > Attractiveness-threshold
end


; obtain capabilities from partners. The capabilities that are learned are those
; from the partners' innovation hypothesis

; firm procedure
to i1:learn-from-partners
    ask my-I-partners
      [ &:merge-capabilities myself ]
    &:make-IH
end


; firm procedure
to &:merge-capabilities [the-other]
    &:add-capabilities-from the-other
    ask the-other [ &:add-capabilities-from myself ]
end


; for each capability in the other's innovation hypothesis, if it is new to me,
; add it (and its ability) to my kene (if I have sufficient capital), and make
; the expertise level 1 less. For each capability that is not new, if the other's
; expertise level is greater than mine, adopt his ability and expertise level,
; otherwise do nothing.

; firm procedure
to &:add-capabilities-from [the-other]
    let capability 0
    let my-position 0

    foreach [my-IH] of the-other [
      set capability item ? [my-capabilities] of the-other
      ifelse (member? capability my-capabilities) [
        ; capability already known to me
        set my-position position capability my-capabilities
        if (item my-position my-expertises < item ? [my-expertises] of the-other) [
          set my-expertises replace-item my-position my-expertises item ? [my-expertises] of the-other
          set my-abilities replace-item my-position my-abilities item ? [my-abilities] of the-other
        ]
      ] [
        ; capability is new to me; adopt if I have 'room'
        if ((length my-capabilities) < ((my-capital / $:Capital-knowledge-ratio) + 1)) [
          set my-capabilities sentence my-capabilities capability
          set my-abilities sentence my-abilities item ? [my-abilities] of the-other
          let other-expertise (item ? [my-expertises] of the-other) - 1
          ; if other-expertise is 1, it is immediately forgotten by adjust-expertise
          if (other-expertise < 2)
            [ set other-expertise 2 ]
          set my-expertises sentence my-expertises other-expertise
        ]
      ]
    ]
end


;;; RESEARCH
;;;
;;; carry out incremental or radical research and adjust expertise


; Successful firms don't do research, they just keep on with their previous product
; (unless their kene has changed through partnering).
; Unsuccessful firms normally do incremental research. However, if their capital has
; almost all gone, they do radical research instead.

to i2:do-research
    if (my-last-reward < Success-threshold) [
      ifelse (my-capital <= &:Low-capital-threshold)
        [ i2:do-radical-research ]
        [ i2:do-incremental-research ]
    ]
end


; adjust an ability up or down.  If this is the second or subsequent time of doing incremental
; research, and the last reward was positive (although less than success-threshold, since if it
; were above that, the firm would continue to produce the last innovation, rather than do
; research), make a change to the same ability in the same direction.
; If the first time or the research proved unsuccessful (the firm made a loss and last-reward
; is 0), choose a capability from the innovation hypothesis at random and alter the ability
; in a random direction by one unit.

; research-direction is initially "random".  It is set here to "down" or "up" to show
; direction of research.  If an ability has been explored to the limit (reached 0 or 10),
; the direction is reset to random.

to i2:do-incremental-research
    if (not Inc-research?) [ stop ]
    let new-ability 0
    if (my-research-direction = "random") [
      set ability-to-research random length my-IH
      ifelse ((random 2) = 1)
        [ set my-research-direction "up" ]
        [ set my-research-direction "down" ]
      set new-ability item ability-to-research my-abilities
    ]
    ifelse (my-research-direction = "up")
      [ set new-ability new-ability + &:Inc-step / item ability-to-research my-capabilities ]
      [ set new-ability new-ability - &:Inc-step / item ability-to-research my-capabilities ]
    if (new-ability <= 0) [
      set new-ability 0
      set my-research-direction "random"
    ]
    if (new-ability > 10) [
      set new-ability 10
      set my-research-direction "random"
    ]
    set my-abilities replace-item ability-to-research my-abilities new-ability
    $:pay-tax $:Inc-research-tax
end


; radical research just means
; a. randomly changing one capability for a new value and then
; b. constructing a new innovation hypothesis from the kene

to i2:do-radical-research
    if (not Rad-research?) [ stop ]
    let capability-to-mutate 0
    let new-capability 0
    set done-rad-research? true
    set capability-to-mutate (random length my-capabilities)
    set new-capability (random K:nCapabilities) + 1  ; find a capability that is new to this firm
    while [member? new-capability my-capabilities]
      [ set new-capability (random K:nCapabilities) + 1 ]
    set my-capabilities replace-item capability-to-mutate my-capabilities new-capability
    &:make-IH
    &:make-advert
    $:pay-tax $:Rad-research-tax
end


; raise the expertise level by one (up to a maximum of 10) for capabilities that
; are used in the innovation, and decrease by one for capabilities that are not.
; If an expertise level has dropped to zero, the capability is forgotten.

to &:adjust-expertise
    if (not Adj-expertise?) [ stop ]
    let location 0
    let expertise 0
    while [location < length my-capabilities] [
      set expertise item location my-expertises
      ifelse (member? location my-IH) [
        if (expertise < 10)
          [ set my-expertises replace-item location my-expertises (expertise + 1) ]
      ] [
        ifelse (expertise > 0) [
          set my-expertises replace-item location my-expertises (expertise - 1)
        ] [
          &:forget-capability location
          set location location - 1
        ]
      ]
      set location location + 1
    ]
end


; remove the capability, ability, expertise at the given location of the kene.
; Warning; all hell will break loose if the capability that is being forgotten is included
; in the innovation hypothesis (but no test is done to check this).
; Although the keen is changed, the innovation hypothesis and the product are not (since
; the forgotten capability is not in the IH, this doesn't matter)

to &:forget-capability [location]
    set my-capabilities remove-item location my-capabilities
    set my-abilities    remove-item location my-abilities
    set my-expertises   remove-item location my-expertises
    set my-orientations remove-item location my-orientations
    &:adjust-IH location
end


; reduce the values (which are indices into the kene) in the innovation hypothesis to
; account for the removal of a capability.  Reduce all indices above 'location' by one

to &:adjust-IH [location]
    let i 0
    let elem 0
    set i 0
    while [i < length my-IH] [
      set elem item i my-IH
      if (elem > location)
        [ set my-IH replace-item i my-IH (elem - 1 ) ]
      set i i + 1
    ]
end


;;; CREATE NETWORKS
;;;

; if the firm's last innovation was successful and they are not already a member of
; a network and they have some partners that are not already members of a network
; and they have enough capital, initiate the formation of a network and add myself
; and my partners as the initial members

; firm procedure
to i3:create-networks
    if (not Networking?) [ stop ]
    if ((my-last-reward > Success-threshold) and (my-capital > $:Initial-capital-SME) and
        (not is-agent? my-I-network)) [
      set my-previous-I-partners remove nobody my-previous-I-partners
      if ((length my-previous-I-partners > 0) and
          (length filter [not is-agent? [my-I-network] of ?] my-previous-I-partners > 0))
        [ i3:create-network ]
    ]
end


; create a network agent founded on myself as the first member and add my partners as members.
; a network consist of a network agent with an associated network firm. The latter does all
; the work of innovation and production for the network. Collect the start-up capital for
; the new firm from the partners, in proportion to the partners' wealth

; firm procedure
to i3:create-network
    if (is-agent? my-I-network) [ stop ]
    let the-network 0
    set the-network i3:make-network
    i3:add-myself-and-partners the-network
    show (word "my network = " my-I-network " the-network = " the-network
        " firm = " [network-firm] of the-network " members = " [network-members] of the-network)
    let partners-wealth reduce [?1 + ?2] map [[my-capital] of ?1] [network-members] of the-network
    foreach [network-members] of the-network
      [ set my-capital my-capital - ($:Initial-capital-SME * my-capital / partners-wealth) ]
    ask [network-firm] of the-network [
      &:make-IH
      &:make-advert
      &:manufacture
    ]
end


; make an 'empty' network (a new network object and a new firm object)

to-report i3:make-network
    let founder 0
    let net 0
    set founder self
    hatch 1 [
      ; create a network agent
      set breed networks
      hide-turtle
      set network-members []
      hatch 1 [
        ; create a firm for the network
        set breed firms
;       set [network-firm] of myself self  ; tell network about its firm TO DO
        set my-capital $:Initial-capital-SME
        set network-firm? true
        set my-I-network myself  ; tell network firm about its network
        ; the network's firm starts with a copy of the capabilities from the founder's IH
        i3:copy-IH-capabilities founder
        set firm-id __#__current-max-firm-id ; the firm gets the first, never used, free firm id
        set __#__current-max-firm-id __#__current-max-firm-id + 1  ; increment for the current-max-firm-id
        show-turtle
      ]
      set net self
    ]
    report net
end


; copy the kene triples corresponding to the innovation hypothesis from the source to this firm

to i3:copy-IH-capabilities [source]
    foreach [my-IH] of source [
      set my-capabilities lput (item ? [my-capabilities] of source) my-capabilities
      set my-abilities    lput (item ? [my-abilities]    of source) my-abilities
      set my-expertises   lput (item ? [my-expertises]   of source) my-expertises
      set my-orientations lput (item ? [my-orientations] of source) my-orientations
    ]
end


; if I have enough capital and am not already a member, add myself to the network, and
; then add all my partners to the network (and so on recursively)

to i3:add-myself-and-partners [the-network]
    if ((not is-agent? my-I-network) and (not member? self [network-members] of the-network) and
        (my-capital > $:Initial-capital-SME / (1 + length [network-members] of the-network))) [
;     set [network-members] of the-network lput self [network-members] of the-network TO DO
;     set [my-I-network] of self the-network TO DO
      &:merge-capabilities [network-firm] of the-network
      foreach my-previous-I-partners [
        if (? != nobody) [ ask ? [i3:add-myself-and-partners the-network ] ]
      ]
    ]
end



;;;;;;;;;;;;;;
;;;        ;;;
;;;  R&D   ;;;
;;;        ;;;
;;;;;;;;;;;;;;



;;; KNOWLEDGE LEVEL
;;;
;;; create innovation hypothesis, advert etc.

; an innovation hypothesis is a vector of locations in the kene. So, for example, an IH
; might be [1 3 4 7], meaning the second (counting from 0 as the first), fourth, fifth
; and eighth triple in the kene. The IH cannot be longer than the length of the kene,
; but is of random length.

to &:make-IH
    let kene-length 0
    let IH-length 0
    let location 0

    set my-IH []
    set kene-length length my-capabilities
    set IH-length _random-between 2 (min list kene-length K:Max-IH-length + 1)
    while [IH-length > 0] [
      set location random kene-length
      if (not member? location my-IH) [
        set my-IH lput location my-IH
        set IH-length IH-length - 1
      ]
    ]
    set my-IH sort my-IH  ; reorders the elements of the innovation hypothesis in numeric ascending order

    ; number of inputs required for this IH is between 3 and nInputs, but not more than length of IH
    set my-number-of-inputs min list (length my-IH) (max list 3 (random nInputs + 1))

    ; reset markup to random, since there will be a new product
;   set my-markup random 100
    set my-research-direction "random"
end


; set up the firm's advert, which is the list of capabilities in its innovation hypothesis

to &:make-advert
    set my-advert map [item ? my-capabilities] my-IH
end


; a firm's product is computed from its innovation hypothesis, using the capabilities and abilities

to &:make-product
    set my-product $:map-artefact my-IH
end


; the quality of a firm's product is computed from the abilities and expertise in its innovation
; hypothesis: it is the sum (modulo 10) of the product of the abilities and (1 - e to the power of the
; corresponding expertise level)

to &:make-quality
    set my-quality
      (reduce [?1 + ?2]
        (map [(item ? my-abilities) * (1 - exp(0 - (item ? my-expertises)))] my-IH))
          mod 10
end


; the mapping from innovation hypothesis to product number
; the product is the sum (modulo the total number of products) of the product of the
; capabilities and the abilities in the innovation hypothesis
; NO LONGER the product number excludes those used to indicate raw materials or end-user products

to-report $:map-artefact [locations]
    let product-range nProducts
    report
      (reduce [?1 + ?2]
        (map [(item ? my-capabilities) * (item ? my-abilities)] locations)) * product-range
          mod product-range
end


to-report $:map-input [locations]
    let product-range nProducts
    report
      (reduce [?1 + ?2]
        (map [item ? my-capabilities] locations))
          mod product-range
end


; calculate what products a firm needs for its inputs.
; This is done by chopping the innovation hypothesis into sections, one for each input, and
; then mapping the section into a product using the standard mapping function

to &:make-inputs
    let width 0
    let i 0
    let finish 0
    let inputLocations 0
    let input 0

    set my-inputs []
    set width int (length my-IH / my-number-of-inputs)  ; the width of each section of the IH
    set i 0
    repeat my-number-of-inputs [
      ; for each input, copy the section of the IH into inputLocations
      set finish i + width
      set inputLocations []
      while [i < finish] [
        set inputLocations lput (item i my-IH) inputLocations
        set i i + 1
      ]
      ; and map from section to product number
      set input $:map-input inputLocations
      ; check that this does not duplicate an existing input, nor the product
      let dup? false
      foreach my-inputs [
        if ($:near-enough? input ?)
          [ set dup? true ]
      ]
      if ($:near-enough? input my-product)
        [ set dup? true ]
      if (not dup?)
        [ set my-inputs lput input my-inputs ]
    ]
    set my-inputs sort my-inputs
    if (length my-inputs = 0) [
      ; this could leave the firm producing with no inputs which would be a scam, so in this
      ; case require one 'impossible' input, one that is guaranteed that no firm will produce,
      ; so stopping the firm's production
      set my-inputs (list (nProducts + 1))
    ]
    ; stop fims that have only raw-material inputs and make an end-user product - that's cheating!
    if (my-product > nProducts - $:End-products) [
      let raw-inputs-only? true
      foreach my-inputs [
        if (? > $:Raw-materials)
          [ set raw-inputs-only? false ]
      ]
      if (raw-inputs-only?)
        [ set my-inputs (list (nProducts + 1)) ]
    ]
;   print (word "Inputs " my-inputs " Product " my-product)
end


; Calculate the product that will be made, the inputs that will be required and
; the quality of the product.  Adjust my expertise.
; Although these are recalculated each round, the product will not change unless
; the innovation hypothesis has changed. Nor will the inputs required. The
; quality will change if expertises have changed (and normally they will have).

to &:manufacture
    &:make-product
    &:make-inputs
    &:make-quality
    &:adjust-expertise
end



;;;;;;;;;;;;;;;;;
;;;           ;;;
;;;   TAXES   ;;;
;;;           ;;;
;;;;;;;;;;;;;;;;;



to $:pay-taxes
    $:pay-tax $:Depreciation  ; annual depreciation
end


; the money paid just disappears. Later it may be transferred to end-users, to keep it in circulation

to $:pay-tax [amount]
    set my-capital my-capital - amount
end


; If the network has been successful, distribute all the profits of the network
; above the initial capital equally to all the network members
; Alternatively if the network has gone bankrupt, dissolve the network

; network procedure
to $:distribute-network-profits
    if ((length network-members > 0) and ([my-capital] of network-firm > $:Initial-capital-SME)) [
      let amount-to-distribute ([my-capital] of network-firm - $:Initial-capital-SME) / length network-members
      foreach network-members [
;       set [my-capital] of ? [my-capital] of ? + amount-to-distribute TO DO
;       show "distributing " + amount-to-distribute + " to " + [who] of ?
      ]
;     set [my-capital] of network-firm initial-capital-SME TO DO
    ]
    if ([my-capital] of network-firm < 0)
      [ i2:dissolve-network ]
end


; unhook each member from the network and kill both the network agent and the associated firm agent

to i2:dissolve-network
;   foreach network-members
;     [ set [my-I-network] of ? [] ] TO DO
    set __#__dead-ages-net lput [my-age] of network-firm __#__dead-ages-net
    ask network-firm
      [ die ]
    die
end


;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   T-NETWORKS   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



;;; Auftragsforschung (contract research)

; Die Präsenz von wissenschaftlichem Wissen im Institut bildet die Basis für die Durchführung von Auftragsforschung.
; Zur Förderung des Transfers und zur Gewinnung von Aufträgen kann das Institut aktiv die eigene Forschung bekannt
; machen und mögliche Kunden ansprechen. Die geschieht überwiegend über formalisierte Netzwerke oder Cluster, Messe-
; und Veranstaltungsbesuche oder informelle Kontakte. Enabling Innovation setzt hierbei beispielsweise mit den
; Kriterien Zielgruppenkenntnis und Organisation an.

; Der Auftragsforschungsprozess beginnt dann mit der Anfrage eines Unternehmens zur Lösung eines spezifischen
; Anwendungsproblems. Diese Anfrage wird bei Bedarf (# on demand #) institutsintern oder über die Zentrale geprüft, um
; festzustellen, ob das Institut diesen Auftrag ausführen darf und kann. Das Institut bereitet anschließend ein Angebot
; vor. Sofern das Angebot angenommen wird, folgt der Vertragsabschluss zwischen Institut und Wirtschaftspartner (inkl.
; Klärung von rechtlichen Aspekten beim entstandenen Ergebnis). Im Anschluss bearbeitet das Institut das Projekt in
; Zusammenarbeit mit dem Unternehmen. Nach Abschluss des Projekts nimmt das Unternehmen den Auftrag ab und führt die
; Zahlung durch. Durch einen Auftrag können sich ggf. weitere Folgeprojekte ergeben, d.h. zu neuen Anfragen führen und
; den Prozess neu starten. Die Entscheidung, wer die Rechte an dem im Auftrag entwickelten Wissen hat, muss im Vertrag
; geregelt werden. In der Regel bestehen Unternehmen jedoch häufig darauf, dass diese allein bei ihnen liegen. Durch
; Geheimhaltungsvereinbarungen ist darüber hinaus oft auch keine Publikationen der Ergebnisse durch das Institut möglich.

    ; Stage t0 - Institute showcases its research and targets possible clients.
    ;          - Firm requests a solution for a specific application
    ;          - (optional) "Zentrale" determines whether the institute can fulfill the order
    ; Stage t1 - Institute prepares an offer
    ; Stage t2 - Contract in case the offer is accepted (incl. IP rights)
    ; Stage t3 - Institute does the project in collaboration with the firm
    ; Stage t4 - After completion of the project, the firm pays
    ;          - Possible follow-up projects, more requests

; observer procedure
to t:go
    if (not T-Networks?) [ stop ]
    array:set __K__knowledge-flow 2 0

    ifelse (Empirical-case?) [
      ; Empirical case
    ] [
      ; Simulation
      r1:publish-calls "tto"
      __L__log-calls "tto"
      ask participants [
        t1:initiate-proposals  ; overriding
        t1:find-partners  ; overriding
        r1:submit-proposals
      ]
      __L__log-proposals "tto"

      r2:close-calls "tto"
      r2:evaluate-calls
      __L__log-evaluation
      r2:dissolve-proposals
      __L__log-projects "tto"

      ask projects [
        r3:start-project
        r3:learn-from-partners
        r3:do-research
        r3:make-deliverables
        r3:finish-project
      ]
      r3:adjust-expertise-levels
      r3:dissolve-projects
    ]
end


;;; PROPOSALS & RESEARCH CONSORTIA
;;;
;;; initiate proposals, invite partners, formulate and submit proposals


; Initiate proposals
; ------------------

; the TTO itself initiates all the proposals for its call

; participant procedure
to t1:initiate-proposals
    if (my-type = "tto") [
      ; TO DO: should be the TTO's own call, not some other TTO's
      let the-call one-of calls with [(call-type = "tto") and (call-status = "open")]
      if (the-call != nobody)
        [ t1:initiate-proposal the-call ]
    ]
end


; if enough room initiate one proposal

; participant procedure
to t1:initiate-proposal [the-call]
    let log? __L__log? and __L__log-r?
    let n 1
    repeat n [
      ifelse r1:room-for-another-proposal? [
        let relevant-capabilities _intersection my-capabilities [call-capabilities] of the-call
        if (not empty? relevant-capabilities) [
          let the-new-proposal r1:make-proposal
          if (log?) [
            type (word "I am participant " my-pnr " (" my-type ") (in " count my-proposals " proposals). ")
            print (word "I am initiating a new proposal " [proposal-nr] of the-new-proposal ".")
          ]
          set my-proposals (turtle-set my-proposals the-new-proposal)
          ask the-new-proposal [
            set proposal-type [call-type] of the-call
            set proposal-call [call-id]   of the-call
            set proposal-coordinator myself
            _notify-changed-status
          ]
          r1:join the-new-proposal
        ]
      ]
      [ if (log?) [ print (word "I have no 'room' for initiating a new proposal.") print "" ] ]
    ]
end


; Partner Search
; --------------

; the TTO searches candidate partners for the proposals SME, and selects the best candidate

; participant procedure
to t1:find-partners
    foreach [self] of my-proposals with [proposal-status = "initiated" and proposal-coordinator = myself]
      [ t1:find-possible-partners ? ]
end


; participant procedure
to t1:find-possible-partners [the-proposal]
    let log? __L__log? and __L__log-r?
    if (log?) [
      type (word "I am participant " my-pnr " (" my-type "). ")
      type (word "I am coordinator of proposal " [proposal-nr] of the-proposal ". ")
      print "I am searching possible partners for this proposal."
    ]

    let nr 0
    let possible-partners []
    let declined []  ; if declined, do not ask again

    if (r1:Invite-previous-partners-first?) [
      ; 1st iteration - search previous partners
      set possible-partners [self] of my-previous-R-partners ; of the coordinator
      ; the search
      set nr 0
      while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
        let a-possible-partner one-of possible-partners
        ask a-possible-partner [ r1:join the-proposal ]
        set possible-partners remove a-possible-partner possible-partners
        if (not member? a-possible-partner [proposal-consortium] of the-proposal)
          [ set declined lput a-possible-partner declined ]
        set nr nr + 1
      ]

      ; 2nd iteration - previous partners can add their previous partners
      let previous-partners no-turtles
      ask my-previous-R-partners [ set previous-partners (turtle-set previous-partners my-previous-R-partners) ]
      set possible-partners [self] of previous-partners with [not member? self [proposal-consortium] of the-proposal]
      set possible-partners _set-difference declined possible-partners
      ; the search (same as above)
      set nr 0
      while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
        let a-possible-partner one-of possible-partners
        ask a-possible-partner [ r1:join the-proposal ]
        set possible-partners remove a-possible-partner possible-partners
        if (not member? a-possible-partner [proposal-consortium] of the-proposal)
          [ set declined lput a-possible-partner declined ]
        set nr nr + 1
      ]
    ]

    ; 3rd iteration - search new partners
    set possible-partners [self] of participants with [not member? self [proposal-consortium] of the-proposal]
    set possible-partners _set-difference declined possible-partners
    ; the search (same as above)
    set nr 0
    while [(not r2:eligible? the-proposal) and (length possible-partners > 0) and (nr < r1:Search-depth)] [
      let a-possible-partner one-of possible-partners
      ask a-possible-partner [ r1:join the-proposal ]
      set possible-partners remove a-possible-partner possible-partners
      if (not member? a-possible-partner [proposal-consortium] of the-proposal)
        [ set declined lput a-possible-partner declined ]
      set nr nr + 1
    ]
end



;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   E-NETWORKS   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



; Entrepreneurial programmes are similar to research instruments. There are participants, calls, proposals, projects
; and project outputs. They are therefore modelled using the same breeds of agents.
;
; Differences include:
; - E-project deliverables include support of new business start-ups. Publications and patents are not deliverables.
; - Some types of E-support are valuation of IP, start-up visibility and business incubation.
; - Valuation of IP results in a better estimate of value of the IP of the start-up.
; - Visibility results in better opportunities for participation in networks and selling products.
; - Business incubation results in an start-up development phase with lower survival threshold.

;;; Ausgründung (spin-off)

; Unternehmensausgründungen oder auch Spin-offs stellen eine wichtige Form des Wissens- und Technologietransfers von
; Forschungseinrichtungen in die Wirtschaft dar. Allgemein handelt es sich bei Spin-offs um neue Unternehmen, die von
; früheren Mitarbeitern einer Forschungseinrichtung aus dieser heraus gegründet werden. Dabei werden die Ergebnisse aus
; Forschung und Entwicklung über implizites Knowhow oder mit Hilfe von Patenten und Lizenzvereinbarungen auf den Markt
; gebracht.

; Die Basis für eine Ausgründung stellt in der Regel eine Idee eines oder mehrerer Mitarbeiter eines Instituts, wie das
; wissenschaftliche Knowhow außerhalb des Instituts genutzt werden kann, dar. Sofern diese Idee ein hohes Erfolgspotenzial
; aufweist und keine Alternative zur Ausgründung besteht, entwickelt das Institut einen Businessplan. Danach wird
; entschieden, ob eine Ausgründung erfolgen soll. Sofern für die Ausgründung spezifisches, geschütztes Know-How des
; Instituts notwendig ist, wird dieses lizensiert. Durch eine anhaltende Beteiligung des Instituts (die jedoch nicht die
; Regel, sondern eher die Ausnahme darstelle) am neu gegründeten Unternehmen oder dessen Verkauf kann das Institut
; finanzielle Mittel generieren. Darüber hinaus können Erträge für das Institut ggf. auch darüber generiert werden, dass
; ein ausgegründetes Unternehmen – analog zu Unternehmen – Aufträge an das „Mutterinstitut“ vergibt oder in Kooperations-
; projekten beteiligt ist. Ein großer Nachteil von Ausgründungen, der auch in der Enabling Innovation-Workshops häufig
; genannt wurde, liegt darin, dass gut ausgebildete Mitarbeiter durch die Gründung das Institut verlassen. Hierdurch ist
; es für Institute nicht immer besonders erstrebenswert, Ausgründungen auch aktiv zu fördern. Enabling Innovation kann
; Ausgründungen & Beteiligungen insbesondere dadurch beeinflussen, dass Strukturen im Institut geschaffen werden, um
; Ausgründungen zu fördern. Dies kann gegebenenfalls auch in Zusammenarbeit und mit Unterstützung von spezialisierten
; externen Mittlern erfolgen.

    ; Stage t0 - Workers of the institute have an idea how to use know-how outside of the institute
    ;          - External intermediaries may support the process
    ; Stage t1 - If high potential, and no alternatives to spin-off, the Institute develops a business plan
    ;          - Search collaboration partners, investors
    ;          - If IP needs to be protected, it is licensed
    ; Stage t2 - Business plan good enough? IP well enough protected? etc.
    ;          - (optional) Institute decides to participate in the spin-off (in order to generate revenues)
    ; Stage t3 - Spin-off
    ; Stage t4 - Institute may get orders through the spin-off
    ;          - Workers may leave the Institute
    ;          - Shares may be sold

; observer procedure
to e:go
    if (not E-Networks?) [ stop ]
    array:set __K__knowledge-flow 3 0

    ; two possibilities:

    ; 1) start-ups are clones of the most successful firm (SEIN)
    ; stage e1 - ...
    ; stage e2 - ...

    ; 2) high potential start-ups (IPSE)
    ; stage e1 - ...
    ; stage e2 - ...
    ; stage e3 - ...

    ifelse (Empirical-case?) [
      ; Empirical case
    ] [
      ; Simulation
      ask entrepreneurs [
        e:start-up
      ]
    ]
end


;;; PROPOSALS & RESEARCH CONSORTIA
;;;
;;; initiate proposals, invite partners, formulate and submit proposals


; innovation potential is computed based on the distances between adverts of firms

; observer procedure
to-report e:innovation-potential [the-advert]
    ; TO DO: normalize against the average distance
    report min [_distance the-advert my-advert] of firms with [my-type != "sup"]
end


; sales potential is computed based on the history of potential/actual sales

; observer procedure
to-report e:sales-potential [the-potential-sales the-sales]
    ; normalized against the average sales
    let avg-sales mean [my-sales] of firms with [my-type != "sup"]
    if (avg-sales > 0)
      [ report (the-potential-sales + the-sales) / avg-sales ]
    report "N/A"
end


;;; START-UPS
;;;
;;; find partners to collaborate with and form partnerships

; The probability p of start-up is proportional to the uniqueness and value of the entrepreneur's
; intellectual property, expressed in the entrepreneur's innovation hypothesis IH.
;
; The probability is calculated as the p = β ⋅ V, where β is is a “birth” parameter and V is the
; updated estimated value of the entrepreneur's IH.
;
; β measures how sensitive is the entrepreneur’s probability of starting up a new business to her
; updated valuation of her IH against the evolving IHs of existing firms. For model calibration, we
; will investigate different values of β in the simulations that follow.
;
; Entrepreneurs update rather than completely determine their evaluations of the value of their IH
; using new information they get at tick t, using a simple model.
; V(i, t) = α ⋅ V(i, t-1) + (1 – α) ⋅ v(i, t)
;
; The memory parameter α determines the extent to which entrepreneurs update their (previously
; updated) value of their IH at tick t-1, using information at tick t, expressed in the equation as
; v(i, t)
;
; One simple piece of information that is used by entrepreneurs is the uniqueness of their IH,
; which can be measured by the distance between their IH and the current instantaneous IHs of their
; closest competitors (the existing firms carrying the most similar IH adverts).
;
; Another simple piece of information is the perceived value of the capabilities from their IH,
; which can be related to the rarity of capabilities.

; entrepreneur procedure
to e:start-up
    if (my-start-up = nobody) [
      let minD min [_distance [my-advert] of myself my-advert] of firms with [my-type != "sup"]
;     print (word "The distance to my closest competitor is " minD)
      let p s:Birth * minD
      if (random-float 1 < p) [
        let the-new-company e:make-start-up
        ; consider it a high potential start-up depending on distance
        if (minD >= 5)
          [ ask the-new-company [ set high-potential? true ] ]
        if (__L__log-debug?) [ print (word "I am starting up a new company " [my-firm-nr] of the-new-company ".") ]
;       print _list-as-string my-advert
;       print _list-as-string [my-advert] of the-new-company
      ]
    ]
end


; entrepreneur procedure
to-report e:make-start-up
    let the-start-up nobody
    hatch-firms 1 [
      set the-start-up self
      set my-firm-nr __#__highest-firm-nr + 1
      set __#__highest-firm-nr my-firm-nr
      set my-pnr __#__highest-pnr + 1
      set __#__highest-pnr my-pnr
      set my-type "sup"
      set my-capital $:Initial-capital-SME
      set my-age 0
      table:put firms-dict my-firm-nr self
      hide-turtle
    ]
    set my-start-up the-start-up
    ask the-start-up [
      #:initialise
      #:initialise-firm
      set my-founder myself
;     set hpsu?
      &:clone-kene-and-IH myself
;     set my-status "start-up"
    ]
    report the-start-up
end


; firm procedure
to &:clone-kene-and-IH [who-to-clone]
    ; clone the kene
    let location 0
    while [location < length [my-capabilities] of who-to-clone] [
      set my-capabilities lput (item location [my-capabilities] of who-to-clone) my-capabilities
      set my-abilities    lput (item location [my-abilities] of    who-to-clone) my-abilities
      set my-expertises   lput (item location [my-expertises] of   who-to-clone) my-expertises
      set my-orientations lput (item location [my-orientations] of who-to-clone) my-orientations
      set location location + 1
    ]
    ; clone the IH
    let pos 0
    while [pos < length [my-IH] of who-to-clone] [
      set my-IH lput (item pos [my-IH] of who-to-clone) my-IH
      set pos pos + 1
    ]
    &:make-advert
    &:manufacture  ; not strictly necessary, but sets the initial product
end


; Firms and institutes participate in research and innovation networks through strategic projects
; receiving national or EU funding. Irish examples are CSETs or CCs. European examples are the funding
; instruments of FP7 and Horizon 2020.
;
; Conform the INFSO model, R/I networks are initiated by universities after which other institutes and
; firms (including SMEs and possibly start-ups) are invited to join.


; Entrepreneurs and SMEs participate in entrepreneurial networks if they consider the services valuable -
; otherwise they prefer to stay below the radar.
;
; E networks are initiated by intermediary organisations such as InterTradIreland


; Firms exit if their fitness falls below some de facto survival threshold.

; A firm with an updated fitness that is below the survival threshold is not necessarily non-existent,
; but is invisible below the radar to all other agents.

; start-ups are clones of the most successful firm, modified in two ways:
; they get only the standard starting capital
; they get their kene trimmed to the length appropriate to their capital
; create 1, or if the most successful firm was very successful, more

to e:create-clone-start-ups
    if (not Start-ups?) [ stop ]
    if (count firms = 0) [ stop ]
    let biggest-reward [my-last-reward] of max-one-of firms [ my-last-reward ]
    if (biggest-reward > Reward-to-trigger-start-up)
       [ repeat log biggest-reward 10 [ e:make-clone-start-up ] ]
end


; clone the firm with the largest reward

to e:make-clone-start-up
    create-firms 1 [
      set my-capital $:Initial-capital-SME
      set firm-id __#__current-max-firm-id  ; the firm gets the first, never used, free firm id
      set __#__current-max-firm-id __#__current-max-firm-id + 1  ; increment for the current-max-firm-id
      #:initialise-firm
      &:clone-kene max-one-of firms with [ self != myself ] [ my-last-reward ]
      &:make-IH
      &:make-advert
      &:manufacture
    ]
end


; cloning a kene involves copying the triples in its innovation hypothesis,
; but chopping it to a length suitable for the capital of the firm receiving it

to &:clone-kene [firm-to-clone]
    let IH-pos 0
    let triple-pos 0
    repeat min list (length [my-IH] of firm-to-clone) (ln ((my-capital / $:Capital-knowledge-ratio) + 1) + 1) [
      set triple-pos item IH-pos [my-IH] of firm-to-clone
      set my-capabilities lput (item triple-pos [my-capabilities] of firm-to-clone) my-capabilities
      set my-abilities    lput (item triple-pos [my-abilities]    of firm-to-clone) my-abilities
      set my-expertises   lput (item triple-pos [my-expertises]   of firm-to-clone) my-expertises
      set my-orientations lput (item triple-pos [my-orientations] of firm-to-clone) my-orientations
      set IH-pos IH-pos + 1
    ]
end



;;;;;;;;;;;;;;;;;;;;;;;;
;;                   ;;;
;;;   TRANSACTIONS   ;;;
;;;                  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;



;                       firm procedures called       variables set
;                       ----------------------       --------------
; find-suppliers        identify-suppliers           selling?
; buy                   find-best-supplier           buying?, my-suppliers, my-total-cost, my-price
;                       purchase                     my-capital, my-Customers, nCustomers, my-sales
; sell-to-end-users
; take-profit                                        my-last-reward
; adjust-price                                       my-markup

; observer procedure
to $:go
    if (not Transactions?) [ stop ]
    print "go Transactions"

    ; Repeat the same procedure twice
    ; First, start-ups are included for 'proto stage' testing
    ; Then start-ups are excluded

    foreach [true false] [
      $:initialise ?
      $:find-suppliers ?
      $:buy ?
      $:sell-to-end-users ?
      if (? = false) [
        ask firms [
          $:take-profit
          $:adjust-price
        ]
      ]
    ]
    __L__log-transactions
end


;;; MARKET LEVEL
;;;
;;; find suppliers for each input, put on market, try to sell product and collect money


to $:initialise [test?]
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    ask firms with [my-type != x] [
      set my-customers []
      set my-nCustomers 0
      set my-sales 0
      if (test? and (my-type = "sup")) [
        set my-potential-customers []
        set my-potential-nCustomers 0
        set my-potential-sales 0
      ]
    ]
end


; A firm doesn't know whether its input can be supplied. Even if it finds a potential supplier,
; that supplier may not be able to produce because it can't find a supplier for its inputs!
; Hence, we first mark all firms as possible producers, and then eliminate those that
; cannot actually produce, because no-one is offering the required inputs and so on
; recursively, until there is no further change and all firms have been classified as either
; potentially able to supply or definitely not (selling? is true or false respectively).

; What happens is that first any firm that only uses raw materials as its inputs is marked
; as 'selling'. Then in a second scan, any firm that uses only raw materials or the products
; produced by firms that are selling are marked as selling. Then on a third scan, the same
; is done, and so on until no more firms are marked as selling. All remaining firms cannot
; produce because no firm produces one or more of their inputs.


; observer procedure
to $:find-suppliers [test?]
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    ask firms with [my-type != x]
      [ set selling? "possible" ]
    let i 0
    let changed? true
    while [changed?] [
      print (word "*** " test? " *** Finding suppliers. Scan " i)
      set changed? false
      ask firms with [(my-type != x) and (selling? = "possible")] [
        $:identify-suppliers test?
        if (not (selling? = "possible"))
          [ set changed? true ]
      ]
      if (not changed?)
        [ print (word "*** " test? " *** Nothing changed in this scan.") ]
      set i i + 1
    ]
    print (word "*** " test? " *** Number of firms selling " (count firms with [(my-type != x) and (selling? = true)]))
end


;; Check whether any firm is offering my required inputs.
;; If not, I definitely cannot produce and sell.
;; Then check whether there are any firms that are selling each input. If not, I can't sell.
;; Then check whether there are firms definitely selling all my inputs. If so, I can sell.
;; Note that raw materials are always available.

; firm procedure
to $:identify-suppliers [test?]
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    let any-near-enough? false
    let ok 0
    foreach my-inputs [
      set any-near-enough? any? firms with [(my-type != x) and
          ($:near-enough? my-product ?)]
      if ((? >= $:Raw-materials) and not (any-near-enough?)) [
        set selling? false
        stop
      ]
    ]
;   print "maybe I can sell"
    foreach my-inputs [
      ;print (word "identifying suppliers for input " ?)
      ifelse (? >= $:Raw-materials)
        [
          set any-near-enough? any? firms with [(my-type != x) and
              ($:near-enough? my-product ?) and not (selling? = false)]
          if (not any-near-enough?) [
            set selling? false
            stop
          ]
;         print "there is still hope..."
          set any-near-enough? any? firms with [(my-type != x) and
              ($:near-enough? my-product ?) and (selling? = true)]
          if (any-near-enough?) [
            set ok ok + 1
;           print (word "ok = " ok)
          ]
        ]
        [ set ok ok + 1 ]
    ]
    if (ok = length my-inputs) [
      set selling? true
      print (word "Ok. All my inputs " my-inputs " for my product " (round (10 * my-product) / 10) " are on offer!")
      stop
    ]
end


;; report true if the product, prod, is near enough in value to inp to be acceptable for use as the input

to-report $:near-enough? [prod inp]
    report abs (prod - inp) < $:Delta
end


;; same story as find-suppliers, but in addition suppliers have to be selling

to $:buy [test?]
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    ask firms with [my-type != x] [
      ifelse (selling? = true)
        [ set buying? "possible" ]
        [ set buying? false ]
    ]
    let i 0
    let changed? true
    while [changed?] [
      print (word "*** " test? " *** Finding the best suppliers that are selling. Scan " i)
      set changed? false
      ask firms with [(my-type != x) and (buying? = "possible")] [
        $:find-best-supplier test?
        if (not (buying? = "possible"))
          [ set changed? true ]
      ]
      if (not changed?)
        [ print (word "*** " test? " *** Nothing changed in this scan.") ]
      set i i + 1
    ]
    print (word "*** " test? " *** Number of firms buying " (count firms with [(my-type != x) and (buying? = true)]))
    ask firms with [(my-type != x) and (buying? = true)]
      [ $:purchase test? ]
end


;; find the best supplier for each of my inputs. If there is more than one offering
;; the cheapest price, choose the one offering the product with the highest quality.
;; Sets the supliers variable with a list of supplier firms, and total-cost with the
;; sum of the prices of the inputs. If no suitable supplier can be found, or the
;; total-cost is greater than my proposed selling price, set buying? to false, meaning
;; that I won't be producing for the market

to $:find-best-supplier [test?]
;   print "find best supplier"
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    let any-near-enough? false
    let ok 0
    set my-total-cost 0
    set my-suppliers []
;   print (word "I am finding best suppliers for each of my inputs " my-inputs)
    foreach my-inputs [
      let supplier nobody
      ifelse (? >= $:Raw-materials) [
        ; if there are no firms selling this input that are or might be in production, I can't produce
        set any-near-enough? any? firms with [(my-type != x) and
            ($:near-enough? my-product ?) and (selling? = true) and not (buying? = false)]
        if (not any-near-enough?) [
          set buying? false
          stop
        ]
        ; if there are any firms that are definitely making the input, find the cheapest and use that one
        set any-near-enough? any? firms with [(my-type != x) and
            ($:near-enough? my-product ?) and (buying? = true)]
        if (any-near-enough?) [
          set ok ok + 1
          let possible-suppliers []
          set possible-suppliers firms with [(my-type != x) and
              ($:near-enough? my-product ?) and (buying? = true)]
          set supplier min-one-of possible-suppliers [my-price * abs (my-product - ?)]
          if (supplier != nobody) [
            set my-total-cost my-total-cost + [my-price] of supplier
;           print (word "I have found the cheapest supplier of input " ?
;               ". The price of the product " (round (10 * [my-product] of supplier) / 10)
;               " is " (round (10 * [my-price] of supplier) / 10))
          ]
        ]
      ] [
        ; raw materials are always available
        set my-total-cost my-total-cost + $:raw-cost
        set ok ok + 1
        set supplier "raw-material"
;       print (word "Raw materials " ? " are always available at cost " M:raw-cost)
      ]
      set my-suppliers lput supplier my-suppliers
    ]
    if (ok = length my-inputs) [
      ; all inputs are available, use cost-plus pricing
      set buying? true
;     set my-price (my-total-cost + random $:Max-price) * (1 + my-markup / 100)
      set my-price my-total-cost * (1 + my-markup)
;     print (word "All inputs are available so I am buying. My total cost is "
;         (round (10 * my-total-cost) / 10) ". I set my price at " (round (10 * my-price) / 10))
    ]
end


;; after all that, actually purchase the inputs from my selected suppliers,
;; reducing my available capital and incrementing the number of customers and
;; and sales total of each of the suppliers

to $:purchase [test?]
    ifelse (test?) [
      ; testing - store potential purchases from start-up suppliers
      foreach my-suppliers [
        if ((? != "raw-material") and ([my-type] of ? = "sup")) [
          ask ? [
            set my-potential-customers lput myself my-potential-customers
            set my-potential-nCustomers my-potential-nCustomers + 1
            set my-potential-sales my-potential-sales + my-price
          ]
        ]
      ]
    ] [
      ; not testing - actually purchase the inputs
      foreach my-suppliers [
        ifelse (? = "raw-material") [
          set my-capital my-capital - $:raw-cost
        ] [
          set my-capital my-capital - [my-price] of ?
          ask ? [
            set my-capital my-capital + my-price
            set my-customers lput myself my-customers
            set my-nCustomers my-nCustomers + 1
            set my-sales my-sales + my-price
          ]
        ]
      ]
    ]
end


; if the firm is producing a consumer product, and the price is right, sell it to the end user

to $:sell-to-end-users [test?]
    let x ""
    if (not test?) [ set x "sup" ]  ; exclude start-ups if not testing
    ask firms with [(my-type != x) and
        (buying? = true) and (my-product > nProducts - $:End-products) and (my-price <= $:final-price)] [
      ifelse (test?) [
        if (my-type = "sup") [
          set my-potential-sales my-potential-sales + my-price
          set my-potential-nCustomers my-potential-nCustomers + 1
;         print (word "Potentially selling " my-product " to end-user at a price of " my-price)
        ]
      ] [
        set my-capital my-capital + my-price
        set my-sales my-sales + my-price
        set my-nCustomers my-nCustomers + 1
;       print (word "Selling " my-product " to end-user at a price of " my-price)
      ]
    ]
end



;;;;;;;;;;;;;;;;;;;;;;;;
;;                   ;;;
;;;   PROFIT & TAX   ;;;
;;;                  ;;;
;;;;;;;;;;;;;;;;;;;;;;;;



; calculate the profit I have made from selling my product

to $:take-profit
    set my-last-reward 0
    if ((my-nCustomers > 0) and (my-price > my-total-cost))
      [ set my-last-reward my-nCustomers * (my-price - my-total-cost) ]
end


; adjust the price of my product to respond to market conditions:
; If in the last round I sold a product, increase the price by 10% for every customer
; If there were no buyers, reduce the price by 10%
; If I did not manage to make a product, because one or more inputs were missing, do nothing

to $:adjust-price
    if (not Adj-price?) [ stop ]
    if (buying? = true) [
      ifelse (my-nCustomers > 0)
        [ set my-markup my-markup + 1 ]
        [ set my-markup my-markup - 1 ]
    ]
end


to __L__log-transactions
    print (word "firm-nr|firm-type|selling?|buying?|"
        "product|inputs|suppliers|cost|markup|price|"
        "(potential) customers|nCustomers|"
        "(potential) sales|")

    foreach n-values (count firms) [?] [
      let nr (? + 1)
      let the-firm table:get firms-dict nr
      let s [my-firm-nr] of the-firm

      ; type of firm
      set s (word s "|" ([my-type] of the-firm))                          ; = ldf, sme or sup

      ; selling? buying?
      set s (word s "|" ([selling?] of the-firm))                         ; = true, possible or false
      set s (word s "|" ([buying?] of the-firm))                          ; = true, possible or false

      ; product, inputs
      set s (word s "|" (round (10 * [my-product] of the-firm) / 10))     ; e.g. 55.5
      set s (word s "|" ([my-inputs] of the-firm))                        ; e.g. [4 22 48]

      ; suppliers
      ifelse (not empty? [my-suppliers] of the-firm)
        [
          let location 0
          let ss "["
          while [location < length [my-suppliers] of the-firm] [
            let the-supplier (item location [my-suppliers] of the-firm)
            ifelse (the-supplier != "raw-material")
              [ set ss (word ss ([my-firm-nr] of the-supplier) " ") ]
              [ set ss (word ss "raw-material ") ]
            set location location + 1
          ]
          set s (word s "|" replace-item (length ss - 1) ss "]")
        ]
        [ set s (word s "|[]") ]

      ; cost, markup, price
      set s (word s "|" (round (10 * [my-total-cost] of the-firm) / 10))
      set s (word s "|" (round (10 * [my-markup]     of the-firm) / 10))
      set s (word s "|" (round (10 * [my-price]      of the-firm) / 10))

      ; (potential) customers, (potential) sales
      ifelse ([my-type] of the-firm = "sup") [
        ifelse (not empty? [my-suppliers] of the-firm)
          [
            let location 0
            let ss "["
            while [location < length [my-potential-customers] of the-firm] [
              let the-potential-customer (item location [my-potential-customers] of the-firm)
              set ss (word ss ([my-firm-nr] of the-potential-customer) " ")
              set location location + 1
            ]
            set s (word s "|" replace-item (length ss - 1) ss "]")
          ]
          [ set s (word s "|[]") ]
        set s (word s "|" ([my-potential-nCustomers] of the-firm))
        set s (word s "|" (round (10 * [my-potential-sales] of the-firm) / 10))
      ] [
        ifelse (not empty? [my-suppliers] of the-firm)
          [
            let location 0
            let ss "["
            while [location < length [my-customers] of the-firm] [
              let the-customer (item location [my-customers] of the-firm)
              set ss (word ss ([my-firm-nr] of the-customer) " ")
              set location location + 1
            ]
            set s (word s "|" replace-item (length ss - 1) ss "]")
          ]
          [ set s (word s "|[]") ]
        set s (word s "|" ([my-nCustomers] of the-firm))
        set s (word s "|" (round (10 * [my-sales] of the-firm) / 10))
      ]

      print s
    ]
end



;;;;;;;;;;;;;;;;;;;;;;
;;;                ;;;
;;;   VALUATIONS   ;;;
;;;                ;;;
;;;;;;;;;;;;;;;;;;;;;;



; observer procedure
to v:go
    if (not Valuations?) [ stop ]
    ask institutes [ v:compute-scores ]
end


; update the institute's SCI/EI scores

; institute procedure
to v:compute-scores
    v:compute-SCI-scores       self
    v:compute-SCI-total-scores self
    v:compute-EI-scores        self
    v:compute-EI-total-scores  self
    v:compute-total-score      self
end


; Just as new firms may be born, existing firms may “die”. Firm death occurs when firm fitness falls
; below some de facto survival threshold that is a feature of the general market environment.
;
; The updating algorithm is directly analogous to the algorithm we specified for entrepreneurs updating
; their IH value.
; F(i, t) = α ⋅ F(i, t-1) + (1 – α) ⋅ f(i, t)
;
; The memory parameter α determines the extent to which firms update their (previously updated) fitness
; at tick t-1, using information at tick t, expressed in the equation as f(i, t)
;
; The information that is used by firms is their market share.

; firm procedure
; to v:update-fitness
;
; end



;;;;;;;;;;;;;;;;;
;;;           ;;;
;;;   ADMIN   ;;;
;;;           ;;;
;;;;;;;;;;;;;;;;;



; some final tidying up at the end of every round

; firm procedure
to #:do-admin
    ; dissolve this round's partnerships, but remember the partners for the future
;   set my-previous-I-partners remove-duplicates sentence my-previous-I-partners my-I-partners

    set my-age my-age + 1

;   if (member? self :the-firms) [
;     set :total-age-of-the-firms :total-age-of-the-firms + 1
;     if (my-last-reward > M:Success-threshold)
;       [ set :successes-of-the-firms :successes-of-the-firms + 1 ]
;   ]
    ; die if bankrupt
;   if (my-capital < 0)
;     [ #:exit ]
end


; remove myself from the simulation, making sure that I am no longer a member of any network etc.

; firm procedure
to #:exit
    set __#__dead-ages lput my-age __#__dead-ages
    ; remove the firm from its network (if any)
    ; if the network has zero or one members, also kill the network
    if ((is-agent? my-I-network) and (my-I-network != nobody)) [
;     set [network-members] of my-I-network remove self [network-members] of my-I-network TO DO
      if ((length [network-members] of my-I-network <= 1) or network-firm?) [
        ask my-I-network
          [ i2:dissolve-network ]
      ]
    ]
    die
end



;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                   ;;;
;;;   SCI/EI SCORES   ;;;
;;;                   ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;



;;; SCI SCORES
;;;

; observer procedure
to v:compute-SCI-total-scores [the-institute]
    ask the-institute [
      ifelse (table:has-key? organisations-dict my-org-type)
        [
          let the-org-type table:get organisations-dict my-org-type
          ; total SCI capacity score
          set SCI-total-score-C [SCI-weight-C1] of the-org-type * SCI-score-C1 +
                                [SCI-weight-C2] of the-org-type * SCI-score-C2 +
                                [SCI-weight-C3] of the-org-type * SCI-score-C3
          ; total SCI performance score
          set SCI-total-score-P [SCI-weight-P1] of the-org-type * SCI-score-P1 +
                                [SCI-weight-P2] of the-org-type * SCI-score-P2 +
                                [SCI-weight-P3] of the-org-type * SCI-score-P3
        ]
        [
          set SCI-total-score-C 0.333 * SCI-score-C1 + 0.333 * SCI-score-C2 + 0.333 * SCI-score-C3
          set SCI-total-score-P 0.333 * SCI-score-P1 + 0.333 * SCI-score-P2 + 0.333 * SCI-score-P3
        ]
    ]
end


; observer procedure
to v:compute-SCI-scores [the-institute]
    ask the-institute [
      ; SCI score C1 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      let n1 25
      let n2 50
      if (false)
        [ show "Invalid SCI score (C1)"  report 0 ]
      set SCI-score-C1 100 * min (list 1 (n1 / n2))

      ; SCI score C2 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid SCI score (C2)"  report 0 ]
      set SCI-score-C2 100 * min (list 1 (n1 / n2))

      ; SCI score C3 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid SCI score (C3)"  report 0 ]
      set SCI-score-C3 100 * min (list 1 (n1 / n2))

      ; SCI score P1 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid SCI score (P1)"  report 0 ]
      set SCI-score-P1 100 * min (list 1 (n1 / n2))

      ; SCI score P2 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid SCI score (P2)"  report 0 ]
      set SCI-score-P2 100 * min (list 1 (n1 / n2))

      ; SCI score P3 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid SCI score (P3)"  report 0 ]
      set SCI-score-P3 100 * min (list 1 (n1 / n2))
    ]
end


;;; EI SCORES
;;;

; observer procedure
to v:compute-EI-total-scores [the-institute]
    ask the-institute [
      ifelse (table:has-key? organisations-dict my-org-type)
        [
          let the-org-type table:get organisations-dict my-org-type
          ; total EI capacity score
          set EI-total-score-C [EI-weight-C1] of the-org-type * EI-score-C1 +
                               [EI-weight-C2] of the-org-type * EI-score-C2 +
                               [EI-weight-C3] of the-org-type * EI-score-C3
          ; total EI performance score
          set EI-total-score-P [EI-weight-P1] of the-org-type * EI-score-P1 +
                               [EI-weight-P2] of the-org-type * EI-score-P2 +
                               [EI-weight-P3] of the-org-type * EI-score-P3
        ]
        [
          set EI-total-score-C 0.333 * EI-score-C1 + 0.333 * EI-score-C2 + 0.333 * EI-score-C3
          set EI-total-score-P 0.333 * EI-score-P1 + 0.333 * EI-score-P2 + 0.333 * EI-score-P3
        ]
    ]
end


; observer procedure
to v:compute-EI-scores [the-institute]
    ask the-institute [
      ; EI score C1 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      let n1 25
      let n2 50
      if (false)
        [ show "Invalid EI score (C1)"  report 0 ]
      set EI-score-C1 100 * min (list 1 (n1 / n2))

      ; SCI score C2 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid EI score (C2)"  report 0 ]
      set EI-score-C2 100 * min (list 1 (n1 / n2))

      ; SCI score C3 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid EI score (C3)"  report 0 ]
      set EI-score-C3 100 * min (list 1 (n1 / n2))

      ; SCI score P1 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid EI score (P1)"  report 0 ]
      set EI-score-P1 100 * min (list 1 (n1 / n2))

      ; SCI score P2 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid EI score (P2)"  report 0 ]
      set EI-score-P2 100 * min (list 1 (n1 / n2))

      ; SCI score P3 is the ratio of
      ; 1) the number of ..., to
      ; 2) the number of ...
      if (false)
        [ show "Invalid EI score (P3)"  report 0 ]
      set EI-score-P3 100 * min (list 1 (n1 / n2))
    ]
end


;;; TOTAL SCI/EI SCORE

; compute the total weighted SCI/EI capacity/performance score

; observer procedure
to v:compute-total-score [the-institute]
    ask the-institute [
      ifelse (table:has-key? organisations-dict my-org-type)
        [
          let the-org-type table:get organisations-dict my-org-type
          set total-score [SCI-weight-C] of the-org-type * SCI-total-score-C +
                          [SCI-weight-P] of the-org-type * SCI-total-score-P +
                          [EI-weight-C]  of the-org-type * EI-total-score-C  +
                          [EI-weight-P]  of the-org-type * EI-total-score-P
        ]
        [
          set total-score 0.25 * SCI-total-score-C + 0.25 * SCI-total-score-P +
                          0.25 * EI-total-score-C  + 0.25 * EI-total-score-P
        ]
    ]
end



;;;;;;;;;;;;;;;;;;;
;;;             ;;;
;;;   UTILITY   ;;;
;;;             ;;;
;;;;;;;;;;;;;;;;;;;



to-report _frequency [val the-list]
    report length filter [? = val] the-list
end


; reports the set intersection of the lists a and b, treated as sets

to-report _intersection [set-a set-b]
    let set-c []
    foreach set-a [ if (member? ? set-b) [ set set-c lput ? set-c ] ]
    report set-c
end


; reports the set difference of lists a and b, treated as sets

to-report _set-difference [set-a set-b]
    let set-c _intersection set-a set-b
    set set-b remove-duplicates (sentence set-a set-b)
    foreach set-c [ if (member? ? set-b) [ set set-b remove ? set-b ] ]
    report set-b
end


; reports a random integer greater than or equal to the low-number,
; but stricly less than the high-number

to-report _random-between [low-number high-number]
    report low-number + random (high-number - low-number)
end


; reports the distance between lists a and b, treated as sets

to-report _distance [list-a list-b]
    report length _set-difference list-a list-b
end


; reports the edit distance (Levenshtein distance) between two lists

to-report _edit-distance [list-a list-b]
    set list-a sort remove-duplicates list-a
    set list-b sort remove-duplicates list-b
    let m length list-a
    let n length list-b
;   print (word " " m " " n " ")
    let d matrix:make-constant (m + 1) (n + 1) 0
    foreach n-values m [?] [
      let i (? + 1)
      matrix:set d i 0 i
    ]
    foreach n-values n [?] [
      let j (? + 1)
      matrix:set d 0 j j
    ]
    foreach n-values n [?] [
      let j (? + 1)
      foreach n-values m [?] [
        let i (? + 1)
        ifelse (item (i - 1) list-a = item (j - 1) list-b)
          [ matrix:set d i j (matrix:get d (i - 1) (j - 1)) ]
          [ matrix:set d i j (min (list (matrix:get d (i - 1) j + 1)  (matrix:get d i (j - 1) + 1) (matrix:get d (i - 1) (j - 1) + 1))) ]
      ]
    ]
;   print matrix:get d m n
    report matrix:get d m n
end


; reports a list as a string

to-report _list-as-string [the-list]
    let location 0
    let s "["
    while [location < length the-list] [
      set s (word s (item location the-list) " ")
      set location location + 1
    ]
    report replace-item (length s - 1) s "]"
end


; report whether or not I am in a partnership

; firm procedure
to-report _in-partnership
  ifelse (count my-I-partners > 0)
    [ report 1 ]
    [ report 0 ]
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                        ;;;
;;;   INSTITUTE MEASURES   ;;;
;;;                        ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



to __I__update-institute-measures
    set __I__institutes-SCI-score-C1 []  set __I__institutes-SCI-score-C2 []  set __I__institutes-SCI-score-C3 []
    set __I__institutes-SCI-score-P1 []  set __I__institutes-SCI-score-P2 []  set __I__institutes-SCI-score-P3 []

    set __I__institutes-EI-score-C1  []  set __I__institutes-EI-score-C2  []  set __I__institutes-EI-score-C3  []
    set __I__institutes-EI-score-P1  []  set __I__institutes-EI-score-P2  []  set __I__institutes-EI-score-P3  []

    set __I__institutes-SCI-total-score-C []  set __I__institutes-SCI-total-score-P []
    set __I__institutes-EI-total-score-C  []  set __I__institutes-EI-total-score-P  []

    set __I__institutes-total-score []

    ask institutes [
      set __I__institutes-SCI-score-C1 lput SCI-score-C1 __I__institutes-SCI-score-C1
      set __I__institutes-SCI-score-C2 lput SCI-score-C2 __I__institutes-SCI-score-C2
      set __I__institutes-SCI-score-C3 lput SCI-score-C3 __I__institutes-SCI-score-C3
      set __I__institutes-SCI-score-P1 lput SCI-score-P1 __I__institutes-SCI-score-P1
      set __I__institutes-SCI-score-P2 lput SCI-score-P2 __I__institutes-SCI-score-P2
      set __I__institutes-SCI-score-P3 lput SCI-score-P3 __I__institutes-SCI-score-P3

      set __I__institutes-EI-score-C1  lput EI-score-C1  __I__institutes-EI-score-C1
      set __I__institutes-EI-score-C2  lput EI-score-C2  __I__institutes-EI-score-C2
      set __I__institutes-EI-score-C3  lput EI-score-C3  __I__institutes-EI-score-C3
      set __I__institutes-EI-score-P1  lput EI-score-P1  __I__institutes-EI-score-P1
      set __I__institutes-EI-score-P2  lput EI-score-P2  __I__institutes-EI-score-P2
      set __I__institutes-EI-score-P3  lput EI-score-P3  __I__institutes-EI-score-P3

      set __I__institutes-SCI-total-score-C lput SCI-total-score-C __I__institutes-SCI-total-score-P
      set __I__institutes-SCI-total-score-P lput SCI-total-score-P __I__institutes-SCI-total-score-P

      set __I__institutes-EI-total-score-C  lput EI-total-score-C  __I__institutes-EI-total-score-C
      set __I__institutes-EI-total-score-P  lput EI-total-score-P  __I__institutes-EI-total-score-P

      set __I__institutes-total-score lput total-score __I__institutes-total-score
    ]
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                      ;;;
;;;   NETWORK MEASURES   ;;;
;;;                      ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; NETWORK MEASURES
;;;
;;; compute network density, number of components, etc.


; observer procedure
to __N__update-network-measures
    foreach N:network-types [
      ; network measures depend on this value
      set __N__which-network ?

      set __N__participants-in-net (participants with [any? __N__my-network])
      __N__count-all-edges
      __N__find-all-components
      if (__N__compute-network-distances?) [
        ; computationally expensive!
        set __N__connected? true
        __N__find-path-lengths
        set __N__diameter max [max remove __N__infinity distance-from-other-participants] of __N__participants-in-net
        set __N__num-connected-pairs sum [length remove __N__infinity (remove 0 distance-from-other-participants)] of __N__participants-in-net
        if (__N__num-connected-pairs != (count __N__participants-in-net * (count __N__participants-in-net - 1)))
          [ set __N__connected? false ]
        ifelse (__N__num-connected-pairs > 0)
          [ set __N__average-path-length (sum [sum remove __N__infinity distance-from-other-participants] of __N__participants-in-net) / __N__num-connected-pairs ]
          [ set __N__average-path-length __N__infinity ]
        ]
      __N__find-clustering-coefficient

      let pos position __N__which-network N:network-types
      array:set __N__networks-average-degree         pos __N__average-degree
      array:set __N__networks-average-path-length    pos __N__average-path-length
      array:set __N__networks-clustering-coefficient pos __N__clustering-coefficient
      array:set __N__networks-components             pos __N__number-of-components
      array:set __N__networks-density                pos __N__density
      array:set __N__networks-largest-component-size pos __N__largest-component-size
    ]
end


; use the which-network variable to define what exactly is my network
; WARNING: Network measures and exported files will be different!

; Network types:                  previous     current      previous & current
;                                 partners:    partners:    partners:
;   Research networks               Rp           Rc           R
;   Innovation networks             Ip           Ic           I
;   Tech Transfer networks          Tp           Tc           T
;   Entrepreneurial networks        Ep           Ec           E

; participant procedure
to-report __N__my-network
      ifelse (__N__which-network = "Rp")
      ;; case Rp: report my previous research partners
      [ report my-previous-R-partners ]
    [ ifelse (__N__which-network = "Rc")
      ;; case Rc: report my current research partners
      [ report my-R-partners ]
    [ ifelse (__N__which-network = "R")
      ;; case R: report my previous & current research partners
      [ report (turtle-set my-previous-R-partners my-R-partners) ]
    [ ifelse (__N__which-network = "Ip")
      ;; case Ip: report my previous innovation partners
      [ report my-previous-I-partners ]
    [ ifelse (__N__which-network = "Ic")
      ;; case Ic: report my current innovation partners
      [ report my-I-partners ]
    [ ifelse (__N__which-network = "I")
      ;; case I: report my previous & current innovation partners
      [ report (turtle-set my-previous-I-partners my-I-partners) ]
    [ ifelse (__N__which-network = "Tp")
      ;; case Tp: report my previous tech transfer partners
      [ report my-previous-T-partners ]
    [ ifelse (__N__which-network = "Tc")
      ;; case Tc: report my current tech transfer partners
      [ report my-T-partners ]
    [ ifelse (__N__which-network = "T")
      ;; case T: report my previous & current tech transfer partners
      [ report (turtle-set my-previous-T-partners my-T-partners) ]
    [ ifelse (__N__which-network = "Ep")
      ;; case Ep: report my previous entrepreneurial partners
      [ report my-previous-E-partners ]
    [ ifelse (__N__which-network = "Ec")
      ;; case Ec: report my current entrepreneurial partners
      [ report my-E-partners ]
    [ ifelse (__N__which-network = "E")
      ;; case E: report my previous & current entrepreneurial partners
      [ report (turtle-set my-previous-E-partners my-E-partners) ]
      ;; default case
      [ print (word "Unknown network type " __N__which-network) ]
  ]]]]]]]]]]]
end


; observer procedure
to __N__count-all-edges
    set __N__count-of-edges 0
    let participants-list sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] __N__participants-in-net
    ; edges
    foreach participants-list [
      let mynr [my-pnr] of ?
      ask ? [
        foreach filter [[my-pnr] of ? > mynr] participants-list [
          if (member? ? __N__my-network)
            [ set __N__count-of-edges __N__count-of-edges + 1]
        ]
      ]
    ]
    ; possible edges
    set __N__count-of-possible-edges count __N__participants-in-net * (count __N__participants-in-net - 1) / 2
    ifelse (any? __N__participants-in-net) [
      ; density
      set __N__density __N__count-of-edges / __N__count-of-possible-edges
      ; average degree
      set __N__average-degree 2 * __N__count-of-edges / count __N__participants-in-net
    ] [
      set __N__density 99999
      set __N__average-degree 99999
    ]
end


; to find all the connected components in the network, their sizes and starting nodes

to __N__find-all-components
    set __N__number-of-components 0
    set __N__largest-component-size 0
    ask __N__participants-in-net [ set explored? false ]
    loop [
      let start one-of __N__participants-in-net with [ not explored? ]
      if (start = nobody) [ stop ]
      set __N__number-of-components __N__number-of-components + 1
      set __N__component-size 0
      ask start [ __N__explore ]
      if (__N__component-size > __N__largest-component-size) [
        set __N__largest-component-size __N__component-size
        set __N__largest-start-node start
      ]
    ]
end


; finds all participants reachable from this node

to __N__explore
    if (explored?) [ stop ]
    set explored? true
    set __N__component-size __N__component-size + 1
    ask __N__my-network [ __N__explore ]
end


to-report __N__in-neighborhood? [ hood ]
    report (member? end1 hood and member? end2 hood)
end


to __N__find-clustering-coefficient
    ifelse (any? __N__participants-in-net) [
      ask __N__participants-in-net [
        ask __N__my-network
          [ create-link-with myself]
      ]
      ifelse (all? __N__participants-in-net [count __N__my-network <= 1]) [
        set __N__clustering-coefficient 0
      ] [
        let total 0
        ask __N__participants-in-net with [count __N__my-network <= 1]
          [ set node-clustering-coefficient 0 ]
        ask __N__participants-in-net with [count __N__my-network > 1]
          [
            let hood link-neighbors
            set node-clustering-coefficient (2 * count links with [__N__in-neighborhood? hood] / (count hood * (count hood - 1)))
            set total total + node-clustering-coefficient
          ]
;       set __N__clustering-coefficient total / count __N__participants-in-net with [count link-neighbors > 1]
        set __N__clustering-coefficient total / count __N__participants-in-net
      ]
      clear-links
    ] [
      set __N__clustering-coefficient 99999
    ]
end


to __N__find-path-lengths
    ask __N__participants-in-net [ set distance-from-other-participants [] ]
    let i 0
    let j 0
    let k 0
    let node1 one-of __N__participants-in-net
    let node2 one-of __N__participants-in-net
    let node-count count __N__participants-in-net
    while [i < node-count] [
      set j 0
      while [j < node-count] [
        set node1 turtle i
        set node2 turtle j
        ifelse (i = j)
          [ ask node1 [ set distance-from-other-participants lput 0 distance-from-other-participants ] ]
          [
            ifelse (member? node1 [__N__my-network] of node2)
              [ ask node1 [ set distance-from-other-participants lput 1 distance-from-other-participants ] ]
              [ ask node1 [ set distance-from-other-participants lput __N__infinity distance-from-other-participants ]
          ]
        ]
        set j j + 1
      ]
      set i i + 1
    ]
    set i 0
    set j 0
    let dummy 0
    while [k < node-count] [
      set i 0
      while [i < node-count] [
        set j 0
        while [j < node-count] [
          set dummy (item k [distance-from-other-participants] of turtle i) +
                    (item j [distance-from-other-participants] of turtle k)
          if (dummy < (item j [distance-from-other-participants] of turtle i))
            [ ask turtle i [ set distance-from-other-participants replace-item j distance-from-other-participants dummy ] ]
          set j j + 1
        ]
        set i i + 1
      ]
      set k k + 1
    ]
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                        ;;;
;;;   KNOWLEDGE MEASURES   ;;;
;;;                        ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;; KNOWLEDGE MEASURES
;;;
;;; compute knowledge measures


to __K__update-knowledge-measures
    __K__knowledge-sum-total
    __K__capabilities-frequency
    __K__diffusion
end


to __K__knowledge-sum-total
    set __K__kenes-length-INS []  set __K__kenes-length-IMD []  set __K__kenes-length-LDF []
    set __K__kenes-length-SME []  set __K__kenes-length-SUP []  set __K__kenes-length-ENT []

    ask institutes                   [ set __K__kenes-length-INS lput (length my-capabilities) __K__kenes-length-INS ]
    ask intermediaries               [ set __K__kenes-length-IMD lput (length my-capabilities) __K__kenes-length-IMD ]
    ask firms with [my-type = "ldf"] [ set __K__kenes-length-LDF lput (length my-capabilities) __K__kenes-length-LDF ]
    ask firms with [my-type = "sme"] [ set __K__kenes-length-SME lput (length my-capabilities) __K__kenes-length-SME ]
    ask firms with [my-type = "sup"] [ set __K__kenes-length-SUP lput (length my-capabilities) __K__kenes-length-SUP ]
    ask entrepreneurs                [ set __K__kenes-length-ENT lput (length my-capabilities) __K__kenes-length-ENT ]

    set __K__knowledge sum __K__kenes-length-INS + sum __K__kenes-length-IMD + sum __K__kenes-length-LDF +
        sum __K__kenes-length-SME + sum __K__kenes-length-SUP + sum __K__kenes-length-ENT
end


; frequency distributions of capabilities

to __K__capabilities-frequency
    set __K__capabilities-INS []  set __K__capabilities-IMD []  set __K__capabilities-LDF []
    set __K__capabilities-SME []  set __K__capabilities-SUP []  set __K__capabilities-ENT []

    ask institutes                   [ foreach my-capabilities [ set __K__capabilities-INS lput ? __K__capabilities-INS ] ]
    ask intermediaries               [ foreach my-capabilities [ set __K__capabilities-IMD lput ? __K__capabilities-IMD ] ]
    ask firms with [my-type = "ldf"] [ foreach my-capabilities [ set __K__capabilities-LDF lput ? __K__capabilities-LDF ] ]
    ask firms with [my-type = "sme"] [ foreach my-capabilities [ set __K__capabilities-SME lput ? __K__capabilities-SME ] ]
    ask firms with [my-type = "sup"] [ foreach my-capabilities [ set __K__capabilities-SUP lput ? __K__capabilities-SUP ] ]
    ask entrepreneurs                [ foreach my-capabilities [ set __K__capabilities-ENT lput ? __K__capabilities-ENT ] ]

    set __K__capabilities-frequency-INS []  set __K__capabilities-frequency-IMD []  set __K__capabilities-frequency-LDF []
    set __K__capabilities-frequency-SME []  set __K__capabilities-frequency-SUP []  set __K__capabilities-frequency-ENT []

    let cap 1
    while [cap <= K:nCapabilities] [
      set __K__capabilities-frequency-INS lput (_frequency cap __K__capabilities-INS) __K__capabilities-frequency-INS
      set __K__capabilities-frequency-IMD lput (_frequency cap __K__capabilities-IMD) __K__capabilities-frequency-IMD
      set __K__capabilities-frequency-LDF lput (_frequency cap __K__capabilities-LDF) __K__capabilities-frequency-LDF
      set __K__capabilities-frequency-SME lput (_frequency cap __K__capabilities-SME) __K__capabilities-frequency-SME
      set __K__capabilities-frequency-SUP lput (_frequency cap __K__capabilities-SUP) __K__capabilities-frequency-SUP
      set __K__capabilities-frequency-ENT lput (_frequency cap __K__capabilities-ENT) __K__capabilities-frequency-ENT
      set cap cap + 1
    ]
end


to __K__diffusion
    set __K__capabilities-diffusion []
    let theme 1
    let capabilities-per-theme K:nCapabilities / count themes  ; 100
    while [theme <= K:nThemes] [
      let m 0
      let lowest 1 + (theme - 1) * capabilities-per-theme
      let highest theme * capabilities-per-theme
      ask participants [
        let capabilities-from-theme filter [? >= lowest and ? <= highest] my-capabilities
        if (length capabilities-from-theme > 0)
          [ set m m + 1 ]
      ]
      let n count participants
      set __K__capabilities-diffusion lput (m / n) __K__capabilities-diffusion
      set theme theme + 1
    ]
end


; Frequency distribution of distances between innovation hypotheses

to __K__distances-frequency
    set __K__distances-ENT []

    ask entrepreneurs [
      let minD K:Max-IH-length

;     print my-entrepreneur-nr
;     print "---"
      let the-advert remove-duplicates my-advert
;     print _list-as-string the-advert
;     print "---"

      ask firms [
        let the-other-advert remove-duplicates my-advert
        let D _distance the-advert the-other-advert
        set minD min list D minD
        ; print distance between the adverts and the smallest distance so far
;       print (word u:list-as-string the-other-advert " D = " D " minD = " minD)
;       print D
      ]

;     print "==="
;     print the smallest distance
;     print minD
      set __K__distances-ENT lput minD __K__distances-ENT
;     print ""
;     print ""
    ]

    set __K__distances-frequency-ENT []

    let D 0
    let maxD K:Max-IH-length
    while [D <= maxD] [
      set __K__distances-frequency-ENT lput (_frequency D __K__distances-ENT) __K__distances-frequency-ENT
      set D D + 1
    ]
end



;;;;;;;;;;;;;;;
;;;         ;;;
;;;   LOG   ;;;
;;;         ;;;
;;;;;;;;;;;;;;;



; observer procedure
to __L__log-stage [stage-nr stage]
    if (__L__log?) [
      print ""  print ""
      let s (word "TICKS = " ticks word ", STAGE = " stage-nr ". " stage)
      let ss ""
      repeat length s [ set ss (word ss "-") ]
      print ss  print s  print ss
      print ""  print ""
    ]
end


; observer procedure
to __L__log-calls [type-of-calls]
    if (__L__log? and __L__log-r?) [
      print ""  print (word "CALLS (" type-of-calls "):")
      foreach sort-by [[call-nr] of ?1 < [call-nr] of ?2] calls with [call-type = type-of-calls] [
        type "  "
        if ([call-nr] of ? < 10) [ type " " ]
        print (word [call-nr] of ? "   " [call-type] of ? "   " [call-status] of ?)
      ]
    ]
end


; observer procedure
to __L__log-proposals [type-of-proposals]
    if (__L__log? and __L__log-r?) [
      print ""  print (word "PROPOSALS (" type-of-proposals "):")
      foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [
        let n [count my-proposals with [proposal-type = type-of-proposals]] of ?
        if (n > 0) [
          type "  "
          if ([my-pnr] of ? < 10) [ type " " ]
          if ([my-pnr] of ? < 100) [ type " " ]
          type (word [my-pnr] of ? "   " [my-type] of ? "   " n " ")
          ask [my-proposals with [proposal-type = type-of-proposals]] of ? [
            type (word "  " proposal-nr)
            if (proposal-coordinator = ?) [ type "C" ]
          ]
          print (word "  " [r1:room-for-another-proposal?] of ?)
        ]
      ]
    ]
end


; observer procedure
to __L__log-evaluation
    if (__L__log? and __L__log-r?) [
      print ""  print "EVALUATION:"
      foreach sort-by [[proposal-ranking-nr] of ?1 < [proposal-ranking-nr] of ?2] proposals [
        type "  "
        ; proposal nr
        let col1 [proposal-nr] of ?
        if (col1 < 10)  [ type " " ]
        if (col1 < 100) [ type " " ]
        type (word col1 " ")
        ; ranking nr
        let col2 [proposal-ranking-nr] of ?
        if (col2 < 10)  [ type " " ]
        if (col2 < 100) [ type " " ]
        type (word col2 " ")
        ; consortium size
        type " "
        let col3 count [proposal-consortium] of ?
        if (col3 < 10)  [ type " " ]
        type (word col3 " ")
        ; average expertise level
        let col4 [mean proposal-expertises] of ?
        set col4 round (10 * col4) / 10
        if (col4 < 10)  [ type " " ]
        type (word col4 " ")
        if (col4 = round col4) [ type "  " ]
        ; capability match
        let col5 r2:capability-match ?
        if (col5 < 10)  [ type " " ]
        type (word col5 " ")
        ; status
        let col6 [proposal-status] of ?
        print (word "  " col6)
      ]
    ]
end


; observer procedure
to __L__log-projects [type-of-projects]
    if (__L__log? and __L__log-r?) [
      print ""  print "PROJECTS:"
      foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [
        type "  "
        if ([my-pnr] of ? < 10)  [ type " " ]
        if ([my-pnr] of ? < 100) [ type " " ]
        type (word [my-pnr] of ? "   " [my-type] of ? "   " count [my-projects] of ? " ")
        ask [my-projects with [project-type = type-of-projects]] of ? [ type (word "  " project-nr) ]
        print ""
      ]
    ]
end


; observer procedure
to __L__log-partnerships
    if (__L__log? and __L__log-i?) [
      print ""  print "PARTNERSHIPS:"
      foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] firms [
        type "  "
        if ([my-pnr] of ? < 10)  [ type " " ]
        if ([my-pnr] of ? < 100) [ type " " ]
        type (word [my-pnr] of ? "   " [my-type] of ? "   " count [my-I-partners] of ? " ")
        ask [my-I-partners] of ? [ type (word "  " my-pnr) ]
        print ""
      ]
    ]
end


; observer procedure
to __L__log-networks
    if (__L__log? and __L__log-i?) [
      print ""  print "NETWORKS:"
      foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] firms with [network-firm?] [
        type "  "
        if ([my-pnr] of ? < 10)  [ type " " ]
        if ([my-pnr] of ? < 100) [ type " " ]
        type (word [my-pnr] of ? "   " [my-type] of ? "   " count [my-I-network] of ? " ")
        ask [my-I-network] of ? [ type (word "  " network-members) ]
        print ""
      ]
    ]
end



;;;;;;;;;;;;;;;;
;;;          ;;;
;;;   PLOT   ;;;
;;;          ;;;
;;;;;;;;;;;;;;;;



; observer procedure
to __U__update-plots
    let pos position Plot-settings ["none (fastest)" "model (default)" "all"]
    if (pos > 0) [
      if ((pos > 1) or Metabolism?)   [ __U__update-institutes-plots ]
      if ((pos > 1) or R-Networks?)   [ __U__update-research-plots ]
      if ((pos > 1) or I-Networks?)   [ __U__update-innovation-plots ]
;     if ((pos > 1) or T-Networks?)   [ __U__update-transfer-plots ]
;     if ((pos > 1) or E-Networks?)   [ __U__update-entrepreneurship-plots ]
      if ((pos > 1) or Transactions?) [ __U__update-market-plots ]
      if ((pos > 1) or Metabolism?)   [ __U__update-metabolism-plots ]
      if ((pos > 1) or Valuations?)   [ __U__update-scores-plots ]
;     __U__update-network-measures-plots
;     __U__update-knowledge-measures-plots
    ]
end


to __U__update-institutes-plots
    set-current-plot "Institute SCI/EI Capacity"
    set-current-plot-pen "SCI"  ; average SCI capacity
    plot mean __I__institutes-SCI-total-score-C
    set-current-plot-pen "EI"   ; average EI capacity
    plot mean __I__institutes-EI-total-score-C

    set-current-plot "Institute SCI/EI Performance"
    set-current-plot-pen "SCI"  ; average SCI performance
    plot mean __I__institutes-SCI-total-score-P
    set-current-plot-pen "EI"   ; average EI performance
    plot mean __I__institutes-SCI-total-score-P
end


; observer procedure
to __U__update-research-plots
    if (not Empirical-case?) [
      set-current-plot "Submitted Proposals"
      set-current-plot-pen "BM"  ; number of proposals submitted to the German ministries
      plot count proposals with [proposal-type = "bm" and proposal-status = "submitted"]
      set-current-plot-pen "EC"  ; number of proposals submitted to the EC
      plot count proposals with [proposal-type = "ec" and proposal-status = "submitted"]
    ]

    set-current-plot "Started Projects"
    set-current-plot-pen "BM"  ; number of projects funded by the German ministries
    plot count projects with [project-type = "bm" and project-status = "started"]
    set-current-plot-pen "EC"  ; number of projects funded by the EC
    plot count projects with [project-type = "ec" and project-status = "started"]

    if (not Empirical-case?) [
      set-current-plot "Project Outputs"
      set-current-plot-pen "Publications"  ; number of publications
      plot count projects
      set-current-plot-pen "Patents"       ; number of patents
      plot count projects
    ]

    if (not Empirical-case?) [
      set-current-plot "Participation in Proposals"
      ; number of submitted proposals
      histogram [length my-participation-in-proposals] of participants
    ]

    set-current-plot "Participation in Projects"
    ; number of started projects
    histogram [length my-participation-in-projects] of participants

    set-current-plot "Research Partners"
    ; number of research partners
    set __N__which-network "R"
    histogram [count __N__my-network] of participants with [any? __N__my-network]

    if (not Empirical-case?) [
      set-current-plot "Proposal Size"
      ; size of proposal consortia
      histogram array:item __P__proposals-size 1
    ]

    set-current-plot "Project Size"
    ; size of project consortia
    histogram array:item __P__projects-size 1
end


to __U__update-innovation-plots
    set-current-plot "Innovation Performance"
    set-current-plot-pen "Successes"
    plot count firms with [my-last-reward > Success-threshold]
;   set-current-plot-pen "Start-ups"
;   plot count firms with [(age = 0) and (step != 0) and (not network-firm)]
;   set-current-plot-pen "Net Successes"
;   plot count firms with [network-firm and (last-reward > success-threshold)]

    set-current-plot "Participation in Collaborations"
    set-current-plot-pen "Partnerships"  ; percentage of firms in partnership
    plot 100 * sum [_in-partnership] of firms / count firms
    set-current-plot-pen "Networks"      ; percentage of firms in network
    plot 100 * count firms with [is-agent? my-I-network] / count firms
;   ; connectedness
;   set-current-plot-pen "Connectedness"
;   plot 100 * ((sum [length partners] of firms / 2) +
;               (perm sum [length members] of networks)) /
;                   (perm count-of-firms)

;   ; number of institutes in the networks
;   plot count institutes with [
;       (any? my-R-partners) or (any? my-previous-R-partners) or
;       (any? my-I-partners) or (any? my-previous-I-partners) or
;       (any? my-T-partners) or (any? my-previous-T-partners) or
;       (any? my-E-partners) or (any? my-previous-E-partners)]

    set-current-plot "Innovation Partners"
    ; number of innovation partners
    set __N__which-network "I"
    histogram [count __N__my-network] of participants with [any? __N__my-network]
end


to __U__update-market-plots
    set-current-plot "Population"
    plot count firms

    set-current-plot "Capital"
    if (count firms > 0) [
      let max-capital max [my-capital] of firms
      let max-score 99.999
      if (max-capital > 0)
        [ histogram map [min (list max-score ?)] [100 * my-capital / max-capital] of firms ]
    ]

    set-current-plot "Products"
    set-current-plot-pen "Inputs"
    histogram reduce [sentence ?1 ?2] [my-inputs] of firms
    set-current-plot-pen "Outputs"
    histogram reduce [sentence ?1 ?2] [my-product] of firms
;   if (count firms with [network-firm] > 0) [
;     set-current-plot-pen "Net Inputs"
;     histogram reduce [sentence ?1 ?2] values-from firms with [network-firm] [inputs]
;   ]
;   set-current-plot-pen "Net Products"
;   histogram-from firms with [network-firm] [product]
;   set-current-plot-pen "Purchases"
;   histogram-from firms with [buying? = true] [product]

    set-current-plot "Transactions"
    set-current-plot-pen "Selling"  ; percentage of firms selling
    if (count firms with [my-type != "sup"] > 0) [
      let n1 count firms with [(my-type != "sup") and (selling? = true)]
      let n2 count firms with [my-type != "sup"]
      plot 100 * n1 / n2
    ]
    set-current-plot-pen "Buying"   ; percentage of firms buying
    if (count firms with [my-type != "sup"] > 0) [
      let n1 count firms with [(my-type != "sup") and (buying? = true)]
      let n2 count firms with [my-type != "sup"]
      plot 100 * n1 / n2
    ]

    set-current-plot "Sales"
    if (count firms with [my-sales > 0] > 0) [
      set-current-plot-pen "Sales"
      plot median [my-sales] of firms with [my-sales > 0]
    ]
    if (count firms with [my-last-reward > 0] > 0) [
      set-current-plot-pen "Profits"
      plot median [my-last-reward] of firms with [my-last-reward > 0]
    ]
;   if (count firms with [network-firm and last-reward > 0] > 0) [
;     set-current-plot-pen "Net Profits"
;     plot median [last-reward] of firms with [network-firm and last-reward > 0]
;   ]
end


to __U__update-transfer-plots
end


to __U__update-entrepreneurship-plots
;   set-current-plot "Number of Start-ups"
;   set-current-plot-pen "sup"   ; number of start-ups
;   set-current-plot-pen "hpsu"  ; number of high potential start-ups

;   set-current-plot "Number of Start-ups"
    histogram [my-age] of firms with [my-type = "sup"]
end


to __U__update-metabolism-plots
    set-current-plot "Capacity"
    ; SCI/EI capacity
    plot mean [my-SCI-capacity + my-EI-capacity] of institutes

    set-current-plot "Funding"
    ; average institutional (core) funding
    plot mean [my-funding] of institutes

    set-current-plot "Demand"
    ; average (market) demand
    plot mean [my-demand] of institutes

    set-current-plot "Output"
    ; output
    plot mean [my-output] of institutes

    set-current-plot "Price"
    ; price
    plot mean [my-price] of institutes

    set-current-plot "Resources"
    ; resources generated
    plot mean [my-resources] of institutes
end


to __U__update-scores-plots
    let max-score 99.999

    set-current-plot "SCI Score C1"         ; SCI capacity score #1
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-C1
    set-current-plot "SCI Score C2"         ; SCI capacity score #2
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-C2
    set-current-plot "SCI Score C3"         ; SCI capacity score #2
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-C3
    set-current-plot "SCI Total Score C"    ; SCI total capacity score
    histogram map [min (list max-score ?)] __I__institutes-SCI-total-score-C

    set-current-plot "SCI Score P1"         ; SCI performance score #1
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-P1
    set-current-plot "SCI Score P2"         ; SCI performance score #2
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-P2
    set-current-plot "SCI Score P3"         ; SCI performance score #3
    histogram map [min (list max-score ?)] __I__institutes-SCI-score-P3
    set-current-plot "SCI Total Score P"    ; SCI total performance score
    histogram map [min (list max-score ?)] __I__institutes-SCI-total-score-P

    set-current-plot "EI Score C1"         ; EI capacity score #1
    histogram map [min (list max-score ?)] __I__institutes-EI-score-C1
    set-current-plot "EI Score C2"         ; EI capacity score #2
    histogram map [min (list max-score ?)] __I__institutes-EI-score-C2
    set-current-plot "EI Score C3"         ; EI capacity score #3
    histogram map [min (list max-score ?)] __I__institutes-EI-score-C3
    set-current-plot "EI Total Score C"    ; EI total capacity score
    histogram map [min (list max-score ?)] __I__institutes-EI-total-score-C

    set-current-plot "EI Score P1"         ; EI performance score #1
    histogram map [min (list max-score ?)] __I__institutes-EI-score-P1
    set-current-plot "EI Score P2"         ; EI performance score #2
    histogram map [min (list max-score ?)] __I__institutes-EI-score-P2
    set-current-plot "EI Score P3"         ; EI performance score #3
    histogram map [min (list max-score ?)] __I__institutes-EI-score-P3
    set-current-plot "EI Total Score P"    ; EI total performance score
    histogram map [min (list max-score ?)] __I__institutes-EI-total-score-P

    set-current-plot "SCI/EI Total Score"  ; SCI/EI total balanced score
    histogram map [min (list max-score ?)] __I__institutes-total-score
end


to __U__update-network-measures-plots
    ; research network
    set __N__which-network "R"
    let pos position __N__which-network N:network-types

    set-current-plot "Network Density"
    plot array:item __N__networks-density pos

    set-current-plot "Number of Components"
    plot array:item __N__networks-components pos

    set-current-plot "Size of Largest Component"
    plot array:item __N__networks-largest-component-size pos

    set-current-plot "Average Degree"
    plot array:item __N__networks-average-degree pos

    set-current-plot "Size of Largest Component"
    plot array:item __N__networks-largest-component-size pos

    set-current-plot "Average Path Length"
    plot array:item __N__networks-average-path-length pos

    set-current-plot "Clustering"
    plot array:item __N__networks-clustering-coefficient pos
end


to __U__update-knowledge-measures-plots
;   set-current-plot "Knowledge Space"
;   histogram (sentence __K__capabilities-INS __K__capabilities-IM __K__capabilities-LDF
;                       __K__capabilities-SME __K__capabilities-SU __K__capabilities-EN)

;   set-current-plot "Knowledge"
;   histogram (sentence __K__kenes-length-INS __K__kenes-length-IM __K__kenes-length-LDF
;                       __K__kenes-length-SME __K__kenes-length-SU __K__kenes-length-EN)

;   set-current-plot "Knowledge Flow"
;   set __N__which-network "R"
;   let pos position __N__which-network N:network-types
;   plot array:item __K__knowledge-flow pos

;   set-current-plot "Knowledge Distance"
;   histogram __K__distances-EN
end



;;;;;;;;;;;;;;;;;;
;;;            ;;;
;;;   EXPORT   ;;;
;;;            ;;;
;;;;;;;;;;;;;;;;;;



;;; UPDATE RUN DATA
;;;
;;; update lists for export-run-data

to __X__update-run-data
    let n 0
    set n count participants with [my-type = "ins"]
    set __#__run-data-participants-INS lput n __#__run-data-participants-INS
    set n count participants with [(my-type = "ins") and (_in-net? = true)]
    set __#__run-data-participants-INS-net lput n __#__run-data-participants-INS-net
    set n count participants with [my-type = "imd"]
    set __#__run-data-participants-IMD lput n __#__run-data-participants-IMD
    set n count participants with [(my-type = "imd") and (_in-net? = true)]
    set __#__run-data-participants-IMD-net lput n __#__run-data-participants-IMD-net
    set n count participants with [my-type = "ldf"]
    set __#__run-data-participants-LDF lput n __#__run-data-participants-LDF
    set n count participants with [(my-type = "ldf") and (_in-net? = true)]
    set __#__run-data-participants-LDF-net lput n __#__run-data-participants-LDF-net
    set n count participants with [my-type = "sme"]
    set __#__run-data-participants-SME lput n __#__run-data-participants-SME
    set n count participants with [(my-type = "sme") and (_in-net? = true)]
    set __#__run-data-participants-SME-net lput n __#__run-data-participants-SME-net
    set n count participants with [my-type = "sup"]
    set __#__run-data-participants-SUP lput n __#__run-data-participants-SUP
    set n count participants with [(my-type = "sup") and (_in-net? = true)]
    set __#__run-data-participants-SUP-net lput n __#__run-data-participants-SUP-net
    set n count participants with [my-type = "ent"]
    set __#__run-data-participants-ENT lput n __#__run-data-participants-ENT
    set n count participants with [(my-type = "ent") and (_in-net? = true)]
    set __#__run-data-participants-ENT-net lput n __#__run-data-participants-ENT-net
    set n count participants with [my-type = "oth"]
    set __#__run-data-participants-OTH lput n __#__run-data-participants-OTH
    set n count participants with [(my-type = "oth") and (_in-net? = true)]
    set __#__run-data-participants-OTH-net lput n __#__run-data-participants-OTH-net

    foreach P:Project-types [
      let pos position ? P:Project-types
      if (not Empirical-case?) [
        set n count proposals with [(proposal-type = ?) and (proposal-status = "submitted")]
        array:set __P__run-data-proposals-submitted pos lput n array:item __P__run-data-proposals-submitted pos
        set n array:item __P__proposals-count pos
        array:set __P__run-data-proposals           pos lput n array:item __P__run-data-proposals pos
        set n array:item __P__proposals-with-SME-count pos
        array:set __P__run-data-proposals-with-SME  pos lput n array:item __P__run-data-proposals-with-SME pos
        set n length filter [? <  5] array:item __P__proposals-size pos
        array:set __P__run-data-proposals-small     pos lput n array:item __P__run-data-proposals-small pos
        set n length filter [? > 25] array:item __P__proposals-size pos
        array:set __P__run-data-proposals-big       pos lput n array:item __P__run-data-proposals-big pos
      ]
      set n count projects with [(project-type = ?) and (project-status = "started")]
      array:set __P__run-data-projects-started      pos lput n array:item __P__run-data-projects-started pos
      set n array:item __P__projects-count pos
      array:set __P__run-data-projects              pos lput n array:item __P__run-data-projects pos
      set n array:item __P__projects-with-SME-count pos
      array:set __P__run-data-projects-with-SME     pos lput n array:item __P__run-data-projects-with-SME pos
      set n length filter [? <  5] array:item __P__projects-size pos
      array:set __P__run-data-projects-small        pos lput n array:item __P__run-data-projects-small pos
      set n length filter [? > 25] array:item __P__projects-size pos
      array:set __P__run-data-projects-big          pos lput n array:item __P__run-data-projects-big pos
    ]

;   set __N__run-data-network-density         lput __N__density                __N__run-data-network-density
;   set __N__run-data-network-components      lput __N__number-of-components   __N__run-data-network-components
;   set __N__run-data-network-largest-comp    lput __N__largest-component-size __N__run-data-network-largest-comp
;   set __N__run-data-network-avg-degree      lput __N__average-degree         __N__run-data-network-avg-degree
;   set __N__run-data-network-avg-path-length lput __N__average-path-length    __N__run-data-network-avg-path-length
;   set __N__run-data-network-clustering      lput __N__clustering-coefficient __N__run-data-network-clustering

    if (not Empirical-case?) [
      set __K__run-data-knowledge lput __K__knowledge __K__run-data-knowledge

      foreach P:Project-types [
        let pos position ? P:Project-types
        let kf 0
        set kf kf + (array:item __K__kf-INS-to-INS pos) + (array:item __K__kf-INS-to-LDF pos) + (array:item __K__kf-INS-to-SME pos)
        set kf kf + (array:item __K__kf-LDF-to-INS pos) + (array:item __K__kf-LDF-to-LDF pos) + (array:item __K__kf-LDF-to-SME pos)
        set kf kf + (array:item __K__kf-SME-to-INS pos) + (array:item __K__kf-SME-to-LDF pos) + (array:item __K__kf-SME-to-SME pos)
        array:set __K__run-data-knowledge-flow pos lput kf array:item __K__run-data-knowledge-flow pos
        array:set __K__run-data-kf-INS-to-INS  pos lput (array:item __K__kf-INS-to-INS pos) array:item __K__run-data-kf-INS-to-INS pos
        array:set __K__run-data-kf-INS-to-LDF  pos lput (array:item __K__kf-INS-to-LDF pos) array:item __K__run-data-kf-INS-to-LDF pos
        array:set __K__run-data-kf-INS-to-SME  pos lput (array:item __K__kf-INS-to-SME pos) array:item __K__run-data-kf-INS-to-SME pos
        array:set __K__run-data-kf-LDF-to-INS  pos lput (array:item __K__kf-LDF-to-INS pos) array:item __K__run-data-kf-LDF-to-INS pos
        array:set __K__run-data-kf-LDF-to-LDF  pos lput (array:item __K__kf-LDF-to-LDF pos) array:item __K__run-data-kf-LDF-to-LDF pos
        array:set __K__run-data-kf-LDF-to-SME  pos lput (array:item __K__kf-LDF-to-SME pos) array:item __K__run-data-kf-LDF-to-SME pos
        array:set __K__run-data-kf-SME-to-INS  pos lput (array:item __K__kf-SME-to-INS pos) array:item __K__run-data-kf-SME-to-INS pos
        array:set __K__run-data-kf-SME-to-LDF  pos lput (array:item __K__kf-SME-to-LDF pos) array:item __K__run-data-kf-SME-to-LDF pos
        array:set __K__run-data-kf-SME-to-SME  pos lput (array:item __K__kf-SME-to-SME pos) array:item __K__run-data-kf-SME-to-SME pos
      ]

;     set __K__run-data-knowledge-patents  lput __K__patents  __K__run-data-knowledge-patents
;     set __K__run-data-knowledge-articles lput __K__articles __K__run-data-knowledge-articles

      let capabilities-frequency (map [?1 + ?2 + ?3 + ?4 + ?5 + ?6]
          __K__capabilities-frequency-INS __K__capabilities-frequency-IMD __K__capabilities-frequency-LDF
          __K__capabilities-frequency-SME __K__capabilities-frequency-SUP __K__capabilities-frequency-ENT)
      set __K__run-data-capabilities lput (length filter [? > 0] capabilities-frequency) __K__run-data-capabilities
      foreach __K__capabilities-diffusion
        [ set __K__run-data-capabilities-diffusion lput ? __K__run-data-capabilities-diffusion ]
    ]

;   ask firms [
;   ifelse (my-type = "sup")
;     [ matrix:set M:run-data-sales my-nr ticks precision my-potential-sales 1 ]
;     [ matrix:set M:run-data-sales my-nr ticks precision my-sales 1 ]
;   ]
end


;;; EXPORT RUN DATA
;;;
;;; export run data to .csv file

; observer procedure
to __X__export-run-data [export-to-simdb?]
    let sep pathdir:get-separator
    let file-name ""
    ifelse (export-to-simdb?) [
      let file-location (word __X__Simdb-location sep "eisskin" Model-version sep Experiment-name sep "data" sep "rundata" sep)
      set file-name (word file-location "eisskin" Model-version " " Experiment-name " " behaviorspace-run-number ".csv")
    ] [
      set file-name (word "work" sep "rundata" sep ticks ".csv")
    ]
    if (file-exists? file-name) [ file-delete file-name ]
    file-open file-name

    file-print (word "Model-version,"   Model-version)
    file-print (word "Experiment-name," Experiment-name)
    file-print (word "Run-number,"      behaviorspace-run-number)
    file-print (word "date-and-time,"   date-and-time)
    file-print ""

    ;;; Inputs

    file-print (word "Base-year,"          Base-year)
    file-print (word "nMonths,"            nMonths)
    file-print (word "Empirical-case,"     Empirical-case?)
    file-print (word "Instruments-filter," Instruments-filter)
    file-print (word "Cutoff-point,"       Cutoff-point)
    file-print ""

    ; Export presets only if relevant
    if (not Empirical-case?) [
      file-print (word "Participants-settings," Participants-settings)
      file-print (word "Institutes-settings,"   Institutes-settings)
      file-print (word "Instruments-settings,"  Instruments-settings)
      file-print (word "Calls-settings,"        Calls-settings)
      file-print (word "Other-settings,"        Other-settings)

      file-print ""
      file-print ";Model-settings"
      file-print (word "Model-settings," Model-settings)
      file-print (word "System?,"        System?)
      file-print (word "R-Networks?,"    R-Networks?)
      file-print (word "I-Networks?,"    I-Networks?)
      file-print (word "T-Networks?,"    T-Networks?)
      file-print (word "E-Networks?,"    E-Networks?)
      file-print (word "Transactions?,"  Transactions?)
      file-print (word "Valuations?,"    Valuations?)

      file-print ""
      file-print ";System-settings"
      file-print (word "Survival-threshold," Survival-threshold)

      file-print ""
      file-print ";Participants-settings,Number,Percent,Size"
      file-print (word "Institutes,"     nInstitutes     ",," Size-INS)
      file-print (word "Intermediaries," nIntermediaries ",," Size-IMD)
      file-print (word "Firms,"          nFirms)
      file-print (word "LDF,," Perc-LDF "," Size-LDF)
      file-print (word "SME,," Perc-SME "," Size-SME)
      file-print (word "SUP,,"          "," Size-SUP)
      file-print (word "Entrepreneurs,"  nEntrepreneurs  ",," Size-ENT)
      file-print (word "Agencies,"       nAgencies)

      file-print ""
      file-print (word ";Institutes-settings" _list-to-csv I:Organisation-types)
      file-print (word "SCI" _array-to-csv I:Perc-SCI)
      file-print (word "EI"  _array-to-csv I:Perc-EI)

      file-print ""
      file-print (word ";Instruments-settings" _list-to-csv P:Project-types)
      file-print (word "Match"          _array-to-csv P:Match)
      file-print (word "Contribution"   _array-to-csv P:Contribution)
      file-print (word "Duration-avg"   _array-to-csv P:Duration-avg)
      file-print (word "Duration-stdev" _array-to-csv P:Duration-stdev)
;     file-print (word "Size"           _array-to-csv P:Size)
      file-print (word "Size-min"       _array-to-csv P:Size-min)
      file-print (word "Size-max"       _array-to-csv P:Size-max)

      file-print ""
      file-print (word ";Calls-settings" _list-to-csv P:Project-types)
      file-print (word "Funding"     _array-to-csv P:Funding-calls)
      file-print (word "Orientation" _array-to-csv P:Orientation-calls)
      file-print (word "Range"       _array-to-csv P:Range-calls)
;     file-print (word "Themes"      _array-to-csv P:Themes-calls)

      file-print ""
      file-print ";Themes-settings"
      file-print (word "nCapabilities,"                 K:nCapabilities)
      file-print (word "nThemes,"                       K:nThemes)
      file-print (word "Sector-capabilities-per-theme," K:Sector-capabilities-per-theme)
      file-print (word "Rare-capabilities-per-theme,"   K:Rare-capabilities-per-theme)

      file-print ""
      file-print ";Other-settings"
      file-print (word "Funding," Funding)
    ]

    ;;; Outputs

    file-print ""
    file-type "Month"
    let month 0
    while [month <= nMonths] [ file-type (word "," month)  set month month + 1 ]
    file-print ""

    file-print ""
    file-type "participants-INS"      foreach __#__run-data-participants-INS     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-INS-net"  foreach __#__run-data-participants-INS-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-IMD"      foreach __#__run-data-participants-IMD     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-IMD-net"  foreach __#__run-data-participants-IMD-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-LDF"      foreach __#__run-data-participants-LDF     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-LDF-net"  foreach __#__run-data-participants-LDF-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-SME"      foreach __#__run-data-participants-SME     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-SME-net"  foreach __#__run-data-participants-SME-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-SUP"      foreach __#__run-data-participants-SUP     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-SUP-net"  foreach __#__run-data-participants-SUP-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-ENT"      foreach __#__run-data-participants-ENT     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-ENT-net"  foreach __#__run-data-participants-ENT-net [ file-type (word "," ?) ]  file-print ""
    file-type "participants-OTH"      foreach __#__run-data-participants-OTH     [ file-type (word "," ?) ]  file-print ""
    file-type "participants-OTH-net"  foreach __#__run-data-participants-OTH-net [ file-type (word "," ?) ]  file-print ""

    foreach P:Project-types [
      let pos position ? P:Project-types
      file-print ""
      if (not Empirical-case?) [
        file-type (word "proposals-submitted-" ?)  foreach array:item __P__run-data-proposals-submitted pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-" ?)            foreach array:item __P__run-data-proposals           pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-with-SME-" ?)   foreach array:item __P__run-data-proposals-with-SME  pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-small-" ?)      foreach array:item __P__run-data-proposals-small     pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-big-" ?)        foreach array:item __P__run-data-proposals-big       pos [ file-type (word "," ?) ]  file-print ""
      ]
      file-type (word "projects-started-" ?)   foreach array:item __P__run-data-projects-started  pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-" ?)           foreach array:item __P__run-data-projects          pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-with-SME-" ?)  foreach array:item __P__run-data-projects-with-SME pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-small-" ?)     foreach array:item __P__run-data-projects-small    pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-big-" ?)       foreach array:item __P__run-data-projects-big      pos [ file-type (word "," ?) ]  file-print ""
    ]

;   foreach N:network-types [
;     let pos position ? N:network-types
;     file-type (word "network-density-" ?)          foreach array:item __N__run-data-network-density         pos [ file-type (word "," ?) ]  file-print ""
;     file-type (word "network-components-" ?)       foreach array:item __N__run-data-network-components      pos [ file-type (word "," ?) ]  file-print ""
;     file-type (word "network-largest-comp-" ?)     foreach array:item __N__run-data-network-largest-comp    pos [ file-type (word "," ?) ]  file-print ""
;     file-type (word "network-avg-degree-" ?)       foreach array:item __N__run-data-network-avg-degree      pos [ file-type (word "," ?) ]  file-print ""
;     file-type (word "network-avg-path-length-" ?)  foreach array:item __N__run-data-network-avg-path-length pos [ file-type (word "," ?) ]  file-print ""
;     file-type (word "network-clustering-" ?)       foreach array:item __N__run-data-network-clustering      pos [ file-type (word "," ?) ]  file-print ""
;   ]

    if (not Empirical-case?) [
      file-type "knowledge"  foreach __K__run-data-knowledge [ file-type (word "," ?) ]  file-print ""

      foreach P:Project-types [
        let pos position ? P:Project-types
        file-type (word "knowledge-flow-" ?)  foreach array:item __K__run-data-knowledge-flow pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-INS-to-INS-" ?)  foreach array:item __K__run-data-kf-INS-to-INS pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-INS-to-LDF-" ?)  foreach array:item __K__run-data-kf-INS-to-LDF pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-INS-to-SME-" ?)  foreach array:item __K__run-data-kf-INS-to-SME pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-LDF-to-INS-" ?)  foreach array:item __K__run-data-kf-LDF-to-INS pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-LDF-to-LDF-" ?)  foreach array:item __K__run-data-kf-LDF-to-LDF pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-LDF-to-SME-" ?)  foreach array:item __K__run-data-kf-LDF-to-SME pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-SME-to-INS-" ?)  foreach array:item __K__run-data-kf-SME-to-INS pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-SME-to-LDF-" ?)  foreach array:item __K__run-data-kf-SME-to-LDF pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "knowledge-SME-to-SME-" ?)  foreach array:item __K__run-data-kf-SME-to-SME pos [ file-type (word "," ?) ]  file-print ""
      ]

;     file-type "knowledge-patents"   foreach __K__run-data-knowledge-patents  [ file-type (word "," ?) ]  file-print ""
;     file-type "knowledge-articles"  foreach __K__run-data-knowledge-articles [ file-type (word "," ?) ]  file-print ""
      file-type "capabilities"        foreach __K__run-data-capabilities       [ file-type (word "," ?) ]  file-print ""

      let theme 1
      while [theme <= K:nThemes] [
        file-type (word "capabilities-diffusion-Theme" theme)
        let i 0
        foreach __K__run-data-capabilities-diffusion [
          if ((i mod K:nThemes) = (theme - 1))
            [ file-type (word "," ?) ]
          set i i + 1
        ]
        file-print ""
        set theme theme + 1
      ]
    ]

    file-print ""
    file-type "participants-pnr"            foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [my-pnr]  of ?) ]  file-print ""
    if (not Empirical-case?)
      [ file-type "participants-nr"         foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [_my-nr]  of ?) ]  file-print "" ]
    file-type "participants-id"             foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [my-id]   of ?) ]  file-print ""
    file-type "participants-type"           foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [my-type] of ?) ]  file-print ""

    file-type "participants-org-type"
    foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [
      ifelse ([my-type] of ? = "ins")
        [ file-type (word "," [my-org-type] of ?) ]
        [ file-type (word ",") ]
    ]
    file-print ""

    if (not Empirical-case?)
      [ file-type "participants-size"       foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [my-cap-capacity] of ?) ]  file-print "" ]
    file-type "participants-R-partners"     foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," count [my-previous-R-partners] of ?) ]  file-print ""
    file-type "participants-I-partners"     foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," count [my-previous-I-partners] of ?) ]  file-print ""
    file-type "participants-T-partners"     foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," count [my-previous-T-partners] of ?) ]  file-print ""
    file-type "participants-E-partners"     foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," count [my-previous-E-partners] of ?) ]  file-print ""
    if (not Empirical-case?)
      [ file-type "participants-proposals"  foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [length my-participation-in-proposals] of ?) ]  file-print "" ]
    file-type "participants-projects"       foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [ file-type (word "," [length my-participation-in-projects]  of ?) ]  file-print ""

    if (not Empirical-case?) [
      foreach P:Project-types [
        let pos position ? P:Project-types
        file-print ""
        file-type (word "proposals-type-" ?)              foreach array:item __P__proposals-type      pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-call-" ?)              foreach array:item __P__proposals-call      pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-size-" ?)              foreach array:item __P__proposals-size      pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-INS-" ?)               foreach array:item __P__proposals-INS       pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-LDF-" ?)               foreach array:item __P__proposals-LDF       pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-SME-" ?)               foreach array:item __P__proposals-SME       pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-expertise-level-" ?)   foreach array:item __P__proposals-exp-level pos [ file-type (word "," ?) ]  file-print ""
        file-type (word "proposals-capability-match-" ?)  foreach array:item __P__proposals-cap-match pos [ file-type (word "," ?) ]  file-print ""
      ]
    ]
    foreach P:Project-types [
      let pos position ? P:Project-types
      file-print ""
      file-type (word "projects-nr-" ?)            foreach array:item __P__projects-nr           pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-id-" ?)            foreach array:item __P__projects-id           pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-type-" ?)          foreach array:item __P__projects-type         pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-call-" ?)          foreach array:item __P__projects-call         pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-size-" ?)          foreach array:item __P__projects-size         pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-INS-" ?)           foreach array:item __P__projects-INS          pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-LDF-" ?)           foreach array:item __P__projects-LDF          pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-SME-" ?)           foreach array:item __P__projects-SME          pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-duration-" ?)      foreach array:item __P__projects-duration     pos [ file-type (word "," ?) ]  file-print ""
      file-type (word "projects-contribution-" ?)  foreach array:item __P__projects-contribution pos [ file-type (word "," ?) ]  file-print ""
    ]

    if (not Empirical-case?) [
      file-print ""
      file-type "kenes-length"
      let kenes-length (sentence __K__kenes-length-INS __K__kenes-length-LDF __K__kenes-length-SME)
      foreach kenes-length [ file-type (word "," ?) ]  file-print ""
      file-type "capabilities-frequency"
      let capabilities-frequency (map [?1 + ?2 + ?3] __K__capabilities-frequency-INS __K__capabilities-frequency-LDF __K__capabilities-frequency-SME)
      foreach capabilities-frequency [ file-type (word "," ?) ]  file-print ""
    ]

;   foreach n-values (nFirms + nEntrepreneurs) [?] [
;     file-type (word "sales " ?)
;     set month 1
;     while [month <= nMonths] [
;       file-type (word "," matrix:get M:run-data-sales ? month)
;       set month month + 1
;     ]
;     file-print ""
;   ]
;   file-print ""

    file-close
end


; for testing the numbering of agents (my-nr)

; participant procedure
to-report _my-nr
      ifelse ((my-type = "ins") or (my-type = "uni") or (my-type = "ctr"))
      ;; case INS, UNI, CTR: report institute-nr
      [ report my-institute-nr ]
    [ ifelse (my-type = "imd")
      ;; case IMD: report intermediary-nr
      [ report my-intermediary-nr ]
    [ ifelse ((my-type = "ldf") or (my-type = "sme") or (my-type = "sup"))
      ;; case LDF, SME, SUP: report firm-nr
      [ report my-firm-nr ]
    [ ifelse (my-type = "ent")
      ;; case ENT: report entrepreneur-nr
      [ report my-entrepreneur-nr ]
    [ ifelse ((my-type = "gov") or (my-type = "ngo") or (my-type = "oth"))
      ;; case OTH: report other-agent-nr
      [ report my-agent-nr ]
      ;; default case
      [ print (word "Unknown participant type " my-type) ]
  ]]]]
end


; participants procedure
to-report _in-net?
    report (any? my-R-partners) or (any? my-previous-R-partners) or
           (any? my-I-partners) or (any? my-previous-I-partners) or
           (any? my-T-partners) or (any? my-previous-T-partners) or
           (any? my-E-partners) or (any? my-previous-E-partners)
end


; [1 2 3] -> ",1,2,3"

; observer procedure
to-report _list-to-csv [a-list]
    let s ""
    foreach a-list [ set s (word s "," ?) ]
    report s
end


; {{array: 1 2 3}} -> ",1,2,3"

; observer procedure
to-report _array-to-csv [an-array]
    let s ""
    let pos 0
    while [pos < array:length an-array] [
      set s (word s "," array:item an-array pos)
      set pos pos + 1
    ]
    report s
end


;;; EXPORT NETWORK DATA
;;;
;;; export network data to specific formats


; observer procedure
to __X__export-network-data [export-to-simdb?]
    foreach N:network-types [
      set __N__which-network ?
;     __X__export-network-data-gml      export-to-simdb? false
;     __X__export-network-data-gml      export-to-simdb? true
      __X__export-network-data-gexf     export-to-simdb? false
;     __X__export-network-data-gexf     export-to-simdb? true
;     __X__export-network-data-dyn-gexf export-to-simdb? false
;     __X__export-network-data-dyn-gexf export-to-simdb? true
  ]
end


; intercept <null>

to-report _null [a-string]
    if (not is-string? a-string) [ report "null" ]  ; intercept <null>
    report a-string
end


; remove surrounding ""

to-report _trim [a-string]
    ifelse (not empty? a-string) [
      ifelse ((length a-string > 2) and (first a-string = "\"") and (last a-string = "\""))
        [ report substring a-string 1 (length a-string - 2) ]
        [ report a-string ]
    ] [
      report ""
    ]
end


; change & to &amp;

to-report _escape [a-string]
    ifelse (not empty? a-string)
      [ report _esc a-string 0 (length a-string) ]
      [ report "" ]
end


to-report _esc [a-string pos1 pos2]
;   print (word "_esc [a-string = " a-string ", pos1 = " pos1 ", pos2 = " pos2 "]")
    ifelse (not empty? a-string)
      [
;       print (word "substring = " substring a-string pos1 pos2)
        ; position of the first appearance of "&" in the substring
        let pos position "&" (substring a-string pos1 pos2)
;       print (word "pos = " pos)
        ifelse (pos = false)
          [ report a-string ]
          [ report _esc (replace-item (pos + pos1) a-string "&amp;") (pos + pos1 + 5) (pos2 + 4) ]
      ]
      [ report "" ]
end


; export network data in gml format

; observer procedure
to __X__export-network-data-gml [export-to-simdb? weighted?]
    let sep pathdir:get-separator
    let file-name ""
    ifelse (export-to-simdb?) [
    let file-location (word __X__Simdb-location sep "eisskin" Model-version sep Experiment-name sep "data" sep "netdata" sep "gml" sep)
    set file-name (word file-location "eisskin" Model-version " " Experiment-name " " behaviorspace-run-number " " __N__which-network ticks)
    ] [
      set file-name (word "work" sep "netdata" sep "gml" sep __N__which-network ticks)
    ]
    ifelse (weighted?)
      [ set file-name (word file-name ".weighted.gml") ]
      [ set file-name (word file-name ".gml") ]
    if (file-exists? file-name) [ file-delete file-name ]
    file-open file-name
    let participants-list sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants with [count __N__my-network > 0]
    file-print "graph ["
    ; nodes
    foreach participants-list [
      file-print "  node ["
      file-print (word "    id \""   [my-pnr]  of ? "\"")
      file-print (word "    type \"" [my-type] of ? "\"")
      file-print (word "    name \"" _trim [my-name] of ? "\"")
      file-print "  ]"
    ]
    ; edges
    let n count participants
    foreach participants-list [
      let mynr [my-pnr] of ?
      ask ? [
        foreach filter [[my-pnr] of ? > mynr] participants-list [
          if (member? ? __N__my-network) [
            let weight 1
;           if (weighted?) [
;             ; weight (number of edges) reflects history of partnerships
;             let index ((mynr - 1) * n) + [my-pnr] of ? - 1
;             set weight array:item P:partnerships-matrix index
;           ]
            ; TO DO : number of participants is not known
            let w 1
            while [w <= weight] [
              file-print "  edge ["
              file-print (word "    source \"" mynr "\"")
              file-print (word "    target \"" [my-pnr] of ? "\"")
              file-print "  ]"
              set w w + 1
            ]
          ]
        ]
      ]
    ]
    file-print "]"
    file-close
end


; export network data in gexf format

; observer procedure
to __X__export-network-data-gexf [export-to-simdb? weighted?]
    let sep pathdir:get-separator
    let file-name ""
    ifelse (export-to-simdb?) [
      let file-location (word __X__Simdb-location sep "eisskin" Model-version sep Experiment-name sep "data" sep "netdata" sep "gexf" sep)
      set file-name (word file-location "eisskin" Model-version " " Experiment-name " " behaviorspace-run-number " " __N__which-network ticks)
    ] [
      set file-name (word "work" sep "netdata" sep "gexf" sep __N__which-network ticks)
    ]
    ifelse (weighted?)
      [ set file-name (word file-name ".weighted.gexf") ]
      [ set file-name (word file-name ".gexf") ]
    if (file-exists? file-name) [ file-delete file-name ]
    file-open file-name
    file-print "<?xml version=\"1.0\" encoding=\"UTF?8\"?>"
    file-print "<gexf xmlns=\"http://www.gexf.net/1.2draft\""
    file-print "      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema?instance\""
    file-print "      xsi:schemaLocation=\"http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd\""
    file-print "      version=\"1.2\">"
    file-print (word "  <meta lastmodifieddate=\"" date-and-time "\">")
    file-print (word "    <creator>" model-version "</creator>")
    file-print (word "    <description>exported netdata</description>")
    file-print "  </meta>"
    file-print "  <graph defaultedgetype=\"undirected\">"
    file-print "    <attributes class=\"node\" mode=\"static\">"
    file-print "      <attribute id=\"0\" title=\"nd_type\"    type=\"string\"/>"
    file-print "      <attribute id=\"1\" title=\"type\"       type=\"string\"/>"
    file-print "      <attribute id=\"2\" title=\"name\"       type=\"string\"/>"
    file-print "      <attribute id=\"3\" title=\"short_name\" type=\"string\"/>"
    file-print "      <attribute id=\"4\" title=\"city\"       type=\"string\"/>"
    file-print "      <attribute id=\"5\" title=\"zip_code\"   type=\"string\"/>"
    file-print "      <attribute id=\"6\" title=\"country\"    type=\"string\"/>"
    file-print "    </attributes>"
    file-print "    <attributes class=\"edge\" mode=\"static\">"
    file-print "      <attribute id=\"0\" title=\"ed_type\"    type=\"string\"/>"
;   file-print "      <attribute id=\"1\" title=\"ed_source\"  type=\"string\"/>"
;   file-print "      <attribute id=\"2\" title=\"ed_target\"  type=\"string\"/>"
    file-print "    </attributes>"
    ; nodes
    file-print "    <nodes>"
    let participants-list sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants with [count __N__my-network > 0]
    foreach participants-list [
      file-print (word "      <node id=\"" [my-pnr] of ? "\" label=\"" _escape _trim _null [my-short-name] of ? "\">")
      file-print "        <attvalues>"
      file-print (word "          <attvalue for=\"0\" value=\"pa\"/>")
      let mytype [my-type] of ?
      if ([my-type] of ? = "ins") and (member? [my-org-type] of ? I:Organisation-types)
        [ set mytype [my-org-type] of ? ]
      file-print (word "          <attvalue for=\"7\" value=\"" _null mytype "\"/>")
      file-print (word "          <attvalue for=\"1\" value=\"" _null mytype "\"/>")
      file-print (word "          <attvalue for=\"2\" value=\"" _escape _trim _null [my-name] of ? "\"/>")
      file-print (word "          <attvalue for=\"3\" value=\"" _escape _trim _null [my-short-name] of ? "\"/>")
      file-print (word "          <attvalue for=\"4\" value=\"" _null [my-city] of ? "\"/>")
      file-print (word "          <attvalue for=\"5\" value=\"" _null [my-zip-code] of ? "\"/>")
      file-print (word "          <attvalue for=\"6\" value=\"" _null [my-country] of ? "\"/>")
      file-print "        </attvalues>"
      file-print "      </node>"
    ]
    file-print "    </nodes>"
    ; edges
    file-print "    <edges>"
    let nr 1
    let n count participants
    foreach participants-list [
      let mynr [my-pnr] of ?
      ask ? [
        foreach filter [[my-pnr] of ? > mynr] participants-list [
          if (member? ? __N__my-network) [
            let weight 1
;           if (weighted?) [
;             ; weight (number of edges) reflects history of partnerships
;             let index ((mynr - 1) * n) + [my-pnr] of ? - 1
;             set weight array:item P:partnerships-matrix index
;           ]
            ; TO DO : number of participants is not known
            file-print (word "      <edge id=\"" nr "\" source=\"" mynr "\" target=\"" [my-pnr] of ? "\" weight=\"" weight "\">")
            file-print "        <attvalues>"
            file-print (word "          <attvalue for=\"0\" value=\"pa-pa\"/>")
;           file-print (word "          <attvalue for=\"1\" value=\"" my-short-name "\"/>")
;           file-print (word "          <attvalue for=\"2\" value=\"" [my-short-name] of ? "\"/>")
            file-print "        </attvalues>"
            file-print "      </edge>"
            set nr nr + 1
          ]
        ]
      ]
    ]
    file-print "    </edges>"
    file-print "  </graph>"
    file-print "</gexf>"
    file-close
end


;;; EXPORT KNOWLEDGE DATA
;;;
;;; export knowledge data to .csv file


; observer procedure
to __X__export-knowledge-data [export-to-simdb?]
    let sep pathdir:get-separator
    let file-name ""
    ifelse (export-to-simdb?) [
      let file-location (word __X__Simdb-location sep "eisskin" Model-version sep Experiment-name sep "data" sep "kdata" sep)
      set file-name (word file-location "eisskin" Model-version " " Experiment-name " " behaviorspace-run-number " " ticks ".csv")
    ] [
      set file-name (word "work" sep "kdata" sep ticks ".csv")
    ]
    if (file-exists? file-name) [ file-delete file-name ]
    file-open file-name

    foreach sort-by [[my-pnr] of ?1 < [my-pnr] of ?2] participants [
      file-type (word [my-pnr] of ? ",")
      file-type (word [my-type] of ? ",")
      if (not Empirical-case?) [
        let capabilities-list sort [my-capabilities] of ?
        let i 0
        foreach capabilities-list [
          ifelse (i > 0)
            [ file-type (word "," ?) ]
            [ file-type ? ]
          set i i + 1
        ]
        file-print ""
      ]
    ]

    file-close
end


;; end of code
@#$#@#$#@
GRAPHICS-WINDOW
1304
28
1549
239
16
16
5.455
1
10
1
1
1
0
1
1
1
-16
16
-16
16
0
0
1
Months
30.0

BUTTON
616
54
683
87
Setup
#:setup
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
683
54
750
87
Go
#:go
T
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
750
54
808
87
Step
#:go
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

INPUTBOX
616
102
808
162
Model-version
EIS-SKIN (10.2016)
1
0
String

PLOT
1400
454
1707
639
Innovation Partners
Number of Partners
Freq.
0.0
75.0
0.0
20.0
false
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

MONITOR
9
14
167
59
Participants-settings
Participants-settings
17
1
11

SLIDER
245
47
343
80
nFirms
nFirms
0
1000
10
1
1
NIL
HORIZONTAL

TEXTBOX
193
96
221
114
LDF
11
0.0
1

TEXTBOX
193
128
221
146
SME
11
0.0
1

SLIDER
245
80
343
113
Perc-LDF
Perc-LDF
0
100
18.5
1
1
NIL
HORIZONTAL

SLIDER
245
112
343
145
Perc-SME
Perc-SME
0
100
74.1
1
1
NIL
HORIZONTAL

SLIDER
343
80
441
113
Size-LDF
Size-LDF
0
50
15
1
1
NIL
HORIZONTAL

SLIDER
343
112
441
145
Size-SME
Size-SME
0
50
10
1
1
NIL
HORIZONTAL

TEXTBOX
193
30
221
48
INS
11
0.0
1

SLIDER
245
14
343
47
nInstitutes
nInstitutes
0
1000
30
1
1
NIL
HORIZONTAL

SLIDER
343
14
441
47
Size-INS
Size-INS
0
50
10
1
1
NIL
HORIZONTAL

CHOOSER
616
499
808
544
Participants-settings
Participants-settings
"manual" "Baseline"
0

MONITOR
9
334
167
379
Instruments-settings
Instruments-settings
17
1
11

SLIDER
616
273
808
306
nMonths
nMonths
0
200
179
1
1
NIL
HORIZONTAL

PLOT
1092
454
1400
639
Participation in Collaborations
Time (Months)
%
0.0
180.0
0.0
100.0
false
false
"" ""
PENS
"Partnerships" 1.0 0 -16777216 true "" ""
"Networks" 1.0 0 -7500403 true "" ""

PLOT
1400
270
1707
455
Innovation Performance
Time (Months)
Score
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"Successes" 1.0 0 -16777216 true "" ""

PLOT
1092
270
1400
455
Innovation Capacity
Time (Months)
Score
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1738
662
1942
798
Number of Start-ups
Time (Months)
Count
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"su" 1.0 0 -7500403 true "" ""
"hpsu" 1.0 0 -2674135 true "" ""

PLOT
1092
786
1297
933
Transactions
Time (Months)
%
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"Selling" 1.0 0 -16777216 true "" ""
"Buying" 1.0 0 -7500403 true "" ""

PLOT
1502
639
1707
786
Products
Time (Months)
Count
0.0
100.0
0.0
100.0
true
false
"" ""
PENS
"Inputs" 1.0 1 -7500403 true "" ""
"Outputs" 1.0 1 -2674135 true "" ""

PLOT
1092
54
1399
239
Institute SCI/EI Capacity
Time (Months)
Score
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"SCI" 1.0 0 -7500403 true "" ""
"EI" 1.0 0 -2674135 true "" ""

PLOT
1399
54
1707
239
Institute SCI/EI Performance
Time (Months)
Score
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"SCI" 1.0 0 -16777216 true "" ""
"EI" 1.0 0 -7500403 true "" ""

PLOT
1092
639
1297
786
Population
Time (months)
N
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1738
798
1942
933
Age of Start-ups
Age
Freq.
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
836
962
1063
1092
Network Density
Time (Months)
NIL
0.0
180.0
0.0
1.0
false
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

PLOT
1942
662
2146
798
Exit Rate of Start-ups
Time (Months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS

PLOT
1297
639
1502
786
Capital
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
1502
786
1707
933
Rate of Radical Research
Time (Months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS

PLOT
1549
1124
1776
1254
Knowledge
Number of Capabilities
Freq.
0.0
50.0
0.0
50.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
1776
1124
2003
1254
Knowledge Flow
Time (Months)
Flow
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1942
798
2146
933
Median Age at Exit
Age
Freq.
0.0
10.0
0.0
100.0
true
false
"" ""
PENS

PLOT
1517
962
1744
1092
Average Degree
Time (Months)
NIL
0.0
180.0
0.0
50.0
false
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

CHOOSER
616
588
808
633
Instruments-settings
Instruments-settings
"manual" "Baseline"
0

INPUTBOX
616
162
808
222
Experiment-name
NIL
1
0
String

PLOT
1063
962
1290
1092
Number of Components
Time (Months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

PLOT
1744
962
1971
1092
Average Path Length
Time (Months)
NIL
0.0
180.0
0.0
5.0
false
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

MONITOR
1738
115
1804
160
LDF
count firms with [my-type = \"ldf\"]
17
1
11

MONITOR
1738
160
1804
205
SME
count firms with [my-type = \"sme\"]
17
1
11

MONITOR
1738
70
1804
115
IMD
count intermediaries
17
1
11

MONITOR
1738
25
1804
70
INS
count institutes
17
1
11

MONITOR
1738
250
1804
295
ENT
count entrepreneurs
17
1
11

MONITOR
1949
115
2014
160
LDF-I-net
count firms with [(my-type = \"ldf\") and ((any? my-I-partners) or (any? my-previous-I-partners))]
17
1
11

MONITOR
1949
160
2014
205
SME-I-net
count firms with [(my-type = \"sme\") and ((any? my-I-partners) or (any? my-previous-I-partners))]
17
1
11

MONITOR
1949
70
2014
115
IMD-I-net
count intermediaries with [(any? my-I-partners) or (any? my-previous-I-partners)]
17
1
11

MONITOR
1949
25
2014
70
INS-I-net
count institutes with [(any? my-I-partners) or (any? my-previous-I-partners)]
17
1
11

MONITOR
1949
250
2014
295
ENT-I-net
count entrepreneurs with [(any? my-I-partners) or (any? my-previous-I-partners)]
17
1
11

MONITOR
2173
152
2303
197
Research Networks
array:item __P__projects-count 1
17
1
11

MONITOR
2173
197
2238
242
Avg. Size
round (10 * mean (array:item __P__projects-size 1)) / 10
17
1
11

MONITOR
2303
152
2369
197
% with SME
round (1000 * (array:item __P__projects-with-SME-count 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2173
242
2238
287
Avg. Capital
round (10 * mean (array:item __P__projects-contribution 1)) / 10
17
1
11

MONITOR
2238
197
2303
242
% Small (<5)
round (1000 * length filter [? < 5] (array:item __P__projects-size 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
197
2369
242
% Large (>25)
round (1000 * length filter [? > 25] (array:item __P__projects-size 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2238
242
2303
287
% Poor (<1)
round (1000 * length filter [? < 1] (array:item __P__projects-contribution 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
242
2369
287
% Rich (>10)
round (1000 * length filter [? > 10] (array:item __P__projects-contribution 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2173
287
2238
332
Avg. Duration
round (10 * mean (array:item __P__projects-duration 1)) / 10
17
1
11

MONITOR
2238
287
2303
332
% Short (<2)
round (1000 * length filter [? < 2] (array:item __P__projects-duration 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
287
2369
332
% Long (>5)
round (1000 * length filter [? > 5] (array:item __P__projects-duration 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2369
152
2435
197
% International
;round (1000 * (array:item P:projects-intl-count 0) / (array:item P:projects-count 0)) / 10\n\"N/A\"
17
1
11

MONITOR
2369
197
2435
242
% National
\"N/A\"
17
1
11

MONITOR
2369
353
2435
398
% International
;round (1000 * (array:item P:projects-intl-count 1) / (array:item P:projects-count 1)) / 10\n\"N/A\"
17
1
11

MONITOR
2369
398
2435
443
% National
\"N/A\"
17
1
11

MONITOR
2369
242
2435
287
% Regional
\"N/A\"
17
1
11

MONITOR
2369
443
2435
488
% Regional
\"N/A\"
17
1
11

MONITOR
2014
115
2080
160
LDF-T-net
count firms with [(my-type = \"ldf\") and ((any? my-T-partners) or (any? my-previous-T-partners))]
17
1
11

MONITOR
2014
160
2080
205
SME-T-net
count firms with [(my-type = \"sme\") and ((any? my-T-partners) or (any? my-previous-T-partners))]
17
1
11

MONITOR
2014
70
2080
115
IMD-T-net
count intermediaries with [(any? my-T-partners) or (any? my-previous-T-partners)]
17
1
11

MONITOR
2014
25
2080
70
INS-T-net
count institutes with [(any? my-T-partners) or (any? my-previous-T-partners)]
17
1
11

MONITOR
2014
250
2080
295
ENT-T-net
count entrepreneurs with [(any? my-T-partners) or (any? my-previous-T-partners)]
17
1
11

MONITOR
2173
353
2303
398
Innovation Networks
array:item __P__projects-count 1
17
1
11

MONITOR
2173
398
2238
443
Avg. Size
round (10 * mean (array:item __P__projects-size 1)) / 10
17
1
11

MONITOR
2173
443
2238
488
Avg. Capital
round (10 * mean (array:item __P__projects-contribution 1)) / 10
17
1
11

MONITOR
1738
205
1804
250
SUP
count firms with [my-type = \"sup\"]
17
1
11

MONITOR
1949
205
2014
250
SUP-I-net
count firms with [(my-type = \"sup\") and ((any? my-I-partners) or (any? my-previous-I-partners))]
17
1
11

MONITOR
2014
205
2080
250
SUP-T-net
count firms with [(my-type = \"sup\") and ((any? my-T-partners) or (any? my-previous-T-partners))]
17
1
11

MONITOR
1884
70
1949
115
IMD-R-net
count intermediaries with [(any? my-R-partners) or (any? my-previous-R-partners)]
17
1
11

MONITOR
1884
25
1949
70
INS-R-net
count institutes with [(any? my-R-partners) or (any? my-previous-R-partners)]
17
1
11

MONITOR
1884
115
1949
160
LDF-R-net
count firms with [(my-type = \"ldf\") and ((any? my-R-partners) or (any? my-previous-R-partners))]
17
1
11

MONITOR
1884
160
1949
205
SME-R-net
count firms with [(my-type = \"sme\") and ((any? my-R-partners) or (any? my-previous-R-partners))]
17
1
11

MONITOR
1884
205
1949
250
SUP-R-net
count firms with [(my-type = \"sup\") and ((any? my-R-partners) or (any? my-previous-R-partners))]
17
1
11

MONITOR
1884
250
1949
295
ENT-R-net
count entrepreneurs with [(any? my-R-partners) or (any? my-previous-R-partners)]
17
1
11

MONITOR
2369
287
2435
332
% Local
\"N/A\"
17
1
11

MONITOR
2303
353
2369
398
% with SME
round (1000 * (array:item __P__projects-with-SME-count 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2238
398
2303
443
% Small (<5)
round (1000 * length filter [? < 5] (array:item __P__projects-size 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
398
2369
443
% Large (> 25)
round (1000 * length filter [? > 25] (array:item __P__projects-size 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2238
443
2303
488
% Poor (<1)
round (1000 * length filter [? < 1] (array:item __P__projects-contribution 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
443
2369
488
% Rich (>10)
round (1000 * length filter [? > 10] (array:item __P__projects-contribution 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2173
488
2238
533
Avg. Duration
round (10 * mean (array:item __P__projects-duration 1)) / 10
17
1
11

MONITOR
2238
488
2303
533
% Short (<2)
round (1000 * length filter [? < 2] (array:item __P__projects-duration 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2303
488
2369
533
% Long (>5)
round (1000 * length filter [? > 5] (array:item __P__projects-duration 1) / (array:item __P__projects-count 1)) / 10
17
1
11

MONITOR
2369
488
2435
533
% Local
\"N/A\"
17
1
11

MONITOR
2173
753
2303
798
Entrepren. Networks
array:item __P__projects-count 3
17
1
11

MONITOR
2303
753
2369
798
% with SME
round (1000 * (array:item __P__projects-with-SME-count 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2173
798
2238
843
Avg. Size
round (10 * mean (array:item __P__projects-size 3)) / 10
17
1
11

MONITOR
2238
798
2303
843
% Small (<5)
round (1000 * length filter [? < 5] (array:item __P__projects-size 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2303
798
2369
843
% Large (>25)
round (1000 * length filter [? > 25] (array:item __P__projects-size 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2173
843
2238
888
Avg. Capital
round (10 * mean (array:item __P__projects-contribution 3)) / 10
17
1
11

MONITOR
2238
843
2303
888
% Poor (<1)
round (1000 * length filter [? < 1] (array:item __P__projects-contribution 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2303
843
2369
888
% Rich (>10)
round (1000 * length filter [? > 10] (array:item __P__projects-contribution 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2173
888
2238
933
Avg. Duration
round (10 * mean (array:item __P__projects-duration 3)) / 10
17
1
11

MONITOR
2238
888
2303
933
% Short (<2)
round (1000 * length filter [? < 2] (array:item __P__projects-duration 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2303
888
2369
933
% Long (>5)
round (1000 * length filter [? > 5] (array:item __P__projects-duration 3) / (array:item __P__projects-count 3)) / 10
17
1
11

MONITOR
2369
753
2435
798
% International
;round (1000 * (array:item P:projects-intl-count 3) / (array:item P:projects-count 3)) / 10\n\"N/A\"
17
1
11

MONITOR
2369
798
2435
843
% National
\"N/A\"
17
1
11

MONITOR
2369
843
2435
888
% Regional
\"N/A\"
17
1
11

MONITOR
2369
888
2435
933
% Local
\"N/A\"
17
1
11

SWITCH
2473
151
2627
184
R-Networks?
R-Networks?
0
1
-1000

SWITCH
2473
184
2627
217
I-Networks?
I-Networks?
1
1
-1000

SWITCH
2473
250
2627
283
E-Networks?
E-Networks?
1
1
-1000

SWITCH
2473
283
2627
316
Transactions?
Transactions?
1
1
-1000

CHOOSER
616
777
808
822
Model-settings
Model-settings
"manual" "R-networks" "I-networks" "T-networks" "E-networks" "Transactions" "all"
1

MONITOR
836
54
893
99
Call
[call-nr] of __P__the-current-call
17
1
11

MONITOR
1007
54
1063
99
Status
__U__show-call-status [call-nr] of __P__the-current-call
17
1
11

MONITOR
950
54
1007
99
Deadline
[call-deadline] of __P__the-current-call
17
1
11

MONITOR
836
99
893
144
Funding
[call-funding] of __P__the-current-call
17
1
11

MONITOR
950
99
1007
144
RPAs
;[call-themes] of P:the-current-call\n\"N/A\"
17
1
11

MONITOR
893
99
950
144
Orientation
[call-orientation] of __P__the-current-call
17
1
11

MONITOR
1007
99
1063
144
Cap. Range
[call-cap-range] of __P__the-current-call
17
1
11

PLOT
836
177
1063
303
Submitted Proposals
Time (months)
Count
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"BM" 1.0 0 -11221820 true "" ""
"EC" 1.0 0 -13791810 true "" ""

PLOT
836
303
1063
429
Started Projects
Time (Months)
Count
0.0
180.0
0.0
30.0
true
false
"" ""
PENS
"BM" 1.0 0 -11221820 true "" ""
"EC" 1.0 0 -13791810 true "" ""

PLOT
836
429
1063
555
Project Outputs
Time (Months)
Count
0.0
180.0
0.0
30.0
true
false
"" ""
PENS
"Publications" 1.0 0 -2064490 true "" ""
"Patents" 1.0 0 -5825686 true "" ""

PLOT
836
555
1063
681
Participation in Proposals
Number of Proposals
Freq.
1.0
20.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
836
681
1063
807
Participation in Projects
Number of Projects
Freq.
1.0
20.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
836
807
1063
933
Research Partners
Number of Partners
Freq.
1.0
75.0
0.0
20.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
1297
786
1502
933
Sales
Time (Months)
Value
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"Sales" 1.0 0 -7500403 true "" ""
"Profits" 1.0 0 -2674135 true "" ""
"Net Profits" 1.0 0 -955883 true "" ""

PLOT
1290
962
1517
1092
Size of Largest Component
Time (Months)
NIL
0.0
180.0
0.0
100.0
true
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

PLOT
1971
962
2198
1092
Clustering
Time (Months)
NIL
0.0
180.0
0.5
1.0
false
false
"" ""
PENS
"" 1.0 0 -13345367 true "" ""

CHOOSER
616
633
808
678
Calls-settings
Calls-settings
"manual" "Baseline"
0

MONITOR
9
550
167
595
Calls-settings
Calls-settings
17
1
11

TEXTBOX
46
70
174
154
research institutes\n(extra-university, other)\n\nlarge diversified firms\n\n\"Mittelstand\"
10
3.0
1

TEXTBOX
10
70
39
154
INS\n\n\nLDF\n\nSME\n
10
3.0
1

SLIDER
245
583
343
616
Funding-calls-EC
Funding-calls-EC
0
10
1
1
1
NIL
HORIZONTAL

SLIDER
343
583
441
616
Orientation-calls-EC
Orientation-calls-EC
0
10
7
1
1
NIL
HORIZONTAL

SWITCH
616
324
808
357
Empirical-case?
Empirical-case?
0
1
-1000

CHOOSER
616
402
808
447
Instruments-filter
Instruments-filter
"none" "CP-#" "CSA-#" "ERC-#" "MC-#" "other" "all"
1

TEXTBOX
193
350
218
368
BM
11
0.0
1

TEXTBOX
193
382
218
400
EC
11
0.0
1

SLIDER
343
334
441
367
Contribution-BM
Contribution-BM
0
50000
15000
1
1
NIL
HORIZONTAL

SLIDER
2197
962
2230
1092
Network-update-interval
Network-update-interval
0
200
180
1
1
NIL
VERTICAL

SLIDER
343
366
441
399
Contribution-EC
Contribution-EC
0
50000
10000
1
1
NIL
HORIZONTAL

CHOOSER
616
678
808
723
Other-settings
Other-settings
"manual" "Baseline"
0

SLIDER
2473
587
2627
620
Survival-threshold
Survival-threshold
0
1
0.2
0.01
1
NIL
HORIZONTAL

SLIDER
2647
554
2801
587
nProducts
nProducts
0
100
100
1
1
NIL
HORIZONTAL

SLIDER
2647
587
2801
620
nInputs
nInputs
3
6
6
1
1
NIL
HORIZONTAL

CHOOSER
2647
327
2801
372
Partnership-strategy
Partnership-strategy
"no partners" "conservative" "progressive"
1

SLIDER
2647
381
2801
414
Attractiveness-threshold
Attractiveness-threshold
0
1
0.2
0.1
1
NIL
HORIZONTAL

MONITOR
893
54
950
99
Type
[call-type] of __P__the-current-call
17
1
11

PLOT
1738
367
1942
503
Transfer Capacity
Time (months)
Count
0.0
180.0
0.0
10.0
true
false
"" ""
PENS

PLOT
1942
367
2146
503
Transfer Performance
Size
Freq.
0.0
50.0
0.0
10.0
true
false
"" ""
PENS

PLOT
1738
503
1942
639
Participation in Transfer
Number of Networks
Freq.
1.0
20.0
0.0
100.0
true
false
"" ""
PENS

PLOT
1942
503
2146
639
Transfer Partners
Time (months)
Count
0.0
10.0
0.0
10.0
true
false
"" ""
PENS

TEXTBOX
10
390
43
533
BM\n\n\nEC\n\n\nCR\n\nPL\n\nSO
10
3.0
1

TEXTBOX
46
390
171
533
research funded by the\nGerman ministeries\n\nresearch funded by the\nEC (FP7, H2020)\n\ncontract research\n\npatenting / licensing\n\nspin-offs
10
3.0
1

SLIDER
2647
447
2801
480
Success-threshold
Success-threshold
0
1000
800
1
1
NIL
HORIZONTAL

SLIDER
2647
414
2801
447
Reward-to-trigger-start-up
Reward-to-trigger-start-up
0
2000
1250
1
1
NIL
HORIZONTAL

SWITCH
2647
85
2801
118
Adj-expertise?
Adj-expertise?
1
1
-1000

SWITCH
2647
251
2801
284
Adj-price?
Adj-price?
1
1
-1000

SWITCH
2647
119
2801
152
Inc-research?
Inc-research?
1
1
-1000

SWITCH
2647
152
2801
185
Rad-research?
Rad-research?
1
1
-1000

SWITCH
2647
185
2801
218
Partnering?
Partnering?
1
1
-1000

SWITCH
2647
218
2801
251
Networking?
Networking?
1
1
-1000

SWITCH
2647
283
2801
316
Start-ups?
Start-ups?
1
1
-1000

TEXTBOX
1738
10
1809
28
POPULATION
9
3.0
1

TEXTBOX
1094
38
1236
56
INSTITUTES: METABOLISM
9
3.0
1

TEXTBOX
2173
136
2283
154
NETWORKS (R/I/T/E)
9
3.0
1

TEXTBOX
838
38
881
56
CALL
9
3.0
1

TEXTBOX
838
946
948
964
NETWORK MEASURES
9
3.0
1

MONITOR
2473
25
2627
70
Model-settings
Model-settings
17
1
11

PLOT
2003
1124
2230
1254
Knowledge Distance
Distance
Freq.
0.0
10.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

SLIDER
616
447
808
480
Cutoff-point
Cutoff-point
0
10
0
1
1
NIL
HORIZONTAL

TEXTBOX
1094
254
1266
272
INNOVATION/MARKET DYNAMICS
9
3.0
1

TEXTBOX
838
161
1003
179
RESEARCH PROPOSALS/PROJECTS
9
3.0
1

MONITOR
9
637
167
682
Other-settings
Other-settings
17
1
11

SLIDER
245
637
343
670
Funding
Funding
0
10000
3500
1
1
NIL
HORIZONTAL

MONITOR
2473
529
2627
574
System-settings
0
17
1
11

MONITOR
2647
25
2801
70
Firms-settings
0
17
1
11

MONITOR
2647
496
2801
541
Market-settings
0
17
1
11

TEXTBOX
1738
351
1866
369
TECHNOLOGY TRANSFER
9
3.0
1

TEXTBOX
838
1107
960
1125
KNOWLEDGE MEASURES
9
3.0
1

TEXTBOX
193
599
218
617
EC
11
0.0
1

SLIDER
245
334
343
367
Match-BM
Match-BM
0
100
18
1
1
NIL
HORIZONTAL

SLIDER
245
366
343
399
Match-EC
Match-EC
0
100
15
1
1
NIL
HORIZONTAL

BUTTON
616
723
680
756
manual
__U__set-all-settings \"manual\"
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
680
723
744
756
Baseline
__U__set-all-settings \"Baseline\"
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
744
723
808
756
Show
__U__show-current-settings
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

OUTPUT
9
691
539
907
11

SWITCH
2473
85
2627
118
System?
System?
1
1
-1000

TEXTBOX
2450
160
2466
178
2.1
9
3.0
1

TEXTBOX
2450
196
2466
214
2.2
9
3.0
1

TEXTBOX
2450
293
2466
311
3
9
3.0
1

TEXTBOX
2450
323
2466
341
4
9
3.0
1

MONITOR
2080
70
2146
115
IMD-E-net
count intermediaries with [(any? my-E-partners) or (any? my-previous-E-partners)]
17
1
11

MONITOR
2080
25
2146
70
INS-E-net
count institutes with [(any? my-E-partners) or (any? my-previous-E-partners)]
17
1
11

MONITOR
2080
115
2146
160
LDF-E-net
count firms with [(my-type = \"ldf\") and ((any? my-E-partners) or (any? my-previous-E-partners))]
17
1
11

MONITOR
2080
160
2146
205
SME-E-net
count firms with [(my-type = \"sme\") and ((any? my-E-partners) or (any? my-previous-E-partners))]
17
1
11

MONITOR
2080
205
2146
250
SUP-E-net
count firms with [(my-type = \"sup\") and ((any? my-E-partners) or (any? my-previous-E-partners))]
17
1
11

MONITOR
2080
250
2146
295
ENT-E-net
count entrepreneurs with [(any? my-E-partners) or (any? my-previous-E-partners)]
17
1
11

MONITOR
1804
70
1870
115
IMD-net
count intermediaries with [_in-net? = true]
17
1
11

MONITOR
1804
25
1870
70
INS-net
count institutes with [_in-net? = true]
17
1
11

MONITOR
1804
115
1870
160
LDF-net
count firms with [(my-type = \"ldf\") and (_in-net? = true)]
17
1
11

MONITOR
1804
160
1870
205
SME-net
count firms with [(my-type = \"sme\") and (_in-net? = true)]
17
1
11

MONITOR
1804
205
1870
250
SUP-net
count firms with [(my-type = \"sup\") and (_in-net? = true)]
17
1
11

MONITOR
1804
250
1870
295
ENT-net
count entrepreneurs with [_in-net? = true]
17
1
11

MONITOR
2173
552
2303
597
Tech Transf. Networks
array:item __P__projects-count 2
17
1
11

MONITOR
2303
552
2369
597
% with SME
round (1000 * (array:item __P__projects-with-SME-count 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2173
597
2238
642
Avg. Size
round (10 * mean (array:item __P__projects-size 2)) / 10
17
1
11

MONITOR
2238
597
2303
642
% Small (<5)
round (1000 * length filter [? < 5] (array:item __P__projects-size 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2303
597
2369
642
% Large (> 25)
round (1000 * length filter [? > 25] (array:item __P__projects-size 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2173
642
2238
687
Avg. Capital
round (10 * mean (array:item __P__projects-contribution 2)) / 10
17
1
11

MONITOR
2238
642
2303
687
% Poor (<1)
round (1000 * length filter [? < 1] (array:item __P__projects-contribution 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2303
642
2369
687
% Rich (>10)
round (1000 * length filter [? > 10] (array:item __P__projects-contribution 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2173
687
2238
732
Avg. Duration
round (10 * mean (array:item __P__projects-duration 2)) / 10
17
1
11

MONITOR
2238
687
2303
732
% Short (<2)
round (1000 * length filter [? < 2] (array:item __P__projects-duration 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2303
687
2369
732
% Long (> 5)
round (1000 * length filter [? > 5] (array:item __P__projects-duration 2) / (array:item __P__projects-count 2)) / 10
17
1
11

MONITOR
2369
552
2435
597
% International
;round (1000 * (array:item P:projects-intl-count 2) / (array:item P:projects-count 2)) / 10\n\"N/A\"
17
1
11

MONITOR
2369
597
2435
642
% National
\"N/A\"
17
1
11

MONITOR
2369
642
2435
687
% Regional
\"N/A\"
17
1
11

MONITOR
2369
687
2435
732
% Local
\"N/A\"
17
1
11

SWITCH
2473
217
2627
250
T-Networks?
T-Networks?
1
1
-1000

TEXTBOX
2450
260
2466
278
2.4
9
3.0
1

TEXTBOX
2450
227
2466
245
2.3
9
3.0
1

TEXTBOX
1738
646
1843
664
ENTREPRENEURSHIP
9
3.0
1

TEXTBOX
193
481
218
499
SO
11
0.0
1

SLIDER
616
240
808
273
Base-year
Base-year
2000
2022
2006
1
1
NIL
HORIZONTAL

PLOT
836
1282
1063
1412
Proposal Size
Size of Consortia
Freq.
1.0
40.0
0.0
20.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

PLOT
1063
1282
1290
1412
Project Size
Size of Consortia
Freq.
1.0
40.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

TEXTBOX
838
1266
997
1284
PROPOSAL/PROJECT MEASURES
9
3.0
1

SLIDER
245
465
343
498
Match-SO
Match-SO
0
100
15
1
1
NIL
HORIZONTAL

SLIDER
343
465
441
498
Contribution-SO
Contribution-SO
0
50000
1000
1
1
NIL
HORIZONTAL

SLIDER
245
399
343
432
Match-CR
Match-CR
0
100
15
1
1
NIL
HORIZONTAL

SLIDER
343
399
441
432
Contribution-CR
Contribution-CR
0
100
10000
1
1
NIL
HORIZONTAL

TEXTBOX
193
414
218
432
CR
11
0.0
1

PLOT
836
1124
1549
1254
Knowledge Space
NIL
NIL
0.0
1000.0
0.0
10.0
true
false
"" ""
PENS
"default" 1.0 1 -5987164 true "" ""

TEXTBOX
2173
10
2319
28
RESEARCH ORGANISATIONS
9
3.0
1

MONITOR
2173
25
2238
70
ORG
count institutes with [\n  (my-org-type = \"fhg\") or\n  (my-org-type = \"hgf\") or\n  (my-org-type = \"wgl\") or\n  (my-org-type = \"mpg\")\n]
17
1
11

MONITOR
2370
25
2435
70
OTH
count institutes with [my-org-type = \"oth\"]
17
1
11

MONITOR
2238
25
2304
70
UNI
count institutes with [my-type = \"uni\"]
17
1
11

MONITOR
2304
25
2370
70
CTR
count institutes with [my-type = \"ctr\"]
17
1
11

SLIDER
441
583
539
616
Range-calls-EC
Range-calls-EC
0
100
35
1
1
NIL
HORIZONTAL

CHOOSER
616
867
808
912
Log-settings
Log-settings
"none (fastest)" "model (default)" "all" "debug"
1

SLIDER
245
432
343
465
Match-PL
Match-PL
0
100
15
1
1
NIL
HORIZONTAL

SLIDER
343
432
441
465
Contribution-PL
Contribution-PL
0
100
1000
1
1
NIL
HORIZONTAL

TEXTBOX
193
448
218
466
PL
11
0.0
1

SLIDER
245
550
343
583
Funding-calls-BM
Funding-calls-BM
0
100
3
1
1
NIL
HORIZONTAL

SLIDER
343
550
441
583
Orientation-calls-BM
Orientation-calls-BM
0
100
5
1
1
NIL
HORIZONTAL

SLIDER
441
550
539
583
Range-calls-BM
Range-calls-BM
0
100
35
1
1
NIL
HORIZONTAL

TEXTBOX
193
566
218
584
BM
11
0.0
1

SWITCH
2473
316
2627
349
Valuations?
Valuations?
0
1
-1000

MONITOR
1738
295
1804
340
OTH
count other-agents
17
1
11

MONITOR
1804
295
1870
340
OTH-net
count other-agents with [_in-net? = true]
17
1
11

MONITOR
1884
295
1949
340
OTH-R-net
count other-agents with [(any? my-R-partners) or (any? my-previous-R-partners)]
17
1
11

MONITOR
1949
295
2014
340
OTH-I-net
count other-agents with [(any? my-I-partners) or (any? my-previous-I-partners)]
17
1
11

MONITOR
2014
295
2080
340
OTH-T-net
count other-agents with [(any? my-T-partners) or (any? my-previous-T-partners)]
17
1
11

MONITOR
2080
295
2146
340
OTH-E-net
count other-agents with [(any? my-E-partners) or (any? my-previous-E-partners)]
17
1
11

PLOT
836
1600
1063
1730
SCI Score C1
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1063
1600
1290
1730
SCI Score C2
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1290
1600
1517
1730
SCI Score C3
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1517
1600
1744
1730
SCI Total Score C
Total Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

TEXTBOX
838
1584
973
1602
INSTITUTES: SCI/EI SCORES
9
3.0
1

PLOT
836
1730
1063
1860
SCI Score P1
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1063
1730
1290
1860
SCI Score P2
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1290
1730
1517
1860
SCI Score P3
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
1517
1730
1744
1860
SCI Total Score P
Total Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -2674135 true "" ""

PLOT
836
1860
1063
1990
EI Score C1
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1063
1860
1290
1990
EI Score C2
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1290
1860
1517
1990
EI Score C3
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1517
1860
1744
1990
EI Total Score C
Total Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
836
1990
1063
2119
EI Score P1
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1063
1990
1290
2119
EI Score P2
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1290
1990
1517
2119
EI Score P3
Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

PLOT
1517
1990
1744
2119
EI Total Score P
Total Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -13791810 true "" ""

MONITOR
9
167
167
212
Institutes-settings
Institutes-settings
17
1
11

TEXTBOX
10
226
39
317
FhG\n\nHGF\n\nWGL\n\nMPG
10
3.0
1

TEXTBOX
46
226
126
317
Fraunhofer\n\nHelmholtz\n\nLeibniz\n\nMax Planck
10
3.0
1

SLIDER
343
167
441
200
Perc-EI-FhG
Perc-EI-FhG
0
1
0.2
0.01
1
NIL
HORIZONTAL

SLIDER
343
200
441
233
Perc-EI-HGF
Perc-EI-HGF
0
1
0.2
0.01
1
NIL
HORIZONTAL

SLIDER
343
233
441
266
Perc-EI-WGL
Perc-EI-WGL
0
1
0.2
0.01
1
NIL
HORIZONTAL

SLIDER
343
266
441
299
Perc-EI-MPG
Perc-EI-MPG
0
1
0.2
0.01
1
NIL
HORIZONTAL

TEXTBOX
193
183
221
201
FhG
11
0.0
1

TEXTBOX
193
217
221
235
HGF
10
0.0
1

TEXTBOX
193
249
221
267
WGL
11
0.0
1

TEXTBOX
193
282
221
300
MPG
11
0.0
1

CHOOSER
616
544
808
589
Institutes-settings
Institutes-settings
"manual" "Baseline"
0

PLOT
1744
1600
1971
1730
SCI/EI Total Score
Total Score
Freq.
0.0
100.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 1 -16777216 true "" ""

CHOOSER
616
822
808
867
Plot-settings
Plot-settings
"none (fastest)" "model (default)" "all"
1

MONITOR
2173
70
2238
115
FhG
count institutes with [my-org-type = \"fhg\"]
17
1
11

MONITOR
2238
70
2303
115
HGF
count institutes with [my-org-type = \"hgf\"]
17
1
11

MONITOR
2303
70
2369
115
WGL
count institutes with [my-org-type = \"wgl\"]
17
1
11

MONITOR
2369
70
2435
115
MPG
count institutes with [my-org-type = \"mpg\"]
17
1
11

CHOOSER
616
912
808
957
Export-settings
Export-settings
"none (fastest)" "model (default)" "all"
1

CHOOSER
616
357
808
402
Calls-filter
Calls-filter
"FP7-ICT-200#-#"
0

MONITOR
2473
360
2627
405
Institutes-settings
Institutes-settings
17
1
11

SLIDER
2473
414
2627
447
Infra-resources
Infra-resources
0
1
0.33
0.01
1
NIL
HORIZONTAL

SLIDER
2473
447
2627
480
Pooled-cap-ratio
Pooled-cap-ratio
0
1
0.15
0.01
1
NIL
HORIZONTAL

SLIDER
2473
480
2627
513
Cap-depreciation
Cap-depreciation
0
1
0.05
0.01
1
NIL
HORIZONTAL

SLIDER
245
167
343
200
Perc-SCI-FhG
Perc-SCI-FhG
0
1
0.8
0.01
1
NIL
HORIZONTAL

SLIDER
245
200
343
233
Perc-SCI-HGF
Perc-SCI-HGF
0
1
0.8
0.01
1
NIL
HORIZONTAL

SLIDER
245
233
343
266
Perc-SCI-WGL
Perc-SCI-WGL
0
1
0.8
0.01
1
NIL
HORIZONTAL

SLIDER
245
266
343
299
Perc-SCI-MPG
Perc-SCI-MPG
0
1
0.8
0.01
1
NIL
HORIZONTAL

SWITCH
2473
118
2627
151
Metabolism?
Metabolism?
1
1
-1000

TEXTBOX
838
1426
1093
1444
INSTITUTES: RESOURCE GENERATION & ALLOCATION
9
3.0
1

PLOT
1063
1441
1290
1571
Demand
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1517
1441
1744
1571
Price
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1290
1441
1517
1571
Output
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
1744
1441
1971
1571
Resources
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
836
1441
1063
1571
Funding
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

PLOT
609
1441
836
1571
Capacity
Time (months)
NIL
0.0
180.0
0.0
10.0
true
false
"" ""
PENS
"" 1.0 0 -16777216 true "" ""

BUTTON
609
1408
676
1441
Setup
#:setup
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
676
1408
743
1441
Go
#:go
T
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

BUTTON
743
1408
801
1441
Step
#:go
NIL
1
T
OBSERVER
NIL
NIL
NIL
NIL
1

TEXTBOX
2450
128
2470
146
1&5
9
3.0
1

TEXTBOX
2450
96
2466
114
0
9
3.0
1

@#$#@#$#@
## WHAT IS IT?

SKIN (Simulating Knowledge Dynamics in Innovation Networks) is a multi-agent model of innovation networks in knowledge-intensive industries grounded in empirical research and theoretical frameworks from innovation economics and economic sociology. The agents represent innovative firms who try to sell their innovations to other agents and end users but who also have to buy raw materials or more sophisticated inputs from other agents (or material suppliers) in order to produce their outputs. This basic model of a market is extended with a representation of the knowledge dynamics in and between the firms. Each firm tries to improve its innovation performance and its sales by improving its knowledge base through adaptation to user needs, incremental or radical learning, and co-operation and networking with other agents.

## HOW IT WORKS

The agents

The individual knowledge base of a SKIN agent, its kene, contains a number of �units of knowledge�. Each unit in a kene is represented as a triple consisting of a firm�s capability C in a scientific, technological or business domain, its ability A to perform a certain application in this field, and the expertise level E the firm has achieved with respect to this ability. The units of knowledge in the kenes of the agents can be used to describe their virtual knowledge bases.

The market

Because actors in empirical innovation networks of knowledge-intensive industries interact on both the knowledge and the market levels, there needs to be a representation of market dynamics in the SKIN model. Agents are therefore characterised by their capital stock. Each firm, when it is set up, has a stock of initial capital. It needs this capital to produce for the market and to finance its R&D expenditures; it can increase its capital by selling products. The amount of capital owned by a firm is used as a measure of its size and additionally influences the amount of knowledge (measured by the number of triples in its kene) that it can maintain.  Most firms are initially given the same starting capital allocation, but in order to model differences in firm size, a few randomly chosen firms can be allocated extra capital.

Firms apply their knowledge to create innovative products that have a chance of being successful in the market. The special focus of a firm, its potential innovation, is called an innovation hypothesis. In the model, the innovation hypothesis (IH) is derived from a subset of the firm�s kene triples.

The underlying idea for an innovation, modelled by the innovation hypothesis, is the source an agent uses for its attempts to make profits in the market. Because of the fundamental uncertainty of innovation, there is no simple relationship between the innovation hypothesis and product development. To represent this uncertainty,  the innovation hypothesis is transformed into a product through a mapping procedure where the capabilities of the innovation hypothesis are used to compute an index number that represents the product. The particular transformation procedure applied allows the same product to result from different kenes.

A firm�s product, P, is generated from its innovation hypothesis as



P = Sum (capability * ability) mod N

where N is a large constant and represents the notional total number of possible different products that could be present in the market).

A product has a certain quality, which is also computed from the innovation hypothesis in a similar way, by multiplying the abilities and the expertise levels for each triple in the innovation hypothesis and normalising the result. Whereas the abilities used to design a product can be used as a proxy for its product characteristics, the expertise of the applied abilities is an indicator of the potential product quality.

In order to realise the product, the agent needs some materials. These can either come from outside the sector (�raw materials�) or from other firms, which generated them as their products. Which materials are needed is again determined by the underlying innovation hypothesis: the kind of material required for an input is obtained by selecting subsets from the innovation hypotheses and applying the standard mapping function.

These inputs are chosen so that each is different and differs from the firm�s own product. In order to be able to engage in production, all the inputs need to be obtainable on the market, i.e. provided by other firms or available as raw materials. If the inputs are not available, the firm is not able to produce and has to give up this attempt to innovate. If there is more than one supplier for a certain input, the agent will choose the one at the cheapest price and, if there are several similar offers, the one with the highest quality.

If the firm can go into production, it has to find a price for its product, taking into account the input prices it is paying and a possible profit margin. While the simulation starts with product prices set at random, as the simulation proceeds a price adjustment mechanism following a standard mark-up pricing model increases the selling price if there is much demand, and reduces it (but no lower than the total cost of production) if there are no customers.  Some products are considered to be destined for the �end-user� and are sold to customers outside the sector: there is always a demand for such end-user products provided that they are offered at or below a fixed end-user price. A firm buys the requested inputs from its suppliers using its capital to do so, produces its output and puts it on the market for others to purchase. Using the price adjustment mechanism, agents are able to adapt their prices to demand and in doing so learn by feedback.

In making a product, an agent applies the knowledge in its innovation hypothesis and this increases its expertise in this area. This is the way that learning by doing/using is modelled. The expertise levels of the triples in the innovation hypothesis are increased and the expertise levels of the other triples are decremented. Expertise in unused triples in the kene is eventually lost and the triples are then deleted from the kene; the corresponding abilities are �forgotten�.

Thus, in trying to be successful on the market, firms are dependent on their innovation hypothesis, i.e. on their kene. If a product does not meet any demand, the firm has to adapt its knowledge in order to produce something else for which there are customers. A firm has several ways of improving its performance, either alone or in co-operation, and in either an incremental or a more radical fashion.

Learning and co-operation: improving innovation performance

In the SKIN model, firms may engage in single- and double-loop learning activities. Firm agents can:
*	use their capabilities (learning by doing/using) and learn to estimate their success via feedback from markets and clients (learning by feedback) as already mentioned above and/or
*	improve their own knowledge incrementally when the feedback is not satisfactory in order to adapt to changing technological and/or economic standards (adaptation learning, incremental learning).

If a firm�s previous innovation has been successful, i.e. it has found buyers, the firm will continue selling the same product in the next round, possibly at a different price depending on the demand it has experienced. However, if there were no sales, it considers that it is time for change. If the firm still has enough capital, it will carry out �incremental� research (R&D in the firm�s labs). Performing incremental research means that a firm tries to improve its product by altering one of the abilities chosen from the triples in its innovation hypothesis, while sticking to its focal capabilities. The ability in each triple is considered to be a point in the respective capability�s action space. To move in the action space means to go up or down by an increment, thus allowing for two possible �research directions�.

Alternatively, firms can radically change their capabilities in order to meet completely different client requirements (innovative learning, radical learning). A SKIN firm agent under serious pressure and in danger of becoming bankrupt, will turn to more radical measures, by exploring a completely different area of market opportunities. In the model, an agent under financial pressure turns to a new innovation hypothesis after first �inventing� a new capability for its kene. This is done by randomly replacing a capability in the kene with a new one and then generating a new innovation hypothesis.

An agent in the model may consider partnerships (alliances, joint ventures etc.) in order to exploit external knowledge sources. The decision whether and with whom to co-operate is based on the mutual observations of the firms, which estimate the chances and requirements coming from competitors, possible and past partners, and clients.  In the SKIN model, a marketing feature provides the information that a firm can gather about other agents: to advertise its product, a firm publishes the capabilities used in its innovation hypothesis. Those capabilities not included in its innovation hypothesis and thus in its product are not visible externally and cannot be used to select the firm as a partner. The firm�s �advertisement� is then the basis for decisions by other firms to form or reject co-operative arrangements.

In experimenting with the model, one can choose between two different partner search strategies, both of which compare the firm�s own capabilities as used in its innovation hypothesis and the possible partner�s capabilities as seen in its advertisement. Applying the conservative strategy, a firm will be attracted to a partner that has similar capabilities; using a progressive strategy the attraction is based on the difference between the capability sets.

To find a partner, the firm will look at previous partners first, then at its suppliers, customers and finally at all others. If there is a firm sufficiently attractive according to the chosen search strategy (i.e. with attractiveness above the �attractiveness threshold�), it will stop its search and offer a partnership. If the potential partner wishes to return the partnership offer, the partnership is set up.

The model assumes that partners learn only about the knowledge being actively used by the other agent. Thus, to learn from a partner, a firm will add the triples of the partner�s innovation hypothesis to its own. For capabilities that are new to it, the expertise levels of the triples taken from the partner are reduced in order to mirror the difficulty of integrating external knowledge as stated in empirical learning research.  For partner�s capabilities that are already known to it, if the partner has a higher expertise level, the firm will drop its own triple in favour of the partner�s one; if the expertise level of a similar triple is lower, the firm will stick to its own version. Once the knowledge transfer has been completed, each firm continues to produce its own product, possibly with greater expertise as a result of acquiring skills from its partner.

If the firm�s last innovation was successful, i.e. the value of its profit in the previous round was above a threshold, and the firm has some partners at hand, it can initiate the formation of a network. This can increase its profits because the network will try to create innovations as an autonomous agent in addition to those created by its members and will distribute any rewards back to its members who, in the meantime, can continue with their own attempts, thus providing a double chance for profits. Networks are �normal� agents, i.e. they get the same amount of initial capital as other firms and can engage in all the activities available to other firms. The kene of a network is the union of the triples from the innovation hypotheses of all its participants. If a network is successful it will distribute any earnings above the amount of the initial capital to its members; if it fails and becomes bankrupt, it will be dissolved.

Start-ups

If a sector is successful, new firms will be attracted into it. This is modelled by adding a new firm to the population when any existing firm makes a substantial profit. The new firm is a clone of the successful firm, but with its kene triples restricted to those in the successful firm�s advertisement and these having a low expertise level. This models a new firm copying the characteristics of those seen to be successful in the market. As with all firms, the kene may also be restricted because the initial capital of a start-up is limited and may not be sufficient to support the copying of the whole of the successful firm�s innovation hypothesis.



## REFERENCES

More information about SKIN and research based on it can be found at: http://cress.soc.surrey.ac.uk/skin/home

The following papers describe the model and how it has been used by its originators:

Gilbert, Nigel, Pyka, Andreas, & Ahrweiler, Petra. (2001b). Innovation networks - a simulation approach. Journal of Artificial Societies and Social Simulation, 4(3)8, <http://www.soc.surrey.ac.uk/JASSS/4/3/8.html>.

Vaux, Janet, & Gilbert, Nigel. (2003). Innovation networks by design: The case of the mobile VCE. In A. Pyka & G. K�ppers (Eds.), Innovation networks: Theory and practice. Cheltenham: Edward Elgar.

Pyka, Andreas, Gilbert, Nigel, & Ahrweiler, Petra. (2003). Simulating innovation networks. In A. Pyka & G. K�ppers; (Eds.), Innovation networks: Theory and practice. Cheltenham: Edward Elgar.

Ahrweiler, Petra, Pyka, Andreas, & Gilbert, Nigel. (2004). Simulating knowledge dynamics in innovation networks (SKIN). In R. Leombruni & M. Richiardi (Eds.),Industry and labor dynamics: The agent-based computational economics approach. Singapore: World Scientific Press.

Ahrweiler, Petra, Pyka, Andreas & Gilbert, Nigel. (2004), Die Simulation von Lernen in Innovationsnetzwerken, in: Michael Florian und Frank Hillebrandt (eds.): Adaption und Lernen in und von Organisationen. VS-Verlag f�r Sozialwissenschaften, Opladen 2004, 165-186.

Pyka, A. (2006), Modelling Qualitative Development. Agent Based Approaches in Economics, in: Rennard, J.-P. (Hrsg.), Handbook of Research on Nature Inspired Computing for Economy and Management, Idea Group Inc., Hershey, USA, 211-224.

Gilbert, Nigel, Ahrweiler, Petra, & Pyka, Andreas. (2007). Learning in innovation networks: Some simulation experiments. Physica A, 378, 100-109.

Pyka, Andreas, Gilbert, Nigel, & Ahrweiler, Petra. (2007). Simulating knowledge-generation and distribution processes in innovation collaborations and networks. Cybernetics and Systems, 38 (7), 667-693.

Pyka, Andreas, Gilbert, Nigel & Petra Ahrweiler (2009), Agent-Based Modelling of Innovation Networks � The Fairytale of Spillover, in: Pyka, A. and Scharnhorst, A. (eds.), Innovation Networks � New Approaches in Modelling and Analyzing, Springer: Complexity, Heidelberg and New York, 101-126.

Gilbert, N., P. Ahrweiler and A. Pyka (2010): Learning in Innovation Networks: some Simulation Experiments. In P. Ahrweiler, (ed.) : Innovation in complex social systems. London: Routledge (Reprint from Physica A, 2007), pp. 235-249.

Scholz, R., T. Nokkala, P. Ahrweiler, A. Pyka and N. Gilbert (2010): The agent-based Nemo Model (SKEIN) � simulating European Framework Programmes. In P. Ahrweiler (ed.): Innovation in complex social systems. London: Routledge, pp. 300-314.

Ahrweiler, P., A. Pyka and N. Gilbert (forthcoming): A new Model for University-Industry Links in knowledge-based Economies. Journal of Product Innovation Management.

Ahrweiler, P., N. Gilbert and A. Pyka (2010): Agency and Structure. A social simulation of knowledge-intensive Industries. Computational and Mathematical Organization Theory (forthcoming).

## CREDITS

To cite the SKIN model please use the following acknowledgement:

Gilbert, Nigel, Ahrweiler, Petra and Pyka, Andreas (2010) The SKIN (Simulating Knowledge Dynamics in Innovation Networks) model.  University of Surrey, University College Dublin and University of Hohenheim.

Copyright 2003 - 2010 Nigel Gilbert, Petra Ahrweiler and Andreas Pyka. All rights reserved.

Permission to use, modify or redistribute this model is hereby granted, provided that both of the following requirements are followed: a) this copyright notice is included. b) this model will not be redistributed for profit without permission and c) the requirements of the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License <http://creativecommons.org/licenses/by-nc-sa/3.0/> are complied with.

The authors gratefully acknowldge funding during the course of development of the model from the European Commission, DAAD, and the British Council.
@#$#@#$#@
default
true
0
Polygon -7500403 true true 150 5 40 250 150 205 260 250

airplane
true
0
Polygon -7500403 true true 150 0 135 15 120 60 120 105 15 165 15 195 120 180 135 240 105 270 120 285 150 270 180 285 210 270 165 240 180 180 285 195 285 165 180 105 180 60 165 15

arrow
true
0
Polygon -7500403 true true 150 0 0 150 105 150 105 293 195 293 195 150 300 150

box
false
0
Polygon -7500403 true true 150 285 285 225 285 75 150 135
Polygon -7500403 true true 150 135 15 75 150 15 285 75
Polygon -7500403 true true 15 75 15 225 150 285 150 135
Line -16777216 false 150 285 150 135
Line -16777216 false 150 135 15 75
Line -16777216 false 150 135 285 75

bug
true
0
Circle -7500403 true true 96 182 108
Circle -7500403 true true 110 127 80
Circle -7500403 true true 110 75 80
Line -7500403 true 150 100 80 30
Line -7500403 true 150 100 220 30

butterfly
true
0
Polygon -7500403 true true 150 165 209 199 225 225 225 255 195 270 165 255 150 240
Polygon -7500403 true true 150 165 89 198 75 225 75 255 105 270 135 255 150 240
Polygon -7500403 true true 139 148 100 105 55 90 25 90 10 105 10 135 25 180 40 195 85 194 139 163
Polygon -7500403 true true 162 150 200 105 245 90 275 90 290 105 290 135 275 180 260 195 215 195 162 165
Polygon -16777216 true false 150 255 135 225 120 150 135 120 150 105 165 120 180 150 165 225
Circle -16777216 true false 135 90 30
Line -16777216 false 150 105 195 60
Line -16777216 false 150 105 105 60

car
false
0
Polygon -7500403 true true 300 180 279 164 261 144 240 135 226 132 213 106 203 84 185 63 159 50 135 50 75 60 0 150 0 165 0 225 300 225 300 180
Circle -16777216 true false 180 180 90
Circle -16777216 true false 30 180 90
Polygon -16777216 true false 162 80 132 78 134 135 209 135 194 105 189 96 180 89
Circle -7500403 true true 47 195 58
Circle -7500403 true true 195 195 58

circle
false
0
Circle -7500403 true true 0 0 300

circle 2
false
0
Circle -7500403 true true 0 0 300
Circle -16777216 true false 30 30 240

cow
false
0
Polygon -7500403 true true 200 193 197 249 179 249 177 196 166 187 140 189 93 191 78 179 72 211 49 209 48 181 37 149 25 120 25 89 45 72 103 84 179 75 198 76 252 64 272 81 293 103 285 121 255 121 242 118 224 167
Polygon -7500403 true true 73 210 86 251 62 249 48 208
Polygon -7500403 true true 25 114 16 195 9 204 23 213 25 200 39 123

cylinder
false
0
Circle -7500403 true true 0 0 300

dot
false
0
Circle -7500403 true true 90 90 120

face happy
false
0
Circle -7500403 true true 8 8 285
Circle -16777216 true false 60 75 60
Circle -16777216 true false 180 75 60
Polygon -16777216 true false 150 255 90 239 62 213 47 191 67 179 90 203 109 218 150 225 192 218 210 203 227 181 251 194 236 217 212 240

face neutral
false
0
Circle -7500403 true true 8 7 285
Circle -16777216 true false 60 75 60
Circle -16777216 true false 180 75 60
Rectangle -16777216 true false 60 195 240 225

face sad
false
0
Circle -7500403 true true 8 8 285
Circle -16777216 true false 60 75 60
Circle -16777216 true false 180 75 60
Polygon -16777216 true false 150 168 90 184 62 210 47 232 67 244 90 220 109 205 150 198 192 205 210 220 227 242 251 229 236 206 212 183

fish
false
0
Polygon -1 true false 44 131 21 87 15 86 0 120 15 150 0 180 13 214 20 212 45 166
Polygon -1 true false 135 195 119 235 95 218 76 210 46 204 60 165
Polygon -1 true false 75 45 83 77 71 103 86 114 166 78 135 60
Polygon -7500403 true true 30 136 151 77 226 81 280 119 292 146 292 160 287 170 270 195 195 210 151 212 30 166
Circle -16777216 true false 215 106 30

flag
false
0
Rectangle -7500403 true true 60 15 75 300
Polygon -7500403 true true 90 150 270 90 90 30
Line -7500403 true 75 135 90 135
Line -7500403 true 75 45 90 45

flower
false
0
Polygon -10899396 true false 135 120 165 165 180 210 180 240 150 300 165 300 195 240 195 195 165 135
Circle -7500403 true true 85 132 38
Circle -7500403 true true 130 147 38
Circle -7500403 true true 192 85 38
Circle -7500403 true true 85 40 38
Circle -7500403 true true 177 40 38
Circle -7500403 true true 177 132 38
Circle -7500403 true true 70 85 38
Circle -7500403 true true 130 25 38
Circle -7500403 true true 96 51 108
Circle -16777216 true false 113 68 74
Polygon -10899396 true false 189 233 219 188 249 173 279 188 234 218
Polygon -10899396 true false 180 255 150 210 105 210 75 240 135 240

house
false
0
Rectangle -7500403 true true 45 120 255 285
Rectangle -16777216 true false 120 210 180 285
Polygon -7500403 true true 15 120 150 15 285 120
Line -16777216 false 30 120 270 120

leaf
false
0
Polygon -7500403 true true 150 210 135 195 120 210 60 210 30 195 60 180 60 165 15 135 30 120 15 105 40 104 45 90 60 90 90 105 105 120 120 120 105 60 120 60 135 30 150 15 165 30 180 60 195 60 180 120 195 120 210 105 240 90 255 90 263 104 285 105 270 120 285 135 240 165 240 180 270 195 240 210 180 210 165 195
Polygon -7500403 true true 135 195 135 240 120 255 105 255 105 285 135 285 165 240 165 195

line
true
0
Line -7500403 true 150 0 150 300

line half
true
0
Line -7500403 true 150 0 150 150

pentagon
false
0
Polygon -7500403 true true 150 15 15 120 60 285 240 285 285 120

person
false
0
Circle -7500403 true true 110 5 80
Polygon -7500403 true true 105 90 120 195 90 285 105 300 135 300 150 225 165 300 195 300 210 285 180 195 195 90
Rectangle -7500403 true true 127 79 172 94
Polygon -7500403 true true 195 90 240 150 225 180 165 105
Polygon -7500403 true true 105 90 60 150 75 180 135 105

plant
false
0
Rectangle -7500403 true true 135 90 165 300
Polygon -7500403 true true 135 255 90 210 45 195 75 255 135 285
Polygon -7500403 true true 165 255 210 210 255 195 225 255 165 285
Polygon -7500403 true true 135 180 90 135 45 120 75 180 135 210
Polygon -7500403 true true 165 180 165 210 225 180 255 120 210 135
Polygon -7500403 true true 135 105 90 60 45 45 75 105 135 135
Polygon -7500403 true true 165 105 165 135 225 105 255 45 210 60
Polygon -7500403 true true 135 90 120 45 150 15 180 45 165 90

sheep
false
15
Circle -1 true true 203 65 88
Circle -1 true true 70 65 162
Circle -1 true true 150 105 120
Polygon -7500403 true false 218 120 240 165 255 165 278 120
Circle -7500403 true false 214 72 67
Rectangle -1 true true 164 223 179 298
Polygon -1 true true 45 285 30 285 30 240 15 195 45 210
Circle -1 true true 3 83 150
Rectangle -1 true true 65 221 80 296
Polygon -1 true true 195 285 210 285 210 240 240 210 195 210
Polygon -7500403 true false 276 85 285 105 302 99 294 83
Polygon -7500403 true false 219 85 210 105 193 99 201 83

square
false
0
Rectangle -7500403 true true 30 30 270 270

square 2
false
0
Rectangle -7500403 true true 30 30 270 270
Rectangle -16777216 true false 60 60 240 240

star
false
0
Polygon -7500403 true true 151 1 185 108 298 108 207 175 242 282 151 216 59 282 94 175 3 108 116 108

target
false
0
Circle -7500403 true true 0 0 300
Circle -16777216 true false 30 30 240
Circle -7500403 true true 60 60 180
Circle -16777216 true false 90 90 120
Circle -7500403 true true 120 120 60

tree
false
0
Circle -7500403 true true 118 3 94
Rectangle -6459832 true false 120 195 180 300
Circle -7500403 true true 65 21 108
Circle -7500403 true true 116 41 127
Circle -7500403 true true 45 90 120
Circle -7500403 true true 104 74 152

triangle
false
0
Polygon -7500403 true true 150 30 15 255 285 255

triangle 2
false
0
Polygon -7500403 true true 150 30 15 255 285 255
Polygon -16777216 true false 151 99 225 223 75 224

truck
false
0
Rectangle -7500403 true true 4 45 195 187
Polygon -7500403 true true 296 193 296 150 259 134 244 104 208 104 207 194
Rectangle -1 true false 195 60 195 105
Polygon -16777216 true false 238 112 252 141 219 141 218 112
Circle -16777216 true false 234 174 42
Rectangle -7500403 true true 181 185 214 194
Circle -16777216 true false 144 174 42
Circle -16777216 true false 24 174 42
Circle -7500403 false true 24 174 42
Circle -7500403 false true 144 174 42
Circle -7500403 false true 234 174 42

turtle
true
0
Polygon -10899396 true false 215 204 240 233 246 254 228 266 215 252 193 210
Polygon -10899396 true false 195 90 225 75 245 75 260 89 269 108 261 124 240 105 225 105 210 105
Polygon -10899396 true false 105 90 75 75 55 75 40 89 31 108 39 124 60 105 75 105 90 105
Polygon -10899396 true false 132 85 134 64 107 51 108 17 150 2 192 18 192 52 169 65 172 87
Polygon -10899396 true false 85 204 60 233 54 254 72 266 85 252 107 210
Polygon -7500403 true true 119 75 179 75 209 101 224 135 220 225 175 261 128 261 81 224 74 135 88 99

wheel
false
0
Circle -7500403 true true 3 3 294
Circle -16777216 true false 30 30 240
Line -7500403 true 150 285 150 15
Line -7500403 true 15 150 285 150
Circle -7500403 true true 120 120 60
Line -7500403 true 216 40 79 269
Line -7500403 true 40 84 269 221
Line -7500403 true 40 216 269 79
Line -7500403 true 84 40 221 269

wolf
false
0
Polygon -16777216 true false 253 133 245 131 245 133
Polygon -7500403 true true 2 194 13 197 30 191 38 193 38 205 20 226 20 257 27 265 38 266 40 260 31 253 31 230 60 206 68 198 75 209 66 228 65 243 82 261 84 268 100 267 103 261 77 239 79 231 100 207 98 196 119 201 143 202 160 195 166 210 172 213 173 238 167 251 160 248 154 265 169 264 178 247 186 240 198 260 200 271 217 271 219 262 207 258 195 230 192 198 210 184 227 164 242 144 259 145 284 151 277 141 293 140 299 134 297 127 273 119 270 105
Polygon -7500403 true true -1 195 14 180 36 166 40 153 53 140 82 131 134 133 159 126 188 115 227 108 236 102 238 98 268 86 269 92 281 87 269 103 269 113

x
false
0
Polygon -7500403 true true 270 75 225 30 30 225 75 270
Polygon -7500403 true true 30 75 75 30 270 225 225 270

@#$#@#$#@
NetLogo 5.3.1
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180

@#$#@#$#@
0
@#$#@#$#@
